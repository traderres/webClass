How to Deploy a Spring Boot Web App to MiniKube
------------------------------------00---------

Assumptions:
 A) You have Docker installed  (needed to run Kubernetes and to run the maven module)
 B) You have Java JDk and Maven installed (needed to compile the webapp)
 C) You have MiniKube installed
 D) You want mvn clean package -PbuildImage    (to build your image file)


References
----------
https://spring.io/guides/gs/spring-boot-kubernetes/


Part 1:  Build the Docker Image
-------------------------------
 1. Edit the webapp/backend/pom.xml
    a. Edit backend/pom.xml

    b. Add this maven profile to the end of the backend/pom.xml


		<profiles>
			...


				<profile>
				  <id>buildImage</id>
				  <build>
					<plugins>
					  <plugin>
						<groupId>org.springframework.boot</groupId>
						<artifactId>spring-boot-maven-plugin</artifactId>
						<version>2.7.1</version>
						<configuration>
						  <addResources>true</addResources>
						</configuration>

						<executions>
						  <execution>
							<id>build-image</id>
							<goals>
							  <goal>build-image</goal>
							</goals>
							<phase>package</phase>
							<configuration>
							  <imageName>my-spring-boot-image-on-install</imageName>
							</configuration>
						  </execution>
					  </executions>
					  </plugin>

					</plugins>
				  </build>

				</profile>

			...

		</profiles>



 2. Build the webapp JAR
    unix> cd ~/intellijProject/angularApp1
    unix> mvn clean package -Pprod

 3. Run the regular JAR
    unix> java jar ./backend/target/backend-exec.jar

 4. Verify you can connect to it:
    a. Start up a browser
    b. Connect to http://localhost:8080/app1
    c. Press Control-C to stop your java JAR

 5. Build the docker image
    unix> mvn clean package -PbuildImage

    [INFO]  Successfully built image 'docker.io/library/my-spring-boot-image-on-install:latest'

 6. Run the docker image
    NOTE:  Use the --network=host so that the docker image can connect to your local database and local ES
    unix> docker run --network=host -p 8080:8080  docker.io/library/my-spring-boot-image-on-install:latest

 7. Connect to the webapp
    a. Open a browser
    b. Connect to http://localhost:8080/app1
    c. Press Control-C to stop the docker run



Part 2:  Deploy the Docker Image to MiniKube
--------------------------------------------
 1. Startup minikube
    unix> minikube start   # do not run as root

    You should see this:
	ðŸ˜„  minikube v1.28.0 on Centos 8.4.2105
	âœ¨  Automatically selected the docker driver. Other choices: virtualbox, none, ssh
	ðŸ“Œ  Using Docker driver with root privileges
	ðŸ‘  Starting control plane node minikube in cluster minikube
	ðŸšœ  Pulling base image ...
	ðŸ’¾  Downloading Kubernetes v1.25.3 preload ...
		> preloaded-images-k8s-v18-v1...:  385.44 MiB / 385.44 MiB  100.00% 65.53 M
		> gcr.io/k8s-minikube/kicbase:  386.27 MiB / 386.27 MiB  100.00% 46.68 MiB
		> gcr.io/k8s-minikube/kicbase:  0 B [_______________________] ?% ? p/s 6.1s
	ðŸ”¥  Creating docker container (CPUs=2, Memory=7900MB) ...
	ðŸ³  Preparing Kubernetes v1.25.3 on Docker 20.10.20 ...
		â–ª Generating certificates and keys ...
		â–ª Booting up control plane ...
		â–ª Configuring RBAC rules ...
	ðŸ”Ž  Verifying Kubernetes components...
		â–ª Using image gcr.io/k8s-minikube/storage-provisioner:v5
	ðŸŒŸ  Enabled addons: storage-provisioner, default-storageclass
	ðŸ’¡  kubectl not found. If you need it, try: 'minikube kubectl -- get pods -A'


 2. Use kubectl to generate the deployment.yaml file
    unix> export APPNAME=app1
    unix> kubectl create deployment $APPNAME --image=docker.io/library/my-spring-boot-image-on-install:latest --dry-run -o=yaml > /tmp/deployment.yaml
    unix> echo --- >> /tmp/deployment.yaml
    unix> kubectl create service clusterip $APPNAME --tcp=8080:8080 --dry-run -o=yaml >> /tmp/deployment.yaml

       Your /tmp/deployment.yaml should look something like this:
       ---------------------------------------------------------=
			apiVersion: apps/v1
			kind: Deployment
			metadata:
			  creationTimestamp: null
			  labels:
				app: app1
			  name: app1
			spec:
			  replicas: 1
			  selector:
				matchLabels:
				  app: app1
			  strategy: {}
			  template:
				metadata:
				  creationTimestamp: null
				  labels:
					app: app1
				spec:
				  containers:
				  - image: docker.io/library/my-spring-boot-image-on-install:latest
					name: my-spring-boot-image-on-install
					resources: {}
			status: {}
			---
			apiVersion: v1
			kind: Service
			metadata:
			  creationTimestamp: null
			  labels:
				app: app1
			  name: app1
			spec:
			  ports:
			  - name: 8080-8080
				port: 8080
				protocol: TCP
				targetPort: 8080
			  selector:
				app: app1
			  type: ClusterIP
			status:
			  loadBalancer: {}




 3. Edit the /tmp/deployment.yaml file (if needed)
    a. Add this to the spec:containers section
             imagePullPolicy: Never

    When finished, it should look something like this:
		apiVersion: apps/v1
			kind: Deployment
			metadata:
			  creationTimestamp: null
			  labels:
				app: app1
			  name: app1
			spec:
			  replicas: 1
			  selector:
				matchLabels:
				  app: app1
			  strategy: {}
			  template:
				metadata:
				  creationTimestamp: null
				  labels:
					app: app1
				spec:
				  containers:
				  - image: docker.io/library/my-spring-boot-image-on-install:latest
					name: my-spring-boot-image-on-install
					imagePullPolicy: Never
					resources: {}
			status: {}
			---
			apiVersion: v1
			kind: Service
			metadata:
			  creationTimestamp: null
			  labels:
				app: app1
			  name: app1
			spec:
			  ports:
			  - name: 8080-8080
				port: 8080
				protocol: TCP
				targetPort: 8080
			  selector:
				app: app1
			  type: ClusterIP
			status:
			  loadBalancer: {}




 4. Apply the deployment.yaml file
    unix> kubectl apply -f /tmp/deployment.yaml

    You should see the following:
		deployment.apps/app1 created
		service/app1 created


 5. Checkout what's running
    unix> kubectl get all

     You should see something like this:

		NAME                        READY   STATUS             RESTARTS   AGE
		pod/app1-b59d695ff-mvfcj    0/1     ErrImagePull       0          10s                        <-- App 1's POD
		pod/demo-76c455b9d9-clglj   0/1     ImagePullBackOff   0          21h

		NAME                 TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)    AGE
		service/app1         ClusterIP   10.106.202.233   <none>        8080/TCP   10s               <-- App 1's service
		service/kubernetes   ClusterIP   10.96.0.1        <none>        443/TCP    22h

		NAME                   READY   UP-TO-DATE   AVAILABLE   AGE
		deployment.apps/app1   0/1     1            0           10s                                  <-- App 1's deployment
		deployment.apps/demo   0/1     1            0           21h

		NAME                              DESIRED   CURRENT   READY   AGE
		replicaset.apps/app1-b59d695ff    1         1         0       10s                            <-- App 1
		replicaset.apps/demo-76c455b9d9   1         1         0       21h



 6. Verify that the pod is good
    unix> kubectl describe service/app1

    You should see the following:
	   Name:             app1-b59d695ff-mvfcj
	   Namespace:        default
	   Priority:         0
	   Service Account:  default
	   Node:             minikube/192.168.49.2
	   Start Time:       Fri, 16 Dec 2022 17:13:52 -0500
	   Labels:           app=app1
						 pod-template-hash=b59d695ff
	   Annotations:      <none>
	   Status:           Pending
	   IP:               172.17.0.6
	   IPs:
		 IP:           172.17.0.6
	   Controlled By:  ReplicaSet/app1-b59d695ff
	   Containers:
		 my-spring-boot-image-on-install:
		   Container ID:
		   Image:          docker.io/library/my-spring-boot-image-on-install:latest
		   Image ID:
		   Port:           <none>
		   Host Port:      <none>
		   State:          Waiting
			 Reason:       ImagePullBackOff
		   Ready:          False
		   Restart Count:  0
		   Environment:    <none>
		   Mounts:
			 /var/run/secrets/kubernetes.io/serviceaccount from kube-api-access-jxrgr (ro)
	   Conditions:
		 Type              Status
		 Initialized       True
		 Ready             False
		 ContainersReady   False
		 PodScheduled      True
	   Volumes:
		 kube-api-access-jxrgr:
		   Type:                    Projected (a volume that contains injected data from multiple sources)
		   TokenExpirationSeconds:  3607
		   ConfigMapName:           kube-root-ca.crt
		   ConfigMapOptional:       <nil>
		   DownwardAPI:             true
	   QoS Class:                   BestEffort
	   Node-Selectors:              <none>
	   Tolerations:                 node.kubernetes.io/not-ready:NoExecute op=Exists for 300s
									node.kubernetes.io/unreachable:NoExecute op=Exists for 300s
	   Events:
		 Type     Reason     Age                  From               Message
		 ----     ------     ----                 ----               -------
		 Normal   Scheduled  2m41s                default-scheduler  Successfully assigned default/app1-b59d695ff-mvfcj to minikube
		 Normal   Pulling    79s (x4 over 2m41s)  kubelet            Pulling image "docker.io/library/my-spring-boot-image-on-install:latest"
		 Warning  Failed     79s (x4 over 2m41s)  kubelet            Failed to pull image "docker.io/library/my-spring-boot-image-on-install:latest": rpc error: code = Unknown desc = Error response from daemon: pull access denied for my-spring-boot-image-on-install, repository does not exist or may require 'docker login': denied: requested access to the resource is denied
		 Warning  Failed     79s (x4 over 2m41s)  kubelet            Error: ErrImagePull
		 Warning  Failed     54s (x6 over 2m41s)  kubelet            Error: ImagePullBackOff
		 Normal   BackOff    43s (x7 over 2m41s)  kubelet            Back-off pulling image "docker.io/library/my-spring-boot-image-on-install:latest"

 7. Fix the pod so it can pull the image


 8. Connect to the application in kubernetes
    unix> kubectl port-forward svc/demo 8080:8080




How to List Docker Images
-------------------------
    unix> docker images -a

    You should see the following:
		REPOSITORY                         TAG                     IMAGE ID       CREATED         SIZE
		paketobuildpacks/run               base-cnb                e06d1d37657c   45 hours ago    87MB
		gcr.io/k8s-minikube/kicbase        v0.0.36                 866c1fe4e3f2   7 weeks ago     1.11GB
		paketobuildpacks/run               <none>                  43a6ea5d061e   23 months ago   107MB
		alpine                             latest                  d6e46aa2470d   2 years ago     5.57MB
		backend                            1.0-SNAPSHOT            d709a585c01d   42 years ago    269MB       <-- Old image
		paketobuildpacks/builder           base                    ab7352030ed4   42 years ago    1.32GB
		<none>                             <none>                  fb44c8e578d0   42 years ago    317MB
		<none>                             <none>                  0b9a62f87d5d   42 years ago    269MB
		gcr.io/paketo-buildpacks/builder   base-platform-api-0.3   d86b37118457   42 years ago    669MB



How to Remove Docker Image
--------------------------
    unix> docker rmi d709a585c01d -f