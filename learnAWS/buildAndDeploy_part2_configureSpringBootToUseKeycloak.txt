How to Configure Spring Boot to use one of 3 security modes: localdev, citadel, and keycloak
-----------------------------------------------------------------------
Problem:  I want my webapp to run in localdev mode (when debugging locally)
          I want my webapp to run in citadel  mode (when running in a BDP)
          I want my webapp to run in keycloak mode (when running in AWS/Kubernetes with a keycloak security provider)




Configure the Java Security so that it has 3 modes:  localdev, citadel, and keycloak
------------------------------------------------------------------------------------
The application.yaml property called security.mode will have 3 possible values:
     localdev  (for running in local http mode)
     citadel   (for running in a BDP using citadel security)
     keycloak  (for running in AWS using keycloak security)

     The citadel/keycloak/localdev java classes are all referenced by the AuthenticationService
     -- So, all developers should have to do is change the AuthenticationService class


 1. Rename UserInfo to MyUserInfo


 2. Add this java package:  backend/src/main/java/....security/citadel
    a. Add this java package:   backend/src/main/java/com/lessons/security/citadel

	b. Add this class:  MyAuthenticationManagerCitadel

			package com.lessons.security.citadel;

			import com.lessons.security.AuthenticationService;
			import com.lessons.security.MyUserInfo;
			import org.slf4j.Logger;
			import org.slf4j.LoggerFactory;
			import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
			import org.springframework.security.authentication.AuthenticationManager;
			import org.springframework.security.core.Authentication;
			import org.springframework.security.core.AuthenticationException;
			import org.springframework.security.core.context.SecurityContextHolder;
			import org.springframework.security.web.authentication.preauth.PreAuthenticatedAuthenticationToken;
			import org.springframework.stereotype.Component;

			import javax.annotation.Resource;


			@ConditionalOnProperty(name="security.mode", havingValue="citadel", matchIfMissing=false)
			@Component
			public class MyAuthenticationManagerCitadel implements AuthenticationManager {
				private static final Logger logger = LoggerFactory.getLogger(MyAuthenticationManagerCitadel.class);

				@Resource
				private AuthenticationService authenticationService;



				@Override
				public Authentication authenticate(Authentication authentication) throws AuthenticationException {
					logger.debug("authenticate() started.   authentication={}", authentication);

					if (SecurityContextHolder.getContext().getAuthentication() != null) {
						// Users is already authenticated, so do nothing
						return  SecurityContextHolder.getContext().getAuthentication();
					}

					// Generate the MyUserInfo object for a citadel user
					MyUserInfo myUserInfo = authenticationService.generateUserInfoUsingCitadel(authentication);

					// Return an AuthenticationToken object
					PreAuthenticatedAuthenticationToken preApprovedToken = new PreAuthenticatedAuthenticationToken(myUserInfo, null, myUserInfo.getAuthorities());
					preApprovedToken.setAuthenticated(true);

					logger.debug("authenticate() finished.  preApprovedToken={}", preApprovedToken);
					return preApprovedToken;
				}
			}



    c. Add this class:  MyRequestHeaderAuthFilterCitadel

			package com.lessons.security.citadel;

			import org.slf4j.Logger;
			import org.slf4j.LoggerFactory;
			import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
			import org.springframework.security.web.authentication.preauth.RequestHeaderAuthenticationFilter;
			import org.springframework.stereotype.Component;

			import javax.annotation.PostConstruct;
			import javax.annotation.Resource;
			import javax.servlet.http.HttpServletRequest;

			@ConditionalOnProperty(name="security.mode", havingValue="citadel", matchIfMissing=false)
			@Component
			public class MyRequestHeaderAuthFilterCitadel extends RequestHeaderAuthenticationFilter
			{
				private static final Logger logger = LoggerFactory.getLogger(MyRequestHeaderAuthFilterCitadel.class);

				@Resource
				private MyAuthenticationManagerCitadel myAuthenticationManagerCitadel;


				@PostConstruct
				public void init() {
					this.setAuthenticationManager(myAuthenticationManagerCitadel);
				}


				/*
				 * getPreAuthenticatedPrincipal()
				 *
				 * This is called when a request is made, the returned object identifies the
				 * user and will either be {@literal null} or a String.
				 *
				 * This method will throw an exception if
				 * exceptionIfHeaderMissing is set to true (default) and the required header is missing.
				 */
				@Override
				protected Object getPreAuthenticatedPrincipal(HttpServletRequest request)
				{
					// Get the principal from the header
					String userDnFromHeader = request.getHeader("SSL_CLIENT_S_DN");

					// If this method returns null, then the user will see a 403 Forbidden Message
					logger.debug("getPreAuthenticatedPrincipal() returns -->{}<--", userDnFromHeader);
					return userDnFromHeader;
				}

			}



    d. Add this class:  SpringSecurityConfigForCitadel

			package com.lessons.security.citadel;

			import org.slf4j.Logger;
			import org.slf4j.LoggerFactory;
			import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
			import org.springframework.context.annotation.Bean;
			import org.springframework.context.annotation.Configuration;
			import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;
			import org.springframework.security.config.annotation.web.builders.HttpSecurity;
			import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
			import org.springframework.security.config.http.SessionCreationPolicy;
			import org.springframework.security.web.SecurityFilterChain;

			import javax.annotation.Resource;


			@Configuration
			@ConditionalOnProperty(name="security.mode", havingValue="citadel", matchIfMissing=false)
			@EnableWebSecurity
			@EnableGlobalMethodSecurity(prePostEnabled = true)         // Needed for @PreAuthorize to work
			public class SpringSecurityConfigForCitadel  {

				private static final Logger logger = LoggerFactory.getLogger(SpringSecurityConfigForCitadel.class);


				@Resource
				private MyRequestHeaderAuthFilterCitadel myRequestHeaderAuthFilterCitadel;


				/**
				 * Configure Spring Security for Citadel Authentication
				 *
				 * @param aHttpSecurity holds the HttpSecurity object that is configured to setup Spring Security
				 * @return SecurityFilterChain object that will implement security
				 * @throws Exception if something goes wrong
				 */
				@Bean
				public SecurityFilterChain securityFilterChain(HttpSecurity aHttpSecurity) throws Exception {

					// Running in HTTPS mode using citadel for authentication
					aHttpSecurity.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.ALWAYS)
							.and()
							.authorizeRequests()    // Filters out any URLs that are ignored.  This should be before any authorization filters
							.antMatchers("/resources/**", "/error").permitAll()
							.antMatchers("/**").access("hasRole('ROLE_USER_FOUND_IN_VALID_LIST_OF_USERS')")   // All users must have the grantedAuthority called ROLE_UserFoundInLdap to view all pages
							.and()
							.requiresChannel().antMatchers("/**").requiresSecure()    // Redirect http to https
							.and()
							.addFilter(this.myRequestHeaderAuthFilterCitadel)          // Pull the DN from the user's X509 certificate or header
							.headers().frameOptions().disable()               // By default X-Frame-Options is set to denied.  Disable frameoptions to let this webapp work in OWF
							.and()
							.anonymous().disable()
							.csrf().disable();

					return aHttpSecurity.build();
				}

			}


 3. Add this java package:  backend/src/main/java/....security/localdev
    a. Add this java package:   backend/src/main/java/com/lessons/security/localdev

	b. Add this class:  MyAuthenticationManagerLocalDev

			package com.lessons.security.localdev;

			import com.lessons.security.AuthenticationService;
			import com.lessons.security.MyUserInfo;
			import org.slf4j.Logger;
			import org.slf4j.LoggerFactory;
			import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
			import org.springframework.security.authentication.AuthenticationManager;
			import org.springframework.security.core.Authentication;
			import org.springframework.security.core.AuthenticationException;
			import org.springframework.security.core.context.SecurityContextHolder;
			import org.springframework.security.web.authentication.preauth.PreAuthenticatedAuthenticationToken;
			import org.springframework.stereotype.Component;

			import javax.annotation.Resource;

			@ConditionalOnProperty(name="security.mode", havingValue="localdev", matchIfMissing=false)
			@Component
			public class MyAuthenticationManagerLocalDev implements AuthenticationManager {
				private static final Logger logger = LoggerFactory.getLogger(MyAuthenticationManagerLocalDev.class);

				@Resource
				private AuthenticationService authenticationService;


				@Override
				public Authentication authenticate(Authentication authentication) throws AuthenticationException {
					logger.debug("authenticate() started.   authentication={}", authentication);

					if (SecurityContextHolder.getContext().getAuthentication() != null) {
						// Users is already authenticated, so do nothing
						return SecurityContextHolder.getContext().getAuthentication();
					}

					// Generate a MyUserInfo for a local dev user
					MyUserInfo myUserInfo = authenticationService.generateUserInfoForDevelopment(authentication);

					// Return an AuthenticationToken object
					PreAuthenticatedAuthenticationToken preApprovedToken = new PreAuthenticatedAuthenticationToken(myUserInfo, null, myUserInfo.getAuthorities());
					preApprovedToken.setAuthenticated(true);

					logger.debug("authenticate() finished.  preApprovedToken={}", preApprovedToken);
					return preApprovedToken;
				}

			}



    c. Add this class:  MyRequestHeaderAuthFilterLocalDev

			package com.lessons.security.localdev;

			import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
			import org.springframework.security.web.authentication.preauth.RequestHeaderAuthenticationFilter;
			import org.springframework.stereotype.Component;

			import javax.annotation.PostConstruct;
			import javax.annotation.Resource;
			import javax.servlet.http.HttpServletRequest;

			@ConditionalOnProperty(name="security.mode", havingValue="localdev", matchIfMissing=false)
			@Component
			public class MyRequestHeaderAuthFilterLocalDev extends RequestHeaderAuthenticationFilter
			{

				@Resource
				private MyAuthenticationManagerLocalDev myAuthenticationManagerLocalDev;


				@PostConstruct
				public void init() {
					this.setAuthenticationManager(this.myAuthenticationManagerLocalDev);
				}



				/*
				 * getPreAuthenticatedPrincipal()
				 *
				 * This is called when a request is made, the returned object identifies the
				 * user and will either be {@literal null} or a String.
				 */
				@Override
				protected Object getPreAuthenticatedPrincipal(HttpServletRequest request)
				{
					return "bogus_user";
				}

			}



    d. Add this class:  SpringSecurityConfigForLocalDev

			package com.lessons.security.localdev;

			import org.slf4j.Logger;
			import org.slf4j.LoggerFactory;
			import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
			import org.springframework.context.annotation.Bean;
			import org.springframework.context.annotation.Configuration;
			import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;
			import org.springframework.security.config.annotation.web.builders.HttpSecurity;
			import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
			import org.springframework.security.config.http.SessionCreationPolicy;
			import org.springframework.security.web.SecurityFilterChain;

			import javax.annotation.Resource;


			@Configuration
			@ConditionalOnProperty(name="security.mode", havingValue="localdev", matchIfMissing=false)
			@EnableWebSecurity
			@EnableGlobalMethodSecurity(prePostEnabled = true)         // Needed for @PreAuthorize to work
			public class SpringSecurityConfigForLocalDev {

				private static final Logger logger = LoggerFactory.getLogger(SpringSecurityConfigForLocalDev.class);

				@Resource
				private MyRequestHeaderAuthFilterLocalDev myRequestHeaderAuthFilterLocalDev;



				/**
				 * Configure Spring Security for Local Dev (FAKE) authentication
				 *
				 * @param aHttpSecurity holds the HttpSecurity object that is configured to setup Spring Security
				 * @return SecurityFilterChain object that will implement security
				 * @throws Exception if something goes wrong
				 */
				@Bean
				public SecurityFilterChain securityFilterChain(HttpSecurity aHttpSecurity) throws Exception {

					// Running in http mode    (no SSL encryption)
					aHttpSecurity
							.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.ALWAYS)
							.and()
								.authorizeRequests()     // Filters out any URLs that are ignored.  This should be before any authorization filters
								.antMatchers("/resources/**", "/error").permitAll()
								.antMatchers("/**").access("hasRole('ROLE_USER_FOUND_IN_VALID_LIST_OF_USERS')")   // All users must have the grantedAuthority called ROLE_USER_FOUND_IN_VALID_LIST_OF_USERS to view all pages
								.anyRequest().authenticated()
							.and()
								.requiresChannel().antMatchers("/**").requiresInsecure()
							.and()
								.addFilter(this.myRequestHeaderAuthFilterLocalDev)
								.headers().frameOptions().disable()                       // By default X-Frame-Options is set to denied.
							.and()
								.anonymous().disable()
								.csrf().disable();


					return aHttpSecurity.build();
				}


			}


 4. Add this java package:  backend/src/main/java/....security/keycloak
    a. Add this java package:   backend/src/main/java/com/lessons/security/keycloak

	b. Add this class:  MyDefaultOidcUser

			package com.lessons.security.keycloak;

			import com.lessons.security.MyUserInfo;
			import org.springframework.security.core.GrantedAuthority;
			import org.springframework.security.oauth2.core.oidc.OidcIdToken;
			import org.springframework.security.oauth2.core.oidc.OidcUserInfo;
			import org.springframework.security.oauth2.core.oidc.user.DefaultOidcUser;

			import java.util.Collection;

			public class MyDefaultOidcUser extends DefaultOidcUser {

				private MyUserInfo myUserInfo;

				public MyDefaultOidcUser(Collection<? extends GrantedAuthority> authorities, OidcIdToken idToken) {
					super(authorities, idToken);
				}

				public MyDefaultOidcUser(Collection<? extends GrantedAuthority> authorities, OidcIdToken idToken, String nameAttributeKey) {
					super(authorities, idToken, nameAttributeKey);
				}

				public MyDefaultOidcUser(Collection<? extends GrantedAuthority> authorities, OidcIdToken idToken, OidcUserInfo userInfo) {
					super(authorities, idToken, userInfo);
				}

				public MyDefaultOidcUser(Collection<? extends GrantedAuthority> authorities, OidcIdToken idToken, OidcUserInfo userInfo, String nameAttributeKey) {
					super(authorities, idToken, userInfo, nameAttributeKey);
				}

				public MyDefaultOidcUser(MyUserInfo aUserInfo, Collection<? extends GrantedAuthority> authorities, OidcIdToken idToken, OidcUserInfo userInfo) {
					super(authorities, idToken, userInfo);
					this.myUserInfo = aUserInfo;
				}


				public MyUserInfo getMyUserInfo() {
					return this.myUserInfo;
				}
			}


    c. Add this class:  OAuth2LoginSuccessHandler

			package com.lessons.security.keycloak;

			import com.lessons.security.AuthenticationService;
			import org.slf4j.Logger;
			import org.slf4j.LoggerFactory;
			import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
			import org.springframework.security.core.Authentication;
			import org.springframework.security.web.authentication.SavedRequestAwareAuthenticationSuccessHandler;
			import org.springframework.stereotype.Component;

			import javax.annotation.Resource;
			import javax.servlet.ServletException;
			import javax.servlet.http.HttpServletRequest;
			import javax.servlet.http.HttpServletResponse;
			import java.io.IOException;

			/*
			 * Create a success handler class that extends SavedRequestAwareAuthenticationSuccessHandler
			 * -- This ensures that upon successful authentication, the user is taken to the user's ORIGINAL url
			 */
			@Component
			@ConditionalOnProperty(name="security.mode", havingValue="keycloak", matchIfMissing=false)
			public class OAuth2LoginSuccessHandler extends SavedRequestAwareAuthenticationSuccessHandler {
				private static final Logger logger = LoggerFactory.getLogger(OAuth2LoginSuccessHandler.class);

				@Resource
				private AuthenticationService authenticationService;

				@Override
				public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response,
						                            Authentication authentication) throws IOException, ServletException {

					logger.debug("onAuthenticationSuccess() started");

					// The user successfully authenticated against the OAUTH2 Server

					// Create the UserInfo object and set it as the principal
					//   1) Replace the OAuth2 Principal object with our own UserInfo object
					//   2) Update the database to indicate that the user successfully logged-in
					this.authenticationService.onAuthenticationSuccessForOauth2(request, response, authentication);


					// Proceed to the user's original URL
					super.onAuthenticationSuccess(request, response, authentication);
				}


			}



    d. Add this class:  SpringSecurityConfigForKeycloak

			package com.lessons.security.keycloak;

			import com.lessons.security.AuthenticationService;
			import com.lessons.security.MyUserInfo;
			import org.slf4j.Logger;
			import org.slf4j.LoggerFactory;
			import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
			import org.springframework.boot.web.servlet.FilterRegistrationBean;
			import org.springframework.context.annotation.Bean;
			import org.springframework.context.annotation.Configuration;
			import org.springframework.core.Ordered;
			import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;
			import org.springframework.security.config.annotation.web.builders.HttpSecurity;
			import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
			import org.springframework.security.config.http.SessionCreationPolicy;
			import org.springframework.security.oauth2.client.oidc.userinfo.OidcUserRequest;
			import org.springframework.security.oauth2.client.oidc.userinfo.OidcUserService;
			import org.springframework.security.oauth2.client.userinfo.OAuth2UserService;
			import org.springframework.security.oauth2.core.oidc.user.OidcUser;
			import org.springframework.security.web.SecurityFilterChain;
			import org.springframework.web.filter.ForwardedHeaderFilter;

			import javax.annotation.Resource;
			import javax.servlet.DispatcherType;


			@Configuration
			@ConditionalOnProperty(name="security.mode", havingValue="keycloak", matchIfMissing=false)
			@EnableWebSecurity
			@EnableGlobalMethodSecurity(prePostEnabled = true)         // Needed for @PreAuthorize to work
			public class SpringSecurityConfigForKeycloak  {

				private static final Logger logger = LoggerFactory.getLogger(SpringSecurityConfigForKeycloak.class);


				@Resource
				private OAuth2LoginSuccessHandler oAuth2LoginSuccessHandler;

				@Resource
				private AuthenticationService authenticationService;



				/**
				 * Configure Spring Security for Keycloak or OAUTH2 Authentication
				 *
				 * @param aHttpSecurity holds the HttpSecurity object that is configured to setup Spring Security
				 * @return SecurityFilterChain object that will implement security
				 * @throws Exception if something goes wrong
				 */
				@Bean
				public SecurityFilterChain securityFilterChain(HttpSecurity aHttpSecurity) throws Exception {

					// Running in https mode with OAuth2 authentication
					aHttpSecurity.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.ALWAYS)
							.and()
								.authorizeRequests()
								.antMatchers("/assets/**",  "**.js", "**.css",  "/error").permitAll()
								.antMatchers("/**").access("hasRole('ROLE_USER_FOUND_IN_VALID_LIST_OF_USERS')")   // All users must have the grantedAuthority called ROLE_USER_FOUND_IN_VALID_LIST_OF_USERS to view all pages
								.anyRequest()
								.authenticated()
							.and()
								.requiresChannel().anyRequest().requiresSecure()
							.and()
							.oauth2Login()

								/*
								 * Update the Principal object stored in the session
								 * Replace the defaultOidcUser with MyDefaultOidcUser object   (that holds the additional MyUserInfo)
								 */
								.userInfoEndpoint(userInfo -> userInfo
										.oidcUserService(this.oidcUserService()))


								/*
								 * The oAuth2LoginSuccessHandler success handler class will do 2 things:
								 *   1) Update the database to indicate that the user successfully authenticated
								 *   2) Redirect the user from keycloak to the user's ORIGINAL requested url (because it extends SavedRequestAwareAuthenticationSuccessHandler)
								 */
								.successHandler(this.oAuth2LoginSuccessHandler)

							.and()
								.csrf().disable();



					return aHttpSecurity.build();
				}


				/**
				 * Generate a new principal pboject that holds MyUserInfo *AND* the original token info from Keycloak
				 *
				 * @return MyDefaultOidcUser object
				 */
				private OAuth2UserService<OidcUserRequest, OidcUser> oidcUserService() {
					final OidcUserService delegate = new OidcUserService();

					return (OidcUserRequest aOidcUserRequest) -> {
						// Get the OidcUser object (that holds information from Keycloak)
						OidcUser oidcUser = delegate.loadUser(aOidcUserRequest);

						// Get the MyUserInfo object (that holds additional info from our database)
						MyUserInfo myUserInfo = this.authenticationService.generateUserInfoWithOauth2InfoFromKeyCloak(oidcUser);

						// Create a new Principal object that holds MyUserInfo *AND* the original token information from keycloak
						MyDefaultOidcUser myDefaultOidcUser = new MyDefaultOidcUser(myUserInfo, myUserInfo.getAuthorities(), oidcUser.getIdToken(), oidcUser.getUserInfo());
						return myDefaultOidcUser;
					};
				}



				@Bean
				public FilterRegistrationBean<ForwardedHeaderFilter> forwardedHeaderFilter() {
					// ForwardedHeaderFilter handles non-standard headers
					//   X-Forwarded-Host, X-Forwarded-Port, X-Forwarded-Proto, X-Forwarded-Ssl, and X-Forwarded-Prefix.
					ForwardedHeaderFilter filter = new ForwardedHeaderFilter();

					FilterRegistrationBean<ForwardedHeaderFilter> registration = new FilterRegistrationBean<>(filter);
					registration.setDispatcherTypes(DispatcherType.REQUEST, DispatcherType.ASYNC, DispatcherType.ERROR);
					registration.setOrder(Ordered.HIGHEST_PRECEDENCE);
					return registration;
				}
			}


 5. Add AuthenticationService to Security/

		package com.lessons.security;

		import com.lessons.models.ConflictingRolesDTO;
		import com.lessons.models.InitialUserInfoDTO;
		import com.lessons.security.keycloak.MyDefaultOidcUser;
		import com.lessons.services.UserService;
		import org.apache.commons.lang3.StringUtils;
		import org.slf4j.Logger;
		import org.slf4j.LoggerFactory;
		import org.springframework.beans.factory.annotation.Value;
		import org.springframework.security.core.Authentication;
		import org.springframework.security.core.GrantedAuthority;
		import org.springframework.security.core.authority.SimpleGrantedAuthority;
		import org.springframework.security.oauth2.core.oidc.user.OidcUser;
		import org.springframework.security.web.authentication.preauth.PreAuthenticatedAuthenticationToken;
		import org.springframework.stereotype.Service;

		import javax.annotation.Resource;
		import javax.servlet.ServletException;
		import javax.servlet.http.HttpServletRequest;
		import javax.servlet.http.HttpServletResponse;
		import java.io.IOException;
		import java.net.URLDecoder;
		import java.util.ArrayList;
		import java.util.List;
		import java.util.Map;
		import java.util.regex.Matcher;
		import java.util.regex.Pattern;

		@Service
		public class AuthenticationService {

			private static final Logger logger = LoggerFactory.getLogger(AuthenticationService.class);

			@Resource
			private UserService userService;

			@Resource
			private HttpServletRequest httpServletRequest;

			@Value("${extract-username-from-auth-header:true}")
			private boolean lookForUsernameInAuthoritiesHeader;



			private static final Pattern patExtractCN = Pattern.compile("cn=(.*?)(?:,|/|\\z)", Pattern.CASE_INSENSITIVE);
			private static final Pattern patMatchRole = Pattern.compile("ROLE:(.*?)(?:;|\\z)", Pattern.CASE_INSENSITIVE);
			private static final Pattern patExtractName = Pattern.compile("name:(.*?)(?:;|\\z)", Pattern.CASE_INSENSITIVE);



			/**
			 * The user has successfully authenticated against an Oauth2 (Keycloak) server
			 * @param aRequest
			 * @param aResponse
			 * @param aAuthentication
			 * @throws Exception
			 */
			public void onAuthenticationSuccessForOauth2(HttpServletRequest aRequest,
														 HttpServletResponse aResponse,
														 Authentication aAuthentication) throws IOException, ServletException {
				logger.debug("onAuthenticationSuccessForOauth2() started");

				MyDefaultOidcUser myDefaultOidcUser = (MyDefaultOidcUser) aAuthentication.getPrincipal();

				// TODO: Mark this user as authenticated


				logger.debug("onAuthenticationSuccessForOauth2() finished");
			}







			private static String getCnValueFromLongDnString(String userDN) {
				logger.debug("getCnValueFromLongDnString()  userDN={}", userDN);
				String cnValue = null;
				// Use the regular expression pattern to getByUserId the value part of "CN=value"
				Matcher matcher = patExtractCN.matcher(userDN);
				if (matcher.find()) {
					cnValue = matcher.group(1);
				}

				logger.debug("getCnValueFromLongDnString() returns -->{}<--", cnValue);
				return cnValue;
			}



			/**
			 * header(X-BDP-User) holds -AUTH:FOUO;AUTH:U;AUTH:USA;GROUP:BDPUSERS;NAME:bdptest_u_fouo;ROLE:ANALYTIC_RUNNER;ROLE:BDP_ADMIN;ROLE:CITE_USER;ROLE:DATA_ADMIN;ROLE:KIBANA_ADMIN;ROLE:LOGS;ROLE:METRICS;ROLE:OWF_ADMIN;ROLE:OWF_USER;ROLE:UNITY_ADMIN<---
			 * Pull every ROLE:role name entry out of the header and insert it into a list of GrantedAuthority objects
			 * @return List of GrantedAuthority objects
			 */
			private List<GrantedAuthority> getAuthoritiesFromHeaderValue() {
				List<GrantedAuthority> grantedRoles = new ArrayList<>();

				// header(X-BDP-User) holds -AUTH:FOUO;AUTH:U;AUTH:USA;GROUP:BDPUSERS;NAME:bdptest_u_fouo;ROLE:ANALYTIC_RUNNER;ROLE:BDP_ADMIN;ROLE:CITE_USER;ROLE:DATA_ADMIN;ROLE:KIBANA_ADMIN;ROLE:LOGS;ROLE:METRICS;ROLE:OWF_ADMIN;ROLE:OWF_USER;ROLE:UNITY_ADMIN<---
				String xbdpUserHeaderValue = httpServletRequest.getHeader("X-BDP-User");
				logger.debug("In getAuthoritiesFromHeaderValue():  header-->{}<--", xbdpUserHeaderValue);
				if (StringUtils.isEmpty(xbdpUserHeaderValue)) {
					// The header is empty -- so return an empty list
					logger.warn("Warning in getAuthoritiesFromHeaderValue():  The X-BDP-User header had nothing in it.  This should never happen.");
					return grantedRoles;
				}

				// Pull every string that starts with ROLE: and add it to the list
				Matcher matcher = patMatchRole.matcher(xbdpUserHeaderValue);
				while (matcher.find()) {
					String roleName = matcher.group(1);
					logger.debug("Found a role:  roleName={}", roleName);
					String roleNameWithPrefix = "ROLE_" + roleName;
					grantedRoles.add(new SimpleGrantedAuthority(roleNameWithPrefix));
				}

				logger.debug("getAuthoritiesFromHeaderValue() returns -->{}<--", StringUtils.join(grantedRoles, ","));
				return grantedRoles;
			}





			private String getUsernameFromAuthoritiesHeader() {
				try {
					String username = null;

					// Get the contents of the header called "X-BDP-User"
					// If using a regular CAC cert, then the header holds "AUTH:FOUO;AUTH:U;AUTH:USA;GROUP:BDPUSERS;NAME:bdptest_u_fouo;ROLE:ANALYTIC_RUNNER;ROLE:BDP_ADMIN;ROLE:CITE_USER;ROLE:DATA_ADMIN;ROLE:KIBANA_ADMIN;ROLE:LOGS;ROLE:METRICS;ROLE:OWF_ADMIN;ROLE:OWF_USER;ROLE:UNITY_ADMIN"
					String xbdpUserHeaderValue = httpServletRequest.getHeader("X-BDP-User");

					logger.debug("In getUsernameFromAuthoritiesHeader():  header-->{}<--", xbdpUserHeaderValue);


					if (StringUtils.isEmpty(xbdpUserHeaderValue)) {
						// The header is empty -- so return an empty list
						throw new RuntimeException("Error in getUsernameFromAuthoritiesHeader():  The X-BDP-User header had nothing in it.  This should never happen.");
					}


					// Extract the username from this non-ECA cert.
					// ASSUMPTION:  The BDP header looks like this:
					//                  ...name:JOHN.SMITH.123456;.....
					//
					//              The extracted username should be this:
					//                   JOHN.SMITH.123456
					Matcher matcher = patExtractName.matcher(xbdpUserHeaderValue);
					if (matcher.find()) {
						username = matcher.group(1);
					}

					if (StringUtils.contains(username, "%20")) {
						// The username contains encoded chars.  So, decode it.  This causes %20 --> " " and %3A --> ":"
						username = URLDecoder.decode(username, "UTF-8");
					}

					logger.debug("getUsernameFromAuthoritiesHeader() returns -->{}<--", username);
					return username;
				}
				catch (Exception e) {
					RuntimeException re = new RuntimeException(e);
					re.setStackTrace(e.getStackTrace());
					throw re;
				}
			}


			/**
			 * Generate the MyUserInfo object for a KEYCLOAK user
			 *
			 * @param aOidcUser holds information from keycloak
			 * @return MyUserInfo object
			 */
			public MyUserInfo generateUserInfoWithOauth2InfoFromKeyCloak(OidcUser aOidcUser) {
				logger.debug("generateUserInfoWithOauth2InfoFromKeyCloak() started.  aOidcUser={}", aOidcUser);
				String certUsername = aOidcUser.getName();

				List<GrantedAuthority> oauth2RolesGranted = new ArrayList<>();

				// Get the roles from keycloak and put them into the object called oauth2RolesGranted
				Map<String, Object> realmAccessMap = (Map<String, Object>) aOidcUser.getAttributes().get("realm_access");
				if ((realmAccessMap != null) && (realmAccessMap.size() == 1)) {
					List<String> roleNames = (List<String>) realmAccessMap.get("roles");

					if (roleNames != null) {
						for (String roleName: roleNames) {
							GrantedAuthority grantedAuthority = new SimpleGrantedAuthority("ROLE_" + roleName);
							oauth2RolesGranted.add(grantedAuthority);
						}
					}

				}

				if (oauth2RolesGranted.size() > 0) {
					oauth2RolesGranted.add(new SimpleGrantedAuthority("ROLE_USER_FOUND_IN_VALID_LIST_OF_USERS"));
				}

				ConflictingRolesDTO conflictingRolesDTO = new ConflictingRolesDTO(oauth2RolesGranted);


				// Get the user's userId from the database (or generate one)
				// NOTE:  Use the non-synchronized version of this method when running in local dev mode
				InitialUserInfoDTO userInfoDTO = userService.getInitialUserInfoOrInsertRecord(certUsername, oauth2RolesGranted);

				// The list of allRolesGranted = all citadel roles + all internal roles granted
				List<GrantedAuthority> allRolesGranted = new ArrayList<>(oauth2RolesGranted.size() + userInfoDTO.getInternalRolesGranted().size() );
				allRolesGranted.addAll(oauth2RolesGranted);
				allRolesGranted.addAll( userInfoDTO.getInternalRolesGranted());

				// Generate the user's granted access map from all roles granted
				Map<String, Boolean> uiControlAccessMap = userService.generateUiControlAccessMap(allRolesGranted);

				// Create a UserInfo object with information from the database and the keycloak server
				MyUserInfo userInfo = new MyUserInfo()
						.withId( userInfoDTO.getUserId() )
						.withIsLocked( userInfoDTO.getIsLocked() )
						.withUsernameUID(certUsername)
						.withGrantedAuthorities(allRolesGranted)
						.withUiControlAccessMap(uiControlAccessMap)
						.withRolesAreConflicting(conflictingRolesDTO.isRolesAreConflicting())
						.withRolesAreConflictingMessage(conflictingRolesDTO.getRolesAreConflictingMessage())
						.withRegisteredCageCode(   userInfoDTO.getRegisteredCagecode())
						.withUsersFullName(        userInfoDTO.getFullName() )
						.withPrimaryOrgId(         userInfoDTO.getPrimaryOrgId() )
						.withSecondaryOrgId(       userInfoDTO.getSecondaryOrgId() )
						.withUsersListOfCageCodes( userInfoDTO.getUsersListOfCageCodes() )
						.withRegistrationStateId(  userInfoDTO.getRegistrationStateId() );

				return userInfo;
			}



			/**
			 * Generate the MyUserInfo object for a CITADEL user
			 *
			 * @param authentication holds the Authentication objects
			 * @return MyUserInfo that holds information about the authenticated user
			 */
			public MyUserInfo generateUserInfoUsingCitadel(Authentication authentication) {

				logger.debug("generateUserInfoUsingCitadel() started authentication={}", authentication);
				String userDN;

				if (authentication.getPrincipal() instanceof String) {
					userDN = authentication.getPrincipal().toString();
				}
				else {
					PreAuthenticatedAuthenticationToken token = (PreAuthenticatedAuthenticationToken) authentication.getPrincipal();
					userDN = token.getName();
				}
				logger.debug("userDN={}", userDN);

				String certUsername;
				if (lookForUsernameInAuthoritiesHeader) {
					// Get the user's unique username from the authorities header (X-BDP Header) / looking for name:....
					certUsername = getUsernameFromAuthoritiesHeader();
				}
				else {
					// Get the user's unique username from the CN= value in their CAC or certificate / Looking for CN=.....
					certUsername = getCnValueFromLongDnString(userDN);
				}

				// Get the list of roles from the header
				List<GrantedAuthority> citadelRolesGranted = getAuthoritiesFromHeaderValue();

				ConflictingRolesDTO conflictingRolesDTO = new ConflictingRolesDTO(citadelRolesGranted);

				if ((citadelRolesGranted != null) && (citadelRolesGranted.size() > 0)) {
					// This user has atleast one CITADEL authority
					// NOTE:  All granted authorities must start with the "ROLE_" prefix
					citadelRolesGranted.add(new SimpleGrantedAuthority("ROLE_USER_FOUND_IN_VALID_LIST_OF_USERS"));
				}
				else {
					// This user has no roles so throw a runtime exception
					throw new RuntimeException("No roles were found for this user: " + certUsername);
				}


				// Get information about this user from teh Users table (in the database)
				InitialUserInfoDTO userInfoDTO = this.userService.getInitialUserInfoOrInsertRecord(certUsername, citadelRolesGranted);

				// The list of allRolesGranted = all citadel roles + all internal roles granted
				List<GrantedAuthority> allRolesGranted = new ArrayList<>(citadelRolesGranted.size() + userInfoDTO.getInternalRolesGranted().size() );
				allRolesGranted.addAll(citadelRolesGranted);
				allRolesGranted.addAll( userInfoDTO.getInternalRolesGranted());

				// Generate the user's granted access map from all roles granted
				Map<String, Boolean> uiControlAccessMap = userService.generateUiControlAccessMap(allRolesGranted);

				// Create a bogus UserInfo object
				// NOTE:  I am hard-coding the user's userid=25
				MyUserInfo myUserInfo = new MyUserInfo()
						.withId( userInfoDTO.getUserId() )
						.withIsLocked( userInfoDTO.getIsLocked() )
						.withUsernameUID(certUsername)
						.withUsernameDn(userDN)
						.withGrantedAuthorities(allRolesGranted)
						.withUiControlAccessMap(uiControlAccessMap)
						.withRolesAreConflicting(conflictingRolesDTO.isRolesAreConflicting())
						.withRolesAreConflictingMessage(conflictingRolesDTO.getRolesAreConflictingMessage())
						.withRegisteredCageCode(    userInfoDTO.getRegisteredCagecode() )
						.withUsersFullName(         userInfoDTO.getFullName() )
						.withPrimaryOrgId(          userInfoDTO.getPrimaryOrgId() )
						.withSecondaryOrgId(        userInfoDTO.getSecondaryOrgId() )
						.withUsersListOfCageCodes(  userInfoDTO.getUsersListOfCageCodes() )
						.withRegistrationStateId(   userInfoDTO.getRegistrationStateId() );


				return myUserInfo;
			}



			/**
			 * Generate the MyUserInfo object for a local developer user
			 *
			 * @param authentication holds the Authentication objects
			 * @return MyUserInfo that holds information about the authenticated user
			 */
			public MyUserInfo generateUserInfoForDevelopment(Authentication authentication) {
				DevUsers userType = DevUsers.DEV_SUPER_USER_1;

				final String userUID = "my_superuser";
				final String userDN = "3.2.12.144549.1.9.1=#161760312e646576,CN=my_test_su_user,OU=Hosts,O=ZZTop.Org,C=ZZ";
				List<GrantedAuthority> citadelRolesGranted = new ArrayList<>();
				citadelRolesGranted.add(new SimpleGrantedAuthority("ROLE_USER_FOUND_IN_VALID_LIST_OF_USERS"));
				citadelRolesGranted.add(new SimpleGrantedAuthority("ROLE_SUPERUSER"));



				ConflictingRolesDTO conflictingRolesDTO = new ConflictingRolesDTO(citadelRolesGranted);

				// Get information about this user from teh Users table (in the database)
				// NOTE:  Use the synchronized version of this method in development
				InitialUserInfoDTO userInfoDTO = this.userService.getInitialUserInfoOrInsertRecordSynchronized(userUID, citadelRolesGranted);

				// The list of allRolesGranted = all citadel roles + all internal roles granted
				List<GrantedAuthority> allRolesGranted = new ArrayList<>(citadelRolesGranted.size() + userInfoDTO.getInternalRolesGranted().size() );
				allRolesGranted.addAll(citadelRolesGranted);
				allRolesGranted.addAll( userInfoDTO.getInternalRolesGranted());

				// Generate the user's granted access map from all roles granted
				Map<String, Boolean> uiControlAccessMap = userService.generateUiControlAccessMap(allRolesGranted);

				// Create a bogus UserInfo object
				// NOTE:  I am hard-coding the user's userid=25
				MyUserInfo myUserInfo = new MyUserInfo()
						.withId( userInfoDTO.getUserId() )
						.withIsLocked( userInfoDTO.getIsLocked() )
						.withUsernameUID(userUID)
						.withUsernameDn(userDN)
						.withGrantedAuthorities(allRolesGranted)
						.withUiControlAccessMap(uiControlAccessMap)
						.withRolesAreConflicting(conflictingRolesDTO.isRolesAreConflicting())
						.withRolesAreConflictingMessage(conflictingRolesDTO.getRolesAreConflictingMessage())
						.withRegisteredCageCode(   userInfoDTO.getRegisteredCagecode())
						.withUsersFullName(        userInfoDTO.getFullName() )
						.withPrimaryOrgId(         userInfoDTO.getPrimaryOrgId() )
						.withSecondaryOrgId(       userInfoDTO.getSecondaryOrgId() )
						.withUsersListOfCageCodes( userInfoDTO.getUsersListOfCageCodes() )
						.withRegistrationStateId(  userInfoDTO.getRegistrationStateId() );


				// When running in local development, disable the acknowledgement popup
				myUserInfo.setUserAcknowledgedMessage();

				return myUserInfo;
			}

		}


 6. Move code from MyAuthenticationManager to the AuthenticationService
    a. Copy the code from MyAuthenticationManager.loadUsDetailsForDevelopment() to the AuthenticationService.generateUserInfoForDevelopment()
    b. Copy the code from MyAuthenticationManager.loadUserDetailsFromRealSource() to the AuthenticationService.generateUserInfoUsingCitadel()
    c. Update AuthenticationService.generateUserInfoWithOauth2InfoFromKeyCloak() so that it generates the MyUserInfo object
       similarly to AuthenticationService.generateUserInfoUsingCitadel()
    d. Copy any additional methods to AuthenticationService that are missing


 7. Erase these security classes:
		Erase MyAuthenticationManager
		Erase MyRequestHeaderAuthFilter
		Erase SpringSecurityConfig
		Erase SubjectX509PrincipalExtractor


 8. Adjust the ElasticSearchResources to use a username and password
    a. Edit the ElasticSearchResourcesConfig.java

    b. Adds this to the top of the java class:
			@Value("${es.authentication.principal:}")
			private String esPrincipal;

			@Value("${es.authentication.password:}")
			private String esPassword;


    c. Add this if statement to the elasticSearchResources bean

    		        if (StringUtils.isNotBlank(esPrincipal)) {
    					// Set the ES connection username/password
    					Realm realm = new Realm.RealmBuilder()
    							.setPrincipal(esPrincipal)
    							.setPassword(esPassword)
    							.setUsePreemptiveAuth(true)
    							.setScheme(Realm.AuthScheme.BASIC)
    							.build();
    					configBuilder.setRealm(realm);
    				}


        When finished, the bean should look something like this:

			@Bean
			public ElasticSearchResources elasticSearchResources() throws Exception {
				logger.debug("elasticSearchResources()  sslEnabled={} principal={} password={}", this.sslEnabled, this.esPrincipal, this.esPassword);

				// Set the AsyncHttpClient settings
				com.ning.http.client.AsyncHttpClientConfig.Builder configBuilder = new com.ning.http.client.AsyncHttpClientConfig.Builder();
				configBuilder.setReadTimeout(-1);
				configBuilder.setAcceptAnyCertificate(true);
				configBuilder.setFollowRedirect(true);

		        if (StringUtils.isNotBlank(esPrincipal)) {
					// Set the ES connection username/password
					Realm realm = new Realm.RealmBuilder()
							.setPrincipal(esPrincipal)
							.setPassword(esPassword)
							.setUsePreemptiveAuth(true)
							.setScheme(Realm.AuthScheme.BASIC)
							.build();
					configBuilder.setRealm(realm);
				}

				if (sslEnabled) {
					// initialize the sslContext and store it in the configBuilder object
					SSLContext sslContext = generateSslContext();
					configBuilder.setSSLContext(sslContext);
				}

				// Create a new AsyncHttpClient object
				com.ning.http.client.AsyncHttpClientConfig config = configBuilder.build();
				AsyncHttpClient asyncHttpClient = new AsyncHttpClient(config);


				// Store the AsyncHttpClient and elasticSearc url in the ElasticSearchResources object
				// NOTE:  THe elastic search url is injected from the application.yaml
				//        The AsyncHttpClient is constructed with java code
				ElasticSearchResources elasticSearchResources = new ElasticSearchResources(this.elasticSearchUrl, asyncHttpClient);

				// Return a spring bean that holds the AsyncHttpClient and elasticsearch url
				return elasticSearchResources;
			}


 9. Change the UserService.getUserInfo() so it knows where to get MyUserInfo

	 public class UserService {

		@Value("${security.mode}")
		private String securityMode;


		@PostConstruct
		public void init() {
			logger.debug("init() started.  citadelDataSourceEnabled={}  enableSettingLastLoginDateOnLogin={}", citadelDataSourceEnabled, enableSettingLastLoginDateOnLogin);
		}


		public MyUserInfo getUserInfo() {
			if (this.securityMode.equalsIgnoreCase("keycloak")) {
				return getUserInfoFromKeycloak();
			} else {
				return getUserInfoFromNonKeyCloak();
			}
		}


		private MyUserInfo getUserInfoFromNonKeyCloak() {
			// Get the UserInfo object from Spring Security
			SecurityContext securityContext = SecurityContextHolder.getContext();
			if (securityContext == null) {
				throw new RuntimeException("Error in getUserInfoFromNonKeyCloak():  SecurityContext is null.  This should never happen.");
			}

			Authentication auth = securityContext.getAuthentication();
			if (auth == null) {
				throw new RuntimeException("Error in getUserInfoFromNonKeyCloak():  Authentication is null.  This should never happen.");
			}

			MyUserInfo userInfo = (MyUserInfo) auth.getPrincipal();
			if (userInfo == null) {
				throw new RuntimeException("Error in getUserInfoFromNonKeyCloak():  UserInfo is null.  This should never happen.");
			}

			return userInfo;
		}


		private MyUserInfo getUserInfoFromKeycloak() {
			// Get the UserInfo object from Spring Security
			SecurityContext securityContext = SecurityContextHolder.getContext();
			if (securityContext == null) {
				throw new RuntimeException("Error in getUserInfoFromKeycloak():  SecurityContext is null.  This should never happen.");
			}

			Authentication auth = securityContext.getAuthentication();
			if (auth == null) {
				throw new RuntimeException("Error in getUserInfoFromKeycloak():  Authentication is null.  This should never happen.");
			}

			MyDefaultOidcUser myDefaultOidcUser = (MyDefaultOidcUser) auth.getPrincipal();
			if (myDefaultOidcUser == null) {
				throw new RuntimeException("Error in getUserInfoFromKeycloak():  MyDefaultOidcUser is null.  This should never happen.");
			}

			MyUserInfo myUserInfo = myDefaultOidcUser.getMyUserInfo();
			if (myUserInfo == null) {
				throw new RuntimeException("Error in getUserInfoFromKeycloak():  MyUserInfo is null.  This should never happen.");
			}

			return myUserInfo;
		}

	}


10. Adjust application.yaml files

    a. Adjust install-bdp/src/main/assembly/webapp/application.yaml so that security.mode is citadel
			##########################################################
			# Security & SSL Settings
			#
			# Set the security mode to "citadel" so it runs on a BDP
			##########################################################
			security.mode: citadel    # Possible values are localdev, citadel, and keycloak)


    b. Adjust src/main/resources/application.yaml AND src/test/resources/application.yaml so that security.mode holds localdev

			##########################################################
			# Citadel Database Settings
			##########################################################
			citadel.datasource.enabled: false


			##########################################################
			# Security & SSL Settings
			#
			# Set the security mode to "localdev" so it runs locally for a developer
			##########################################################
			security.mode: localdev    # Possible values are localdev, citadel, and keycloak)




11. Verify that the webapp runs locally
    a. Verify that the IntelliJ debugger worker
       1) Activate the full debugger
       2) Verify that the webapp connects to http://localhost:4200

    b. Verify that it works from command line in local dev mode
       1) Compile it to run locally
          unix> mvn clean package -Pprod

       2) Run it locally from command-line
          unix> java -jar ./backend/target/backend-exec.jar

       3) Attempt to connect to http://localhost:8080/app1


12. Build the RDA / Verify it works on dev cluster
    unix> mvn clean package -Pprod -PbuildRda


13. Build the image / Verify it still compiles
    a. Login to docker
       unix> docker login

    b. Build and push the images to the docker container repo
       unix> mvn clean package -Pprod -PbuildImageAndPush




Next Step  Deploy the images to AWS using Keycloak and PKI authentication
-------------------------------------------------------------------------
See learnAWS / buildAndDeploy_part3_setupKubernetesOnAwsClusterAndDeploy

