How to Modify Maven and Security to build as an RDA or Docker Container
-----------------------------------------------------------------------
Problem:  How to modify the builds and security to build all of the artifacts as either RDA (zip files) or docker containers




Configure maven so that we can build using buildRda, buildImage or buildImageAndPush
-------------------------------------------------------------------------------------
 1.  Tell the parent pom.xml which modules to use for the buildImage profile
     a. edit the parent pom.xml
     b. Add this profile


    <profile>
      <!--    B U I L D     I M A G E      P R O F I L E      (for running this app in a container)  -->
      <id>buildImage</id>

      <modules>
        <module>common-backend</module>
        <module>backend</module>
        <module>frontend</module>
        <module>admin-backend</module>
        <module>admin-frontend</module>
        <module>sync-service</module>
      </modules>
    </profile>



 2.  Add the "buildImage" and "buildImageAndPush" profiles to sync-service/pom.xml

    <!--    B U I L D     I M A G E      P R O F I L E      (for running this app in a container)  -->
    <profile>
      <id>buildImage</id>

      <!-- When running this profile, do *NOT* include the src/main/resources/application.yaml in the build -->
      <build>
        <resources>
           <resource>
            <filtering>false</filtering>
            <directory>src/main/resources</directory>
            <excludes>
              <exclude>application.yaml</exclude>
            </excludes>
          </resource>
        </resources>

        <plugins>
          <plugin>
            <!-- Use the jib-maven-plugin to build the container and push it up to a registry [without having to install Docker] -->
            <groupId>com.google.cloud.tools</groupId>
            <artifactId>jib-maven-plugin</artifactId>
            <version>3.3.1</version>

            <executions>
              <execution>
                <phase>package</phase>
                <goals>
                  <!-- Possible goals are build and dockerBuild   -->
                  <!--   The "build"       goal does not require docker / build the image and push it to a repo                 -->
                  <!--   The "dockerBuild" goal requires docker         / build the image and push to the local daemon daemon   -->
                  <goal>dockerBuild</goal>
                </goals>
              </execution>
            </executions>

            <configuration>
              <from>
                <!-- Define the source image that will be executed            -->
                <!-- See https://hub.docker.com/_/eclipse-temurin/tags        -->

                <!-- This source image runs linux with JDK 1.8-362             -->
                <!-- <image>eclipse-temurin:8u362-b09-jdk@sha256:3b83f3fc0d016d7536dfd5e8a98ece451061b7dbb6d5db3ddea2db30b6153b28</image>-->

                <!-- This source image runs linux with JDK 17.07 -->
                <image>eclipse-temurin:17.0.7_7-jdk@sha256:9dd6a19e4819b066aa2bd8e54d5988a49cca29736fe5447cb0a57daa975f8935</image>
              </from>

              <to>
                <!--                <image>527362555097.dkr.ecr.us-gov-west-1.amazonaws.com/poc:${project.artifactId}-${project.version}</image>-->
                <image>traderres/my-private-repo:${user.name}-${project.artifactId}-${project.version}</image>
               </to>


              <extraDirectories>
                <paths>
                  <path>
                    <!-- Copies everything from 'src/main/image_resources' into '/sync-service-/src/main/image_resources' on the container. -->
                    <from>src/main/image_resources</from>
                    <into>/sync-service/src/main/image_resources</into>
                  </path>
                </paths>
              </extraDirectories>

              <container>
                <jvmFlags>
                  <!-- When starting the container, tell Java where to find the application.yaml -->
                  <jvmFlag> -Dspring.config.location=/sync-service/src/main/image_resources/application.yaml</jvmFlag>
                </jvmFlags>
              </container>

            </configuration>

          </plugin>
        </plugins>
      </build>
    </profile>




    <!--    B U I L D     I M A G E    A N D    P U S H        P R O F I L E      (for running this app in a container)  -->
    <profile>
      <id>buildImageAndPush</id>

      <!-- When running this profile, do *NOT* include the src/main/resources/application.yaml in the build -->
      <build>
        <resources>
          <resource>
            <filtering>false</filtering>
            <directory>src/main/resources</directory>
            <excludes>
              <exclude>application.yaml</exclude>
            </excludes>
          </resource>
        </resources>

        <plugins>
          <plugin>
            <!-- Use the jib-maven-plugin to build the container and push it up to a registry [without having to install Docker] -->
            <groupId>com.google.cloud.tools</groupId>
            <artifactId>jib-maven-plugin</artifactId>
            <version>3.3.1</version>

            <executions>
              <execution>
                <phase>package</phase>
                <goals>
                  <!-- Possible goals are build and dockerBuild   -->
                  <!--   The "build"       goal does not require docker / build the image and push it to a repo                 -->
                  <!--   The "dockerBuild" goal requires docker         / build the image and push to the local daemon daemon   -->
                  <goal>build</goal>
                </goals>
              </execution>
            </executions>

            <configuration>
              <from>
                <!-- Define the source image that will be executed            -->
                <!-- See https://hub.docker.com/_/eclipse-temurin/tags        -->

                <!-- This source image runs linux with JDK 1.8-362             -->
                <!-- <image>eclipse-temurin:8u362-b09-jdk@sha256:3b83f3fc0d016d7536dfd5e8a98ece451061b7dbb6d5db3ddea2db30b6153b28</image>-->

                <!-- This source image runs linux with JDK 17.07 -->
                <image>eclipse-temurin:17.0.7_7-jdk@sha256:9dd6a19e4819b066aa2bd8e54d5988a49cca29736fe5447cb0a57daa975f8935</image>
              </from>

              <to>
                <!--                <image>527362555097.dkr.ecr.us-gov-west-1.amazonaws.com/poc:${project.artifactId}-${project.version}</image>-->
                <image>traderres/my-private-repo:${user.name}-${project.artifactId}-${project.version}</image>
              </to>


              <extraDirectories>
                <paths>
                  <path>
                    <!-- Copies everything from 'src/main/image_resources' into '/sync-service-/src/main/image_resources' on the container. -->
                    <from>src/main/image_resources</from>
                    <into>/sync-service/src/main/image_resources</into>
                  </path>
                </paths>
              </extraDirectories>

              <container>
                <jvmFlags>
                  <!-- When starting the container, tell Java where to find the application.yaml -->
                  <jvmFlag> -Dspring.config.location=/sync-service/src/main/image_resources/application.yaml</jvmFlag>
                </jvmFlags>
              </container>

            </configuration>

          </plugin>
        </plugins>
      </build>
    </profile>


	When finished, the sync-service/pom.xml looks something like this:

		<?xml version="1.0" encoding="UTF-8"?>

		<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
		  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
		  <modelVersion>4.0.0</modelVersion>

		  <parent>
			<artifactId>angularApp1</artifactId>
			<groupId>com.lessons</groupId>
			<version>2.2.2-SNAPSHOT</version>
		  </parent>

		  <artifactId>sync-service</artifactId>
		  <version>2.2.2-SNAPSHOT</version>

		  <name>sync-service</name>

		  <properties>
			<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
			<maven.compiler.source>1.8</maven.compiler.source>
			<maven.compiler.target>1.8</maven.compiler.target>
		  </properties>


		  <dependencyManagement>
			<dependencies>

			  <dependency>
				<!-- Tell Spring Boot to use this **OLDER** version of flyway that works with Postgres 9.6 -->
				<groupId>org.flywaydb</groupId>
				<artifactId>flyway-core</artifactId>
				<version>5.2.4</version>
			  </dependency>

			  <dependency>
				<!-- Set the Spring Boot Version -->
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-dependencies</artifactId>
				<version>2.7.3</version>
				<type>pom</type>
				<scope>import</scope>
			  </dependency>

			</dependencies>
		  </dependencyManagement>


		  <dependencies>
			<dependency>
			  <!-- Spring Boot Console Application -->
			  <groupId>org.springframework.boot</groupId>
			  <artifactId>spring-boot-starter</artifactId>
			</dependency>

			<dependency>
			  <!-- Send logging from Java Common Logging to SLF4J -->
			  <groupId>org.slf4j</groupId>
			  <artifactId>jcl-over-slf4j</artifactId>
			  <version>1.7.5</version>
			</dependency>

			<dependency>
			  <!-- SLF4J will use Logback-classic as its logging implementation -->
			  <groupId>ch.qos.logback</groupId>
			  <artifactId>logback-classic</artifactId>
			  <version>1.2.3</version>
			</dependency>

			<dependency>
			  <!-- Hikari Data Source / JDBC Connection Pool -->
			  <groupId>com.zaxxer</groupId>
			  <artifactId>HikariCP</artifactId>
			  <version>3.4.5</version>
			</dependency>

			<dependency>
			  <!-- Provides JdbcTemplate and TransactionTemplate objects to run SQL from Java -->
			  <groupId>org.springframework</groupId>
			  <artifactId>spring-jdbc</artifactId>
			  <version>5.3.21</version>
			</dependency>

			<dependency>
			  <!-- AsyncHttpClient Client implementation (used to make outgoing REST calls out to ES) -->
			  <groupId>com.ning</groupId>
			  <artifactId>async-http-client</artifactId>
			  <version>1.9.40</version>
			</dependency>

			<dependency>
			  <!-- StringUtils Dependency -->
			  <groupId>org.apache.commons</groupId>
			  <artifactId>commons-lang3</artifactId>
			  <version>3.5</version>
			</dependency>

			<dependency>
			  <groupId>org.apache.commons</groupId>
			  <artifactId>commons-collections4</artifactId>
			  <version>4.4</version>
			</dependency>

			<dependency>
			  <!-- Implementation for converting objects to JSON -->
			  <groupId>com.fasterxml.jackson.core</groupId>
			  <artifactId>jackson-databind</artifactId>
			  <version>2.13.3</version>
			</dependency>

			<dependency>
			  <!-- Include the db-migrations as a dependency (so we can run flyway:migrate on application startup) -->
			  <groupId>${project.groupId}</groupId>
			  <artifactId>db-migrations</artifactId>
			  <version>${project.version}</version>
			</dependency>

			<dependency>
			  <!-- Add common backend as a dependency -->
			  <groupId>${project.groupId}</groupId>
			  <artifactId>common-backend</artifactId>
			  <version>${project.version}</version>
			</dependency>

			<dependency>
			  <groupId>junit</groupId>
			  <artifactId>junit</artifactId>
			  <version>4.12</version>
			  <scope>test</scope>
			</dependency>
		  </dependencies>

		  <build>

			<plugins>


			  <plugin>
				<groupId>pl.project13.maven</groupId>
				<artifactId>git-commit-id-plugin</artifactId>
				<version>4.9.10</version>

				<executions>
				  <execution>
				    <id>get-the-git-infos</id>
				    <goals>
				      <goal>revision</goal>
				    </goals>
				  </execution>
				  <execution>
				    <id>validate-the-git-infos</id>
				    <goals>
				      <goal>validateRevision</goal>
				    </goals>
				  </execution>
				</executions>

				<configuration>
				  <verbose>false</verbose>
				  <generateGitPropertiesFile>true</generateGitPropertiesFile>
				</configuration>
			  </plugin>


			  <plugin>
				<!-- This plugin provides the tools needed to repackage the Spring Boot JAR into a runnable JAR
				     Run this command to generate the runnable Spring Boot Jar
				        mvn clean package  *or*
				        mvn clean package spring-boot:repackage
				 -->
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
				<version>2.7.3</version>
				<configuration>
				  <addResources>true</addResources>
				</configuration>

				<executions>
				  <execution>
				    <goals>
				      <goal>repackage</goal>
				    </goals>
				    <configuration>
				      <classifier>exec</classifier>
				    </configuration>
				  </execution>
				</executions>

			  </plugin>
			  <plugin>
				<artifactId>maven-resources-plugin</artifactId>
				<version>3.0.2</version>
				<configuration>
				  <encoding>UTF-8</encoding>
				  <nonFilteredFileExtensions>
				    <nonFilteredFileExtension>ttf</nonFilteredFileExtension>
				  </nonFilteredFileExtensions>
				</configuration>
			  </plugin>
			</plugins>
		  </build>

		  <profiles>

			<!-- B U I L D     R D A        P R O F I L E       (for running this app within the BDP)   -->
			<profile>
			   <id>buildRda</id>
			  <activation>
				<activeByDefault>false</activeByDefault>
			  </activation>

			  <!-- When running the buildRda profile, exclude the backend/src/main/resources/application.yaml from the JAR file -->
			  <build>
				<resources>
				  <resource>
				    <filtering>false</filtering>
				    <directory>src/main/resources</directory>
				    <excludes>
				      <exclude>application.yaml</exclude>
				    </excludes>
				  </resource>
				</resources>
			  </build>
			</profile>


			<!--    B U I L D     I M A G E      P R O F I L E      (for running this app in a container)  -->
			<profile>
			  <id>buildImage</id>

			  <!-- When running this profile, do *NOT* include the src/main/resources/application.yaml in the build -->
			  <build>
				<resources>
				   <resource>
				    <filtering>false</filtering>
				    <directory>src/main/resources</directory>
				    <excludes>
				      <exclude>application.yaml</exclude>
				    </excludes>
				  </resource>
				</resources>

				<plugins>
				  <plugin>
				    <!-- Use the jib-maven-plugin to build the container and push it up to a registry [without having to install Docker] -->
				    <groupId>com.google.cloud.tools</groupId>
				    <artifactId>jib-maven-plugin</artifactId>
				    <version>3.3.1</version>

				    <executions>
				      <execution>
				        <phase>package</phase>
				        <goals>
				          <!-- Possible goals are build and dockerBuild   -->
				          <!--   The "build"       goal does not require docker / build the image and push it to a repo                 -->
				          <!--   The "dockerBuild" goal requires docker         / build the image and push to the local daemon daemon   -->
				          <goal>dockerBuild</goal>
				        </goals>
				      </execution>
				    </executions>

				    <configuration>
				      <from>
				        <!-- Define the source image that will be executed            -->
				        <!-- See https://hub.docker.com/_/eclipse-temurin/tags        -->

				        <!-- This source image runs linux with JDK 1.8-362             -->
				        <!-- <image>eclipse-temurin:8u362-b09-jdk@sha256:3b83f3fc0d016d7536dfd5e8a98ece451061b7dbb6d5db3ddea2db30b6153b28</image>-->

				        <!-- This source image runs linux with JDK 17.07 -->
				        <image>eclipse-temurin:17.0.7_7-jdk@sha256:9dd6a19e4819b066aa2bd8e54d5988a49cca29736fe5447cb0a57daa975f8935</image>
				      </from>

				      <to>
				        <!--                <image>527362555097.dkr.ecr.us-gov-west-1.amazonaws.com/poc:${project.artifactId}-${project.version}</image>-->
				        <image>traderres/my-private-repo:${user.name}-${project.artifactId}-${project.version}</image>
				       </to>


				      <extraDirectories>
				        <paths>
				          <path>
				            <!-- Copies everything from 'src/main/image_resources' into '/sync-service-/src/main/image_resources' on the container. -->
				            <from>src/main/image_resources</from>
				            <into>/sync-service/src/main/image_resources</into>
				          </path>
				        </paths>
				      </extraDirectories>

				      <container>
				        <jvmFlags>
				          <!-- When starting the container, tell Java where to find the application.yaml -->
				          <jvmFlag> -Dspring.config.location=/sync-service/src/main/image_resources/application.yaml</jvmFlag>
				        </jvmFlags>
				      </container>

				    </configuration>

				  </plugin>
				</plugins>
			  </build>
			</profile>




			<!--    B U I L D     I M A G E    A N D    P U S H        P R O F I L E      (for running this app in a container)  -->
			<profile>
			  <id>buildImageAndPush</id>

			  <!-- When running this profile, do *NOT* include the src/main/resources/application.yaml in the build -->
			  <build>
				<resources>
				  <resource>
				    <filtering>false</filtering>
				    <directory>src/main/resources</directory>
				    <excludes>
				      <exclude>application.yaml</exclude>
				    </excludes>
				  </resource>
				</resources>

				<plugins>
				  <plugin>
				    <!-- Use the jib-maven-plugin to build the container and push it up to a registry [without having to install Docker] -->
				    <groupId>com.google.cloud.tools</groupId>
				    <artifactId>jib-maven-plugin</artifactId>
				    <version>3.3.1</version>

				    <executions>
				      <execution>
				        <phase>package</phase>
				        <goals>
				          <!-- Possible goals are build and dockerBuild   -->
				          <!--   The "build"       goal does not require docker / build the image and push it to a repo                 -->
				          <!--   The "dockerBuild" goal requires docker         / build the image and push to the local daemon daemon   -->
				          <goal>build</goal>
				        </goals>
				      </execution>
				    </executions>

				    <configuration>
				      <from>
				        <!-- Define the source image that will be executed            -->
				        <!-- See https://hub.docker.com/_/eclipse-temurin/tags        -->

				        <!-- This source image runs linux with JDK 1.8-362             -->
				        <!-- <image>eclipse-temurin:8u362-b09-jdk@sha256:3b83f3fc0d016d7536dfd5e8a98ece451061b7dbb6d5db3ddea2db30b6153b28</image>-->

				        <!-- This source image runs linux with JDK 17.07 -->
				        <image>eclipse-temurin:17.0.7_7-jdk@sha256:9dd6a19e4819b066aa2bd8e54d5988a49cca29736fe5447cb0a57daa975f8935</image>
				      </from>

				      <to>
				        <!--                <image>527362555097.dkr.ecr.us-gov-west-1.amazonaws.com/poc:${project.artifactId}-${project.version}</image>-->
				        <image>traderres/my-private-repo:${user.name}-${project.artifactId}-${project.version}</image>
				      </to>


				      <extraDirectories>
				        <paths>
				          <path>
				            <!-- Copies everything from 'src/main/image_resources' into '/sync-service-/src/main/image_resources' on the container. -->
				            <from>src/main/image_resources</from>
				            <into>/sync-service/src/main/image_resources</into>
				          </path>
				        </paths>
				      </extraDirectories>

				      <container>
				        <jvmFlags>
				          <!-- When starting the container, tell Java where to find the application.yaml -->
				          <jvmFlag> -Dspring.config.location=/sync-service/src/main/image_resources/application.yaml</jvmFlag>
				        </jvmFlags>
				      </container>

				    </configuration>

				  </plugin>
				</plugins>
			  </build>
			</profile>


			<profile>
			  <!-- D E F A U L T       M A V E N      P R O F I L E -->
			  <id>defaultProfile</id>
			  <activation>
				<activeByDefault>true</activeByDefault>
			  </activation>

			  <!-- When running any other build profile, include *ALL* files from the sync/src/main/resources into the JAR file -->
			  <build>
				<resources>
				  <resource>
				    <directory>src/main/resources</directory>
				    <filtering>false</filtering>
				  </resource>
				</resources>
			  </build>
			</profile>
		  </profiles>
		</project>



 2.  Add the "buildImage" and "buildImageAndPush" profiles to backend/pom.xml



    <!--    B U I L D     I M A G E      P R O F I L E      (for running this app in a container)  -->
    <profile>
      <id>buildImage</id>

      <!-- When running this profile, do *NOT* include the src/main/resources/application.yaml in the build -->
      <build>
        <resources>
          <resource>
            <filtering>false</filtering>
            <directory>src/main/resources</directory>
            <excludes>
              <exclude>application.yaml</exclude>
            </excludes>
          </resource>
        </resources>

        <plugins>
          <plugin>
            <!-- Use the jib-maven-plugin to build the container and push it up to a registry [without having to install Docker] -->
            <groupId>com.google.cloud.tools</groupId>
            <artifactId>jib-maven-plugin</artifactId>
            <version>3.3.1</version>

            <executions>
              <execution>
                <phase>package</phase>
                <goals>
                  <!-- Possible goals are build and dockerBuild   -->
                  <!--   The "build"       goal does not require docker / build the image and push it to a repo                 -->
                  <!--   The "dockerBuild" goal requires docker         / build the image and push to the local daemon daemon   -->
                  <goal>dockerBuild</goal>
                </goals>
              </execution>
            </executions>

            <configuration>
              <from>
                <!-- Define the source image that will be executed            -->
                <!-- See https://hub.docker.com/_/eclipse-temurin/tags        -->

                <!-- This source image runs linux with JDK 1.8-362             -->
                <!-- <image>eclipse-temurin:8u362-b09-jdk@sha256:3b83f3fc0d016d7536dfd5e8a98ece451061b7dbb6d5db3ddea2db30b6153b28</image>-->

                <!-- This source image runs linux with JDK 17.07 -->
                <image>eclipse-temurin:17.0.7_7-jdk@sha256:9dd6a19e4819b066aa2bd8e54d5988a49cca29736fe5447cb0a57daa975f8935</image>
              </from>

              <to>
                <!--                <image>527362555097.dkr.ecr.us-gov-west-1.amazonaws.com/poc:${project.artifactId}-${project.version}</image>-->
                <image>traderres/my-private-repo:${user.name}-${project.artifactId}-${project.version}</image>
              </to>


              <extraDirectories>
                <paths>
                  <path>
                    <!-- Copies everything from 'src/main/image_resources' into '/sync-service-/src/main/image_resources' on the container. -->
                    <from>src/main/image_resources</from>
                    <into>/backend/src/main/image_resources</into>
                  </path>
                </paths>
              </extraDirectories>

              <container>
                <jvmFlags>
                  <!-- When starting the container, tell Java where to find the application.yaml -->
                  <jvmFlag> -Dspring.config.location=/backend/src/main/image_resources/application.yaml</jvmFlag>
                </jvmFlags>
              </container>

            </configuration>

          </plugin>
        </plugins>
      </build>
    </profile>




    <!--    B U I L D     I M A G E    A N D     P U S H       P R O F I L E      (for running this app in a container)  -->
    <profile>
      <id>buildImageAndPush</id>

      <!-- When running this profile, do *NOT* include the src/main/resources/application.yaml in the build -->
      <build>
        <resources>
          <resource>
            <filtering>false</filtering>
            <directory>src/main/resources</directory>
            <excludes>
              <exclude>application.yaml</exclude>
            </excludes>
          </resource>
        </resources>

        <plugins>
          <plugin>
            <!-- Use the jib-maven-plugin to build the container and push it up to a registry [without having to install Docker] -->
            <groupId>com.google.cloud.tools</groupId>
            <artifactId>jib-maven-plugin</artifactId>
            <version>3.3.1</version>

            <executions>
              <execution>
                <phase>package</phase>
                <goals>
                  <!-- Possible goals are build and dockerBuild   -->
                  <!--   The "build"       goal does not require docker / build the image and push it to a repo                 -->
                  <!--   The "dockerBuild" goal requires docker         / build the image and push to the local daemon daemon   -->
                  <goal>build</goal>
                </goals>
              </execution>
            </executions>

            <configuration>
              <from>
                <!-- Define the source image that will be executed            -->
                <!-- See https://hub.docker.com/_/eclipse-temurin/tags        -->

                <!-- This source image runs linux with JDK 1.8-362             -->
                <!-- <image>eclipse-temurin:8u362-b09-jdk@sha256:3b83f3fc0d016d7536dfd5e8a98ece451061b7dbb6d5db3ddea2db30b6153b28</image>-->

                <!-- This source image runs linux with JDK 17.07 -->
                <image>eclipse-temurin:17.0.7_7-jdk@sha256:9dd6a19e4819b066aa2bd8e54d5988a49cca29736fe5447cb0a57daa975f8935</image>
              </from>

              <to>
                <!--                <image>527362555097.dkr.ecr.us-gov-west-1.amazonaws.com/poc:${project.artifactId}-${project.version}</image>-->
                <image>traderres/my-private-repo:${user.name}-${project.artifactId}-${project.version}</image>
              </to>


              <extraDirectories>
                <paths>
                  <path>
                    <!-- Copies everything from 'src/main/image_resources' into '/sync-service-/src/main/image_resources' on the container. -->
                    <from>src/main/image_resources</from>
                    <into>/backend/src/main/image_resources</into>
                  </path>
                </paths>
              </extraDirectories>

              <container>
                <jvmFlags>
                  <!-- When starting the container, tell Java where to find the application.yaml -->
                  <jvmFlag> -Dspring.config.location=/backend/src/main/image_resources/application.yaml</jvmFlag>
                </jvmFlags>
              </container>

            </configuration>

          </plugin>
        </plugins>
      </build>
    </profile>



	When finished, the backend/pom.xml looks something like this:

			<?xml version="1.0" encoding="UTF-8"?>
			<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
					 xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
			  <modelVersion>4.0.0</modelVersion>

			  <parent>
				<artifactId>angularApp1</artifactId>
				<groupId>com.lessons</groupId>
				<version>2.2.2-SNAPSHOT</version>
			  </parent>

			  <artifactId>backend</artifactId>
			  <version>2.2.2-SNAPSHOT</version>

			  <name>backend</name>

			  <properties>
				<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
				<maven.compiler.source>1.8</maven.compiler.source>
				<maven.compiler.target>1.8</maven.compiler.target>
			  </properties>

			  <dependencyManagement>
				<dependencies>

				  <dependency>
					<!-- Tell Spring Boot to use this **OLDER** version of flyway that works with Postgres 9.6 -->
					<groupId>org.flywaydb</groupId>
					<artifactId>flyway-core</artifactId>
					<version>5.2.4</version>
				  </dependency>

				  <dependency>
					<!-- Set the Spring Boot Version -->
					<groupId>org.springframework.boot</groupId>
					<artifactId>spring-boot-dependencies</artifactId>
					<version>2.7.3</version>
					<type>pom</type>
					<scope>import</scope>
				  </dependency>

				</dependencies>
			  </dependencyManagement>

			  <dependencies>
				<dependency>
				  <!-- AsyncHttpClient Client implementation (used to make outgoing REST calls out to ES) -->
				  <groupId>com.ning</groupId>
				  <artifactId>async-http-client</artifactId>
				  <version>1.9.40</version>
				</dependency>

				<dependency>
				  <!-- StringUtils Dependency -->
				  <groupId>org.apache.commons</groupId>
				  <artifactId>commons-lang3</artifactId>
				  <version>3.5</version>
				</dependency>

				<dependency>
				  <!-- Jasypt is the Java Simplified Encryption Library / used to encrypt the citadel password in the production application.yaml file -->
				  <groupId>com.github.ulisesbocchio</groupId>
				  <artifactId>jasypt-spring-boot-starter</artifactId>
				  <version>1.17</version>
				</dependency>

				<dependency>
				  <groupId>org.apache.commons</groupId>
				  <artifactId>commons-collections4</artifactId>
				  <version>4.4</version>
				</dependency>


				<dependency>
				  <groupId>org.springframework.security</groupId>
				  <artifactId>spring-security-web</artifactId>
				  <version>5.7.3</version>
				</dependency>

				<dependency>
				  <groupId>org.springframework.security</groupId>
				  <artifactId>spring-security-config</artifactId>
				  <version>5.7.3</version>
				</dependency>

				<dependency>
				  <!-- Sprint Boot / Keycloak Integration / Add the OAuth2/OpenID client to talk to Keycloak and authenticate users -->
				  <groupId>org.springframework.boot</groupId>
				  <artifactId>spring-boot-starter-oauth2-client</artifactId>
				</dependency>

				<dependency>
				  <!-- Hikari Data Source / JDBC Connection Pool -->
				  <groupId>com.zaxxer</groupId>
				  <artifactId>HikariCP</artifactId>
				  <version>3.4.5</version>
				</dependency>

				<dependency>
				  <!-- Add common backend dependency -->
				  <groupId>${project.groupId}</groupId>
				  <artifactId>common-backend</artifactId>
				  <version>${project.version}</version>
				</dependency>

				<dependency>
				  <!-- Include the db-migrations as a dependency (so we can run flyway:migrate on application startup) -->
				  <groupId>${project.groupId}</groupId>
				  <artifactId>db-migrations</artifactId>
				  <version>${project.version}</version>
				</dependency>

				<dependency>
				  <!-- Include the front-end as a dependency so the front-end is compiled *BEFORE* the backend is compiled -->
				  <groupId>${project.groupId}</groupId>
				  <artifactId>frontend</artifactId>
				  <version>${project.version}</version>
				</dependency>

				<dependency>
				  <!--  Hadoop Common libraries -->
				  <groupId>org.apache.hadoop</groupId>
				  <artifactId>hadoop-common</artifactId>
				  <version>2.9.2</version>

				  <exclusions>
					<!-- Hadoop-common comes with log4j but we will use logback so strip it out -->
					<exclusion>
					  <groupId>org.slf4j</groupId>
					  <artifactId>slf4j-log4j12</artifactId>
					</exclusion>
					<exclusion>
					  <groupId>log4j</groupId>
					  <artifactId>log4j</artifactId>
					</exclusion>
					<exclusion>
					  <groupId>org.slf4j</groupId>
					  <artifactId>slf4j-log4j12</artifactId>
					</exclusion>

					<!-- Exclude javax.servlet and javax.servlet.jsp dependencies so this hadoop-client does not conflict with the Undertow App Server -->
					<exclusion>
					  <groupId>javax.servlet</groupId>
					  <artifactId>servlet-api</artifactId>
					</exclusion>
					<exclusion>
					  <groupId>javax.servlet.jsp</groupId>
					  <artifactId>jsp-api</artifactId>
					</exclusion>
				  </exclusions>
				</dependency>

				<dependency>
				  <!-- Hadoop HDFS libraries -->
				  <groupId>org.apache.hadoop</groupId>
				  <artifactId>hadoop-hdfs</artifactId>
				  <version>2.9.2</version>
				  <exclusions>
					<!-- Hadoop-hdfs comes with log4j but we will use logback so strip it out -->
					<exclusion>
					  <groupId>log4j</groupId>
					  <artifactId>log4j</artifactId>
					</exclusion>

					<!-- Exclude javax.servlet and javax.servlet.jsp dependencies so this hadoop-client does not conflict with the Undertow App Server -->
					<exclusion>
					  <groupId>javax.servlet</groupId>
					  <artifactId>servlet-api</artifactId>
					</exclusion>
					<exclusion>
					  <groupId>javax.servlet.jsp</groupId>
					  <artifactId>jsp-api</artifactId>
					</exclusion>
				  </exclusions>
				</dependency>


				<dependency>
				  <!-- Add wrapper to invoke virus-scanning with clamAV -->
				  <groupId>com.eurodyn.qlack.util</groupId>
				  <artifactId>qlack-util-clam-av</artifactId>
				  <version>3.5.3</version>

				  <exclusions>
					<!-- The qlack-util-clam-av dependency comes with lots of stuff we do not need -->
					<exclusion>
					  <groupId>org.springframework.boot</groupId>
					  <artifactId>spring-boot-configuration-processor</artifactId>
					</exclusion>

					<exclusion>
					  <groupId>org.springframework.boot</groupId>
					  <artifactId>spring-boot-starter</artifactId>
					</exclusion>

					<exclusion>
					  <groupId>org.springframework.boot</groupId>
					  <artifactId>spring-boot-starter-data-jpa</artifactId>
					</exclusion>

					<exclusion>
					  <groupId>org.hibernate</groupId>
					  <artifactId>hibernate-core</artifactId>
					</exclusion>

					<exclusion>
					  <groupId>org.jboss.logging</groupId>
					  <artifactId>jboss-logging</artifactId>
					</exclusion>

					<exclusion>
					  <groupId>com.zaxxer</groupId>
					  <artifactId>HikariCP</artifactId>
					</exclusion>

					<exclusion>
					  <groupId>org.springframework</groupId>
					  <artifactId>spring-jdbc</artifactId>
					</exclusion>

					<exclusion>
					  <groupId>org.springframework</groupId>
					  <artifactId>spring-aop</artifactId>
					</exclusion>

					<exclusion>
					  <groupId>commons-codec</groupId>
					  <artifactId>commons-codec</artifactId>
					</exclusion>

					<exclusion>
					  <groupId>com.querydsl</groupId>
					  <artifactId>querydsl-core</artifactId>
					</exclusion>

				  </exclusions>
				</dependency>

				<dependency>
				  <!-- Send logging from Java Util Logging to SLF4J  (so the virus scanning logging is sent to logback) -->
				  <groupId>org.slf4j</groupId>
				  <artifactId>jul-to-slf4j</artifactId>
				  <version>1.7.30</version>
				</dependency>

				<dependency>
				  <!-- Spring Boot Web -->
				  <groupId>org.springframework.boot</groupId>
				  <artifactId>spring-boot-starter-web</artifactId>

				  <exclusions>
					<exclusion>
					  <!-- Remove Tomcat from Spring Boot -->
					  <groupId>org.springframework.boot</groupId>
					  <artifactId>spring-boot-starter-tomcat</artifactId>
					</exclusion>

					<exclusion>
					  <!-- Remove logging from spring as we will use logback -->
					  <groupId>org.springframework.boot</groupId>
					  <artifactId>spring-boot-starter-logging</artifactId>
					</exclusion>
				  </exclusions>
				</dependency>

				<dependency>
				  <!-- Add Dependency for the Undertow App Server -->
				  <groupId>org.springframework.boot</groupId>
				  <artifactId>spring-boot-starter-undertow</artifactId>

				  <exclusions>
					<exclusion>
					  <!-- Remove logging from undertow as we will use logback -->
					  <groupId>org.springframework.boot</groupId>
					  <artifactId>spring-boot-starter-logging</artifactId>
					</exclusion>
				  </exclusions>
				</dependency>

				<dependency>
				  <!-- Send logging from Java Common Logging to SLF4J -->
				  <groupId>org.slf4j</groupId>
				  <artifactId>jcl-over-slf4j</artifactId>
				  <version>1.7.5</version>
				</dependency>

				<dependency>
				  <!-- SLF4J will use Logback-classic as its logging implementation -->
				  <groupId>ch.qos.logback</groupId>
				  <artifactId>logback-classic</artifactId>
				  <version>1.2.3</version>
				</dependency>

				<dependency>
				  <groupId>org.springframework</groupId>
				  <artifactId>spring-jdbc</artifactId>
				  <version>5.3.21</version>
				</dependency>

				<dependency>
				  <groupId>org.springframework</groupId>
				  <artifactId>spring-web</artifactId>
				  <version>5.3.21</version>
				</dependency>

				<dependency>
				  <!-- Implementation for converting objects to JSON -->
				  <groupId>com.fasterxml.jackson.core</groupId>
				  <artifactId>jackson-databind</artifactId>
				  <version>2.13.3</version>
				</dependency>

				<dependency>
				  <!-- AsyncHttpClient Client implementation           -->
				  <!--    (used to make outgoing REST calls out to ES) -->
				  <groupId>com.ning</groupId>
				  <artifactId>async-http-client</artifactId>
				  <version>1.9.40</version>
				</dependency>

				<dependency>
				  <groupId>junit</groupId>
				  <artifactId>junit</artifactId>
				  <version>4.12</version>
				  <scope>test</scope>
				</dependency>

				<dependency>
				  <groupId>org.apache.pdfbox</groupId>
				  <artifactId>pdfbox</artifactId>
				  <version>2.0.24</version>
				</dependency>

				<dependency>
				  <!-- Add the javax.mail email library (so this webapp can send out emails by connecting to an SMTP server) -->
				  <groupId>com.sun.mail</groupId>
				  <artifactId>javax.mail</artifactId>
				  <version>1.6.2</version>
				</dependency>

				<dependency>
				  <!-- Add the Spring Boot Test Harness so we can run the webapp from unit tests -->
				  <groupId>org.springframework.boot</groupId>
				  <artifactId>spring-boot-starter-test</artifactId>
				  <version>2.7.3</version>
				  <scope>test</scope>
				</dependency>

				<dependency>
				  <!-- Apache POI dependency (used to generate xlsx files) -->
				  <groupId>org.apache.poi</groupId>
				  <artifactId>poi-ooxml</artifactId>
				  <version>4.1.2</version>
				  <scope>test</scope>
				</dependency>

				<!-- https://mvnrepository.com/artifact/org.apache.commons/commons-compress -->
				<dependency>
				  <groupId>org.apache.commons</groupId>
				  <artifactId>commons-compress</artifactId>
				  <version>1.21</version>
				  <scope>test</scope>
				</dependency>



			  </dependencies>

			  <build>

				<plugins>

				  <plugin>
					<groupId>pl.project13.maven</groupId>
					<artifactId>git-commit-id-plugin</artifactId>
					<version>4.9.10</version>

					<executions>
					  <execution>
						<id>get-the-git-infos</id>
						<goals>
						  <goal>revision</goal>
						</goals>
					  </execution>
					  <execution>
						<id>validate-the-git-infos</id>
						<goals>
						  <goal>validateRevision</goal>
						</goals>
					  </execution>
					</executions>

					<configuration>
					  <verbose>false</verbose>
					  <generateGitPropertiesFile>true</generateGitPropertiesFile>
					</configuration>
				  </plugin>


				  <plugin>
					<!-- This plugin provides the tools needed to repackage the Spring Boot JAR into a runnable JAR
						 Run this command to generate the runnable Spring Boot Jar
						    mvn clean package  *or*
						    mvn clean package spring-boot:repackage
					 -->
					<groupId>org.springframework.boot</groupId>
					<artifactId>spring-boot-maven-plugin</artifactId>
					<version>2.7.3</version>
					<configuration>
					  <addResources>true</addResources>
					</configuration>

					<executions>
					  <execution>
						<goals>
						  <goal>repackage</goal>
						</goals>
						<configuration>
						  <classifier>exec</classifier>
						</configuration>
					  </execution>
					</executions>
				  </plugin>

				  <plugin>
					<artifactId>maven-resources-plugin</artifactId>
					<version>3.0.2</version>
					<configuration>
					  <encoding>UTF-8</encoding>
					  <nonFilteredFileExtensions>
						<nonFilteredFileExtension>ttf</nonFilteredFileExtension>
					  </nonFilteredFileExtensions>
					</configuration>
				  </plugin>
				</plugins>
			  </build>

			  <profiles>

				<!-- B U I L D     R D A        P R O F I L E       (for running this app within the BDP)   -->
				<profile>
				  <id>buildRda</id>

				  <!-- When running the buildRda profile, exclude the backend/src/main/resources/application.yaml from the JAR file -->
				  <build>
					<resources>
					  <resource>
						<filtering>true</filtering>
						<directory>src/main/resources</directory>
						<excludes>
						  <exclude>application.yaml</exclude>
						</excludes>
					  </resource>
					</resources>
				  </build>
				</profile>


				<!--    B U I L D     I M A G E      P R O F I L E      (for running this app in a container)  -->
				<profile>
				  <id>buildImage</id>

				  <!-- When running this profile, do *NOT* include the src/main/resources/application.yaml in the build -->
				  <build>
					<resources>
					  <resource>
						<filtering>false</filtering>
						<directory>src/main/resources</directory>
						<excludes>
						  <exclude>application.yaml</exclude>
						</excludes>
					  </resource>
					</resources>

					<plugins>
					  <plugin>
						<!-- Use the jib-maven-plugin to build the container and push it up to a registry [without having to install Docker] -->
						<groupId>com.google.cloud.tools</groupId>
						<artifactId>jib-maven-plugin</artifactId>
						<version>3.3.1</version>

						<executions>
						  <execution>
						    <phase>package</phase>
						    <goals>
						      <!-- Possible goals are build and dockerBuild   -->
						      <!--   The "build"       goal does not require docker / build the image and push it to a repo                 -->
						      <!--   The "dockerBuild" goal requires docker         / build the image and push to the local daemon daemon   -->
						      <goal>dockerBuild</goal>
						    </goals>
						  </execution>
						</executions>

						<configuration>
						  <from>
						    <!-- Define the source image that will be executed            -->
						    <!-- See https://hub.docker.com/_/eclipse-temurin/tags        -->

						    <!-- This source image runs linux with JDK 1.8-362             -->
						    <!-- <image>eclipse-temurin:8u362-b09-jdk@sha256:3b83f3fc0d016d7536dfd5e8a98ece451061b7dbb6d5db3ddea2db30b6153b28</image>-->

						    <!-- This source image runs linux with JDK 17.07 -->
						    <image>eclipse-temurin:17.0.7_7-jdk@sha256:9dd6a19e4819b066aa2bd8e54d5988a49cca29736fe5447cb0a57daa975f8935</image>
						  </from>

						  <to>
						    <!--                <image>527362555097.dkr.ecr.us-gov-west-1.amazonaws.com/poc:${project.artifactId}-${project.version}</image>-->
						    <image>traderres/my-private-repo:${user.name}-${project.artifactId}-${project.version}</image>
						  </to>


						  <extraDirectories>
						    <paths>
						      <path>
						        <!-- Copies everything from 'src/main/image_resources' into '/sync-service-/src/main/image_resources' on the container. -->
						        <from>src/main/image_resources</from>
						        <into>/backend/src/main/image_resources</into>
						      </path>
						    </paths>
						  </extraDirectories>

						  <container>
						    <jvmFlags>
						      <!-- When starting the container, tell Java where to find the application.yaml -->
						      <jvmFlag> -Dspring.config.location=/backend/src/main/image_resources/application.yaml</jvmFlag>
						    </jvmFlags>
						  </container>

						</configuration>

					  </plugin>
					</plugins>
				  </build>
				</profile>




				<!--    B U I L D     I M A G E    A N D     P U S H       P R O F I L E      (for running this app in a container)  -->
				<profile>
				  <id>buildImageAndPush</id>

				  <!-- When running this profile, do *NOT* include the src/main/resources/application.yaml in the build -->
				  <build>
					<resources>
					  <resource>
						<filtering>false</filtering>
						<directory>src/main/resources</directory>
						<excludes>
						  <exclude>application.yaml</exclude>
						</excludes>
					  </resource>
					</resources>

					<plugins>
					  <plugin>
						<!-- Use the jib-maven-plugin to build the container and push it up to a registry [without having to install Docker] -->
						<groupId>com.google.cloud.tools</groupId>
						<artifactId>jib-maven-plugin</artifactId>
						<version>3.3.1</version>

						<executions>
						  <execution>
						    <phase>package</phase>
						    <goals>
						      <!-- Possible goals are build and dockerBuild   -->
						      <!--   The "build"       goal does not require docker / build the image and push it to a repo                 -->
						      <!--   The "dockerBuild" goal requires docker         / build the image and push to the local daemon daemon   -->
						      <goal>build</goal>
						    </goals>
						  </execution>
						</executions>

						<configuration>
						  <from>
						    <!-- Define the source image that will be executed            -->
						    <!-- See https://hub.docker.com/_/eclipse-temurin/tags        -->

						    <!-- This source image runs linux with JDK 1.8-362             -->
						    <!-- <image>eclipse-temurin:8u362-b09-jdk@sha256:3b83f3fc0d016d7536dfd5e8a98ece451061b7dbb6d5db3ddea2db30b6153b28</image>-->

						    <!-- This source image runs linux with JDK 17.07 -->
						    <image>eclipse-temurin:17.0.7_7-jdk@sha256:9dd6a19e4819b066aa2bd8e54d5988a49cca29736fe5447cb0a57daa975f8935</image>
						  </from>

						  <to>
						    <!--                <image>527362555097.dkr.ecr.us-gov-west-1.amazonaws.com/poc:${project.artifactId}-${project.version}</image>-->
						    <image>traderres/my-private-repo:${user.name}-${project.artifactId}-${project.version}</image>
						  </to>


						  <extraDirectories>
						    <paths>
						      <path>
						        <!-- Copies everything from 'src/main/image_resources' into '/sync-service-/src/main/image_resources' on the container. -->
						        <from>src/main/image_resources</from>
						        <into>/backend/src/main/image_resources</into>
						      </path>
						    </paths>
						  </extraDirectories>

						  <container>
						    <jvmFlags>
						      <!-- When starting the container, tell Java where to find the application.yaml -->
						      <jvmFlag> -Dspring.config.location=/backend/src/main/image_resources/application.yaml</jvmFlag>
						    </jvmFlags>
						  </container>

						</configuration>

					  </plugin>
					</plugins>
				  </build>
				</profile>


				<profile>
				  <!-- When running any other build profile, include *ALL* files from the backend/src/main/resources into the JAR file -->
				  <id>defaultProfile</id>
				  <activation>
					<activeByDefault>true</activeByDefault>
				  </activation>
				  <build>
					<resources>
					  <resource>
						<directory>src/main/resources</directory>
						<filtering>true</filtering>
					  </resource>
					</resources>
				  </build>
				</profile>
			  </profiles>
			</project>


 3. Add these directories:
          backend/src/main/image_resources/
          sync-service/src/main/image_resources/



 4. Update the image_resources/application.yaml for the sync-service
    a. Copy the install-bdp/sync-service/application.yaml  to  sync-service/src/main/image_resources/application.yaml
    b. Edit sync-service/src/main/image_resources/application.yaml
       Replace BDP environment variables with regular environment variables

		#################################################################
		# Database Settings
		#################################################################
		app.datasource:
		  driver-class-name: org.postgresql.Driver
		  url: jdbc:postgresql://${POSTGRES_HOSTNAME}/${POSTGRES_DB_NAME}
		  username: ${POSTGRES_DB_USERNAME}
		  password: ${POSTGRES_DB_PASSWORD}
		  schema: ${POSTGRES_SCHEMA_NAME}
		  maxPoolSize: ${POSTGRES_POOL_SIZE:20}
		  database-name: ${POSTGRES_DB_NAME}
		  flyway-migrate-on-startup: true



		##########################################################
		# Citadel Database Settings
		##########################################################
		citadel.datasource:
		  enabled: false



		###########################################################
		# ElasticSearch Settings
		##########################################################
		es:
		  url: ${ES_URL}
		  ssl_enabled: true
		  add_bdp_security: false
		  key-store: ${INCOMING_KEYSTORE_FILEPATH}
		  key-store-password:  ${INCOMING_KEYSTORE_PASSWORD}
		  key-store-type: JKS
		  trust-store:  ${INCOMING_TRUSTSTORE_FILEPATH}
		  trust-store-password: ${INCOMING_TRUSTSTORE_PASSWORD}
		  trust-store-type: JKS
		  authentication.principal: ${ES_USERNAME}
		  authentication.password:  ${ES_PASSWORD}





 5. Update the image_resources/application.yaml for the backend
    NOTE:  Don't forget to change the server.servlet.context-path to be something real like /frms
    NOTE:  Update this to use SSL and Keycloak sections
    a. Copy the install-bdp/webapp/application.yaml  to  backend/src/main/image_resources/application.yaml
    b. Edit backend/src/main/image_resources/application.yaml
       Replace BDP environment variables with regular environment variables

		#################################################################
		# Database Settings
		#################################################################
		app.datasource:
		  driver-class-name: org.postgresql.Driver
		  url: jdbc:postgresql://${POSTGRES_HOSTNAME}/${POSTGRES_DB_NAME}
		  username: ${POSTGRES_DB_USERNAME}
		  password: ${POSTGRES_DB_PASSWORD}
		  schema: ${POSTGRES_SCHEMA_NAME}
		  maxPoolSize: ${POSTGRES_POOL_SIZE:20}
		  database-name: ${POSTGRES_DB_NAME}
		  flyway-migrate-on-startup: true



		##########################################################
		# Citadel Database Settings
		##########################################################
		citadel.datasource:
		  enabled: false



		###########################################################
		# ElasticSearch Settings
		##########################################################
		es:
		  url: ${ES_URL}
		  ssl_enabled: true
		  add_bdp_security: false
		  key-store: ${INCOMING_KEYSTORE_FILEPATH}
		  key-store-password:  ${INCOMING_KEYSTORE_PASSWORD}
		  key-store-type: JKS
		  trust-store:  ${INCOMING_TRUSTSTORE_FILEPATH}
		  trust-store-password: ${INCOMING_TRUSTSTORE_PASSWORD}
		  trust-store-type: JKS
		  authentication.principal: ${ES_USERNAME}
		  authentication.password:  ${ES_PASSWORD}



		##########################################################
		# Security & SSL Settings
		#
		# Set the security mode to "keycloak" so it authenticates against keycloak
		##########################################################
		security.mode: keycloak    # Possible values are localdev, citadel, and keycloak / set to keycloak to use keycloak authentication

		server:
		  ssl:
			key-store: ${INCOMING_KEYSTORE_FILEPATH}
			key-store-password: ${INCOMING_KEYSTORE_PASSWORD}
			key-store-type: JKS
			client-auth: need
			trust-store: ${INCOMING_TRUSTSTORE_FILEPATH}
			trust-store-password: ${INCOMING_TRUSTSTORE_PASSWORD}
			trust-store-type: JKS
			enabled: true

		# Secure the cookies
		server.servlet.session.cookie.secure: true
		server.servlet.session.cookie.http-only: true

		server.use-forward-headers: true


		##############################################################################
		# Keycloak Settings for Spring Security
		#
		# The realm url is probably something like https://keycloak.rbr-tech.com:8444/realms/MyRealm
		##############################################################################
		spring.security.oauth2.client.registration.keycloak.client-id: ${KEYCLOAK_CLIENT_ID}
		spring.security.oauth2.client.registration.keycloak.client-secret: ${KEYCLOAK_CLIENT_SECRET}
		spring.security.oauth2.client.registration.keycloak.authorization-grant-type: authorization_code
		spring.security.oauth2.client.registration.keycloak.scope: openid,email,profile
		spring.security.oauth2.client.provider.keycloak.issuer-uri: ${KEYCLOAK_ISSUER_URI}
		spring.security.oauth2.client.provider.keycloak.user-name-attribute: preferred_username





 6. Add the Spring Boot Oauth2 client to the backend/pom.xml    (so the webapp can talk to keycloak via Oauth2/OpenID

		<dependency>
		  <!-- Sprint Boot / Keycloak Integration / Add the OAuth2/OpenID client to talk to Keycloak and authenticate users -->
		  <groupId>org.springframework.boot</groupId>
		  <artifactId>spring-boot-starter-oauth2-client</artifactId>
		</dependency>



 7. Verify that the <to><image> has the correct private repo
    a. Edit the backend/pom.xml and sync-service.pom.xml

    b. Make sure the private-repo has the correct url

           <to>
               <image>traderres/my-private-repo:${user.name}-${project.artifactId}-${project.version}</image>
           </to>


 8. Build and push the containers to a container repo

		Build & Push Approach 1:  Use -PbuildImageAndPush and provide username/password on the command-line
        ---------------------------------------------------------------------------------------------------
		unix> export USERNAME=traderres
		unix> export PASSWORD='secret'
		unix> mvn clean package -Pprod -PbuildImageAndPush -Djib.to.auth.username=$USERNAME -Djib.to.auth.password=$PASSWORD



		Build & Push Approach 2:  Use -PbuildImageAndPush and use the "docker login" command to set credentials
        -------------------------------------------------------------------------------------------------------
		a. Login to docker
		   unix> docker login
		   username: traderres
		   password

		b. Build and push to your docker repo
		   unix> mvn clean package -Pprod -PbuildImageAndPush



		Build & Push Approach 3  Use -PbuildImageAndPush and use the "docker login" command to set credentials to push to AWS ECR
        --------------------------------------------------------------------------------------------------------------------------
		a. Configure AWS credentials
		   unix> aws configure

           AWS Access Key ID:
           AWS Secret Access Key:
           Default region name [us-gov-west-1]:
           Default output format:

		b. Login to AWS   (taken from the push command in the AWS ECR Registry)
           unix> aws ecr get-login-password --region us-gov-west-1 | docker login --username AWS --password-stdin 527362555097.dkr.ecr.us-gov-west-1.amazonaws.com

		c. Build and push to your AWS ECR repository
		   unix> mvn clean package -Pprod -PbuildImageAndPush



		Build & Push Approach 4:  Use -PbuildImage to build it to your local docker daemon and push it up manually
        ----------------------------------------------------------------------------------------------------------
		a. Login to docker  (to set your docker credentials and allow you to push the tags to your private repo)
		   unix> docker login

		b. Build the image and store it in your local docker daemon
		   unix> mvn clean package -Pprod -PbuildImage

		c. Push each image up to the repo
		   unix> docker push traderres/my-private-repo:sync-service-2.2.2-SNAPSHOT
		   unix> docker push traderres/my-private-repo:backend-2.2.2-SNAPSHOT


 9. Verify that the files were uploaded to your docker repo
    a. Go to https://hub.docker.com
    b. Enter your docker username/password
    c. Go to your private repo -> tags
    d. Verify that it builds the image and pushes it to your repo:







Next Step  Configure Spring Boot to work with Keycloak:
-------------------------------------------------------------------------
See learnAWS / buildAndDeploy_part2_configureSpringBootToUseKeycloak.txt


