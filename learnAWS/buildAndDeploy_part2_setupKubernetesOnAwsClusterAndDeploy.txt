How to Setup Kubernetes on AWS Cluster and Deploy using Keycloak Server for PKI Authentication
----------------------------------------------------------------------------------------------


General Approach
 1. User uses a browser to hit Java Web App
    -- User presents PKI certificate to Java Web App

 2. Spring Security redirects user to the Keycloak server
    -- User presents PKI certificate to keycloak

 3. User is presented a keycloak login page  (or it can be bypassed)
    -- User presses "Submit" button on keycloak login page
    -- User is redirected to the Java Web App with keycloak credentials
       *OR*
    -- If bypass setting is enabled, user goes directly to Java Web App with keycloak credentials

 4. Spring Security detects that authentication is successful
    -- Java code gets the user's roles and any additional info and adds MyUserInfo to the principal object

    NOTE:  Redirecting the user to the keycloak server is the most secure way of implementing security (according to the Keycloak folks)



ASSUMPTIONS:
 A) You can build your spring boot webapp as a container
    See learnKeycloak / howToConfigureKeycloakToUsePkiAuthenticationOnLocalhost.txt
    See learnAWS / buildAndDeploy_part1_buildWebappsAsRdaOrContainer.txt
 B) You have an AWS account
 C) You have installed the AWS CLI tool
 D) You have a registered domain called "traderres.com"



Goal: Deploy this webapp so anyone can get to it using https://www.traderres.com/sf


Setup local kubectl that is *NOT* part of minikube
---------------------------------------------------
 1. Remove the existing mini kube setup
    unix> mv ~/.kube ~/.kube-localhost

 2. Comment out this alias
    unix> vi ~/.bashrc
    ##   alias kubectl="minikube kubectl --"

 3. Download & install kubectl
    unix> cd /tmp
    unix> curl -LO https://dl.k8s.io/release/v1.26.0/bin/linux/amd64/kubectl
    unix> sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl

    unix> which kubectl
    /usr/local/bin/kubectl

 4. Set my kubectl configuration (so running kubectl connects to the AWS cluster)
    a. Get your current region by going to aws.com, logging-in as the dve.user and looking at the region (next to your name in the upper right corner)
    b. Get your EKS cluster name by going to EKS -> Clusters and look at the name
    unix> aws eks update-kubeconfig --region us-east-1 --name sf

    You should see this:
        Added new context arn:aws:eks:us-east-1:524647912468:cluster/sf to /home/adam/.kube/config

 5. Connect as the dev.user

 6. Login to the server
    unix> kubectl get services
    -- Now, your kubectl is setup to your cluster




Make the build and push to AWS ECR
----------------------------------
 1. Run aws configure
    unix> aws configure

    AWS Access Key ID [None]:    SECRET_KEY_ID
    AWS Secret Access Key:       SECRET_ACCESS_KEY
    Region:                      us-gov-west-1
    Default Output format:       json

 2. Get the authentication token
    unix> aws ecr get-login-password --region us-gov-west-1 | docker login --username AWS --password-stdin 527362555097.dkr.ecr.us-gov-west-1.amazonaws.com

 3. Adjust the pom.xml
    Change the buildImage profile
        <image>527362555097.dkr.ecr.us-gov-west-1.amazonaws.com/frms:${project.artifactId}-${project.version}</image>


 4. Build the image
    unix> mvn clean package -Pprod -PbuildImage

 5. Use Docker to push the image up
    unix> docker push  527362555097.dkr.ecr.us-gov-west-1.amazonaws.com/frms:sync-service-1.0.9-SNAPSHOT
    unix> docker push  527362555097.dkr.ecr.us-gov-west-1.amazonaws.com/frms:backend-1.0.9-SNAPSHOT




General Approach
----------------
 1. Setup AWS Account / Create Users / Grant CLI Access  (so we can push up builds to our AWS ECR Registry)
 2. Setup AWS CNI Policy / so dev.user can make changes to kubernetes
 3. Setup AWS ECR Registry (as dev.user)   which will hold our builds to be deployed)
 4. Configure the Amazon VPC (created by default for the dev.user)
 5. Create the EKS Cluster (as dev.user)
 6. Finish configuring CNI Policy
 7. Create the keypair and inbound rule
 8. Create Kubernetes Node Group
 9. SSH to the node instance to update the yum packages of the running instance
10. Initialize AWS-hosted resources (exist outside of the kubernetes cluster)
    NOTE:  postgres and OpenSearch do not run inside kubernetes
    a. Setup 2 RDS / postgres instances (one for the webapp and one for keycloak)
    b. Setup OpenSearch
11. Create our own certificate authority (for pki client certs)
12. Configure your local kubectl command to talk to our new Kubernetes cluster
13. Get the aws external hostnames for keycloak and the app's loadbalancer
14. Register the godayy domain name that correspond to the external AWS keycloak and external AWS load balancer names
15. Create server certs with Let's Encrypt for the load-balancer (app.traderres.com) and keycloak (keycloak.traderres.com)
16. Install Java 11 JDK on the keycloak server
17. Create & install the keycloak certificates on the running instance
18. Initialize Keycloak as a service on the running instsance
19. Configure keycloak
20. Configure certificates for the load-balancer (external hostname used to access the webapp)
21. Get the environment values for the kubernetes deployment yaml files
22. Setup PersistentVolumes so you can share certs among the pods
23. Use Kubernetes to deploy the webapp
24. Verify it works



Procedure
---------
 1. Setup AWS Account / Create Users / Grant CLI Access  (so we can push up builds to our AWS ECR Registry)
    Goal:  Setup a user that can run the CLI to push-up builds
    a. Go to https://aws.com/

    b. Create the "administrators" group
       1) In AWS, go to Services -> IAM
       2) On the left, click on User groups
       3) Press "Create group"
          User group name:  administrators

       4) In the "Attach permissions policies"
          Add these role:
            AdministratorAccess


    b. Create the dev.user
       1) In AWS, go to Services -> IAM
       2) On the left, click on Users
       3) Press "Add Users"
       4) In "User details"
          User name:  dev.user
          Check "Provide user access to the AWS Management Console"
          Check "I want to create an IAM user"


          Custom password
             custom password:  enter it
             Uncheck "User must create a new password at next sign-in)

          Press "Next"

       5) In "Set permissions"
          Select "Attach policies directly"
          Search for CNI
          Check Off theses roles:  AmazonEKS_CNI_Policy
          Press "Next"

       6) Press "Create user"
          NOTE:  Grab the console sign-in link:   https://524647912468.signin.aws.amazon.com/console

       7) Add this user to the "administrators group"
          Return the user lists
          Click on the "dev.user" link
          Click on "Groups"
          Press "Add user to groups"
          Check "administrators"
          Press "Add user to group(s)"


       8) Create access keys for the dev.user
          1) Click on "Users"
          2) Click on dev.user
          3) Click on "Security Credentials"
          4) Click on "Create access key"
          5) Select Command Line interface
             Select "I understand the above"
             Press "Next"

          6) Description tag value:  leave it blank
             Press "Create access key"

          7) Download the key by pressing "Download .csv file"
            --> Save dev.user_accessKeys.csv to your ~/Downloads

           -- Now, the user called "dev.user" should have the authority to push up to the AWS ECR Registry


    c. Logout as root user


 2. Setup AWS CNI Policy (as the dev.user)
    a. Login as dev.user
       https://524647912468.signin.aws.amazon.com/console

    b. Verify that you have a VPC (created for you)
       Select your VPC, Press Action -> Edit VPC Settings
       -- Verify that "Enable DNS resolution" is checked
       -- Verify that "Enable DNS hostnames"  is checked
       -- Verify that you have subnets already created for you
       -- Verify that you have an Internet gateway created for you

    c. Create this role: eksClusterRole
       1) Go to AWS IAM page
       2) Click on Roles
       3) Press "Create Role"
       4) In Select trusted entity, choose "AWS service"
          In Use Cases for other AWS services, select EKS
          Select EKS - Cluster
          Press "Next"

       5) In "Add permissions", go with defaults and press "Next"

       6) In Name, review, and create
          Role name:  eksClusterRole
          Press "Create Role"

       7) In Roles, Check on eksClusterRole
          Select "Add permissions" -> Attach Policies
          Search for AmazonEKS and press Enter
          Check AmazonEKS_CNI_Policy
          Press "Add Permission"

       8) In the "Roles/ eksClusterRole page, select Trust relationships
          Verify that you see this:
			  {
				  "Version": "2012-10-17",
				  "Statement": [
					  {
						  "Effect": "Allow",
						  "Principal": {
							  "Service": "eks.amazonaws.com"
						  },
						  "Action": "sts:AssumeRole"
					  }
				  ]
			  }

    b. Create this role:  eksNodeRole
       1) Go to AWS IAM page
       2) Click on Roles
       3) Press "Create Role"
       4) In Select trusted entity, choose "AWS service"
          In Use Cases for other AWS services, select EKS
          Select EKS - Cluster
          Press "Next"
       5) In "Add permissions", go with defaults and press "Next"
       6) In Name, review, and create
          Role name:  eksNodeRole
          Press "Create Role"

       7) In Roles, Click on eksNodeRole
       8) Select "Add permissions" -> Attach Policies
          Search for AmazonEKS and press Enter
          Check AmazonEKS_CNI_Policy
          Check AmazonEKSWorkerNodePolicy
          Press "Add Permission"

       9) In the Roles / eksNodeRole, remove the AmazonEKSClusterPolicy
          -- In Permissions policies, check AmazonEKSClusterPolicy
          -- Press "Remove"

      10) In the Roles / eksNodeRole, Add the AmazonEC2ContainerRegistryReadOnly
          -- In Permissions policies, select Add permissions -> Attach policies
          -- Search for AmazonEC2container
          -- Check AmazonEC2ContainerRegistryReadOnly
          -- Press "Add permissions"

          At this point eksNodeRole, should have 3 policies:
          		AmazonEKSWorkerNodePolicy
           		AmazonEC2ContainerRegistryReadOnly
           		AmazonEKS_CNI_Policy,

     11) Click on "Trust relationships" (all of the worker nodes are running on ec2 hosted servers / this granting rights to the ec2 hosted instsances)
         Press "Edit trust policy"

         Find this line:
           "Service": "eks.amazonaws.com"

         Replace with this line:
           "Service": "ec2.amazonaws.com"

         Press "Update policy"



    c. Create this role:  AmazonEKS_VPC_CNI_Role
       1) Go to AWS IAM page
       2) Click on Roles
       3) Press "Create Role"
       4) In Select trusted entity, choose "AWS service"
          In Use Cases for other AWS services, select EKS
          Select EKS - Cluster
          Press "Next"
       5) In "Add permissions", go with defaults and press "Next"
       6) In Name, review, and create
          Role name:  AmazonEKS_VPC_CNI_Role
          Press "Create Role"

       7) In Roles, Click on AmazonEKS_VPC_CNI_Role
       8) Select "Add permissions" -> Attach Policies
          Search for cni and press Enter
          Check AmazonEKS_CNI_Policy
          Press "Add Permission"
       9) In Permissions policies, remove AmazonEKSClusterPolicy policy
          -- Check AmazonEKSClusterPolicy and press "Remove"


 3. Setup AWS ECR Registry (as dev.user)   which will hold our builds to be deployed
    a. Connect to AWS as dev.user and go to your console
    b. Search Services for ECR -> Select Elastic Container Registry
    c. Press "Get Started"
    d. In "Create repository"
       Visibility settings:  Private
       Repository name:      traderres
       In DOD:               Turn on KMS encryption
       Press "Create repository"

    e. Copy the URI:  524647912468.dkr.ecr.us-east-2.amazonaws.com/traderres

    f. Check your repository and press "View push commands"
       -- This has the procedures for using the AWS CLI to connect


 4. Configure the Amazon VPC (created by default for the dev.user)
    NOTE:  Default settings should be fine
    NOTE:  We can change the subnets are this point

    If you don't have any VPCs, follow these steps to manually create one
    a. Login as the dev.user
    b. Search Services for VPC
    c. Press "Create VPC"
	d. In the "Create VPC"
	   Select "VPC and more"

	   Name Tag: project       (default setting)
	   IPv4 CIDR: 10.0.0/16    (default setting)
	   IPv6 CIDR: No IPV6      (default setting)
	   Tenancy:   Default      (default setting)

	   Number of Avail Zones: 3     (because you have to have a minimum of 2 for lots of stuff / 3 should be auto-generated for you)

	   Number of public  subsets: 3
	   Number of private subsets: 3

	   VPC Endpoints:             None

	   DNS Options:
	      Enable DNS Hostnames    <checked>
	      Enable DNS resolution   <checked>

	   Press "Create VPC"

    e. Make sure your subnets enable IP/hostname resolution
       1) Click on VPC -> Subnets
       2) Edit your 1st public subnet -> Action -> Edit Subnet settings
          Check "Enable auto-assign public IPv4 address"
          Press "Save"

       3) Edit your 2nd public subnet -> Action -> Edit Subnet settings
          Check "Enable auto-assign public IPv4 address"
          Press "Save"

       4) Edit your 1st public subnet -> Action -> Edit Subnet settings
          Check "Enable auto-assign public IPv4 address"
          Press "Save"



 5. Create the EKS Cluster (as dev.user)
    a. Login as the dev.user

    b. Search Services for EKS -> Select Elastic Kubernetes Service  (as dev.user)

    c. Select "Add Cluster" -> Create

    d. In "Configure Cluster"
       Name:                  nccs
       Kubernetes version:    1.27  (or the latest)
       Cluster service role:  eksClusterRole
       Press "Next"

       Configure Kubernetes service IP address range:  Unchecked


    e. In Networking
       VPC:                               Choose default vpc
       Subnets:                           auto-selected both subnets for you
       Security groups:                   Choose the default security group
       Choose cluster IP address family:  IPv4
       Cluster endpoint access:           Public
       Press "Next"

    f. In Configure Logging
       Leave it all off for now
       Press "Next"

    g. In "Select add-ons"
       By default, it select Amazon VPC CNI, kube-proxy, CoreDNS
       Press "Next"

    h. In "Configure selected add-ons settings"
       Go with default and press "Next"
       Press "Next"

    i. In "Review and Create"
       Press "Create"

       W A I T    U P    T O    1 0     M I N      (for AWS to create it)

       -- Right now, we have a cluster with no nodes


 6. Finish configuring CNI Policy
    a. Get the OpenID Connect provider URL
       1) Configure your AWS CLI to talk to your new cluster
           unix> aws configure

	       	AWS Access Key ID:     <enter the first entry form the downloaded csv file>
    	   	AWS Secret Access Key: <enter the 2nd entry from the downloaded csv file>
       		Default region name:   us-east-2    (you get this from the AWS console, look next to your name and look at the default region)
       		Default output format  json

       2) Get the cluster info:
          unix> aws eks describe-cluster --name nccs --query "cluster.identity.oidc.issuer" --output text
          https://oidc.eks.us-east-1.amazonaws.com/id/ID_FROM_DESCRIBE_CLUSTER




    b. Grant anyone in our account to EKS/VPC/CNI
       1) Click on Roles
       2) Click on AmazonEKS_VPC_CNI_Role
       3) Click on "Trust relationships"
       4) Edit trust policy

          Replace the trust policy with this  (no tabs):
          Replace ID_FROM_DESCRIBE_CLUSTER with the value from the step above
          REPLACE MY_REGION with us-east-2 (if needed)

{
    "Version": "2012-10-17",
    "Statement": [
    {
        "Effect": "Allow",
        "Principal": {
              "Federated": "arn:aws:iam::524647912468:oidc-provider/oidc.eks.MY_REGION.amazonaws.com/id/ID_FROM_DESCRIBE_CLUSTER"
         },
         "Action": "sts:AssumeRoleWithWebIdentity",
         "Condition": {
         "StringEquals": {
              "oidc.eks.MY_REGION.amazonaws.com/id/ID_FROM_DESCRIBE_CLUSTER:aud": "sts.amazonaws.com",
              "oidc.eks.MY_REGION.amazonaws.com/id/ID_FROM_DESCRIBE_CLUSTER:sub": "system:serviceaccount:kube-system:aws-node"
              }
            }
        }
   ]
}


NOTE:  If you have multiple clusters, then you would have multiple statements:

{
    "Version": "2012-10-17",
    "Statement": [
    {
        "Effect": "Allow",
        "Principal": {
              "Federated": "arn:aws:iam::524647912468:oidc-provider/oidc.eks.us-east-1.amazonaws.com/id/ID_FROM_DESCRIBE_CLUSTER"
         },
         "Action": "sts:AssumeRoleWithWebIdentity",
         "Condition": {
         "StringEquals": {
              "oidc.eks.us-east-1.amazonaws.com/id/ID_FROM_DESCRIBE_CLUSTER:aud": "sts.amazonaws.com",
              "oidc.eks.us-east-1.amazonaws.com/id/ID_FROM_DESCRIBE_CLUSTER:sub": "system:serviceaccount:kube-system:aws-node"
              }
            }
        },

      {
        "Effect": "Allow",
        "Principal": {
              "Federated": "arn:aws:iam::524647912468:oidc-provider/oidc.eks.us-east-1.amazonaws.com/id/ID_FROM_DESCRIBE_CLUSTER"
         },
         "Action": "sts:AssumeRoleWithWebIdentity",
         "Condition": {
         "StringEquals": {
              "oidc.eks.us-east-1.amazonaws.com/id/ID_FROM_DESCRIBE_CLUSTER:aud": "sts.amazonaws.com",
              "oidc.eks.us-east-1.amazonaws.com/id/ID_FROM_DESCRIBE_CLUSTER:sub": "system:serviceaccount:kube-system:aws-node"
              }
            }
        }


   ]
}


     8) Press "Update policy"





 7. Create the keypair and inbound rule
    a. Go to EC2
    b. Look for Network & Security -> Key Pairs
    c. Press "Create key pair"
       Name:   node-for-kubunetes-instance
       Type:   RSA
       Format: PEM
       Press "Create key pair"
              -- You will be prompted to download the node-for-kubernetes-instance.pem

    d. Add an inbound rule for this node so that you can ssh from anywhere
       1) Go to EC2
       2) Click on Resources -> Security groups
       3) Check the default security group and press Action -> Edit Inbound Rules
       4) Press "Add Rule"
          Type:   SSH
          Source: Anywhere-IPv4
          Press "Save rule"

    e. Add another inbound rule for our default security group  (to let all traffic in and out)
       1) Go to EC2 Dashboard
       2) Click on Resources -> Security groups
       3) Check the default security group and press Action -> Edit Inbound Rules
       4) Press "Add Rule"
              Type:   All Traffic
              Source: Anywhere-IPv4
                      0.0.0.0/0
              Press "Save rule"


 8. Create Kubernetes Node Group  (as dev.user)
	a. Go to Amazon Elastic Kubernetes Services
	b. Click on your cluster (nccs)
	c. Click on "Compute"
	d. Press "Add node group"
	e. In "Configure node group"
		   Name:           nccs-node-group
		   Node IAM Role:  eksNodeRole
		   Press "Next"

	f. In "Node group compute configuration"
	   AMI Type:       Amazon Linux 2 (AL2_x86_64)
	   Capacity Type:  On-Demand                        (in DOD, we would have reserved instances)
	   Instance types  t3.medium
	   Disk size:      20 GiB

	   In Node group scaling configuration         (at a minimum, you want 2 nodes as one of the nodes is running keycloak)
		 Desired Size:   2 nodes
		 Minimum size:   2 nodes
		 Maximum size:   2 nodes         (so the whole kubernetes env is run on a SINGLE server)

	   In Node group update configuration   (this is the part of the auto-scaling features built into EKS)
	   -- Go with defaults

	   Pres "Next"


	g. In "Specify Networking"
		1) Select the both subnets
		2) Select "Configure ssh access for nodes"
		   -- In the warning, press "Enable"
           -- Subnets:                       <Use the down arrow to ONLY select your 3 public subnets / do not select private subnets)
		   -- SSH Key pair:                  Select node-for-kubernetes-instance
		   -- Allow SSH remote access from:  Selected security groups
		   -- For security groups:           Select default VPC security group

		Press "Next"

	h. In "Review and Create"
		Press "Create"

		NOTE:  At this point, I'm being charged for the t3.medium (which costs $2/day)

	i. W A I T      U P    T O       2      M I N       F O R     A W S    (to create the node group)

	j. While waiting, get the public IP of your instance
	   a. Go to the EC2 Dashboard -> instances
	   b. Check the checkbox on your newly-created instance
	   c. Look at the bottom details
		  -- You should see your public IP address

    k. Add the default security group to our running instance
       a. Go to EC2 -> Instances
       b. Check the checkbox next to our running instance
       c. Selection Actions -> Security -> Change security groups
       d. In "Associated security groups"
          Search for default
          Add it to the list
          press "Save"


 9. SSH to the node instance to update the yum packages of the running instance
    a. Get the public hostname or IP
       1) Go to EC2 -> Instances -> Check our running instance
       2) Get the public IPv4 address or Public IPv4 DNS hostname from the details

    b. Attempt to ssh to it
       1) Copy your node-for-kubunetes-instance.pem to your ~/.ssh directory
          unix> cp ~/Downloads/node-for-kubunetes-instance.pem  ~/.ssh

       2) Adjust the permissions so only you can read it:
          unix> chmod go-rwx ~/.ssh/node-for-kubunetes-instance.pem

       3) Attempt to ssh
          unix> ssh -i ~/.ssh/node-for-kubunetes-instance.pem ec2-user@18.218.246.201

          WARNING:  If you cannot ssh to the IP address of the instance, then make sure that instance has the default security group applied


       4) Once connected, then do a yum update
          unix> sudo yum update

          NOTE:  If there is a linux kernel update, then you should reboot the instance
                 with sudo reboot

       5) Install telnet command
          unix> sudo yum install telnet

       6) Install nslookup command
          unix> sudo yum install bind-utils




10. Initialize AWS-hosted resources (exist outside of the kubernetes cluster)   (as dev.user)
    NOTE:  postgres and OpenSearch do not run inside kubernetes
    a. Create the keycloak database
       1) In AWS, search for RDS / Select RDS   (as dev.user)
       2) Select Databases -> Press "Create database"
       3) In "Create database"
          Database creation method:  standard create
          Engine type:               PostgreSQL
          Engine version:            PostreSQL 14.6-R1
          Templates:                 Dev/Test
          Availability:              Single DB Instance

          Settings
             DB Instance identifier     keycloak-database          NOTE:  This is not the same as the database name
             Master username:           keycloak_user
             Master password            secret123

          Instance configuration
             DB Instance class:             Burstable / db.t3.micro
             Include previous gen classes:  Unchecked

          Storage
             Storage Type:                General Purpose SSD (gp2)
             Allocated storage:           20 GB
             Enable storage autoscaling:  Unchecked

		  Connectivity:
		     Compute Resource:               Don't Connect to an EC2 computer resource
		     VPC:                            <Choose default VPC / project-vpc>
		     DB Subnet Group:                <choose default subnet>
		     Public Access:                  No   (you can only access this database from inside the cluster)
		     Existing VPC Security Groups:   <Select default VPC>
             Additional VPC security group:  Empty

                                             NOTE:  If I want to make the database open to all, set the VPC security group to include "Default"

          Additional Configuration:
             Database Port:                   5432
             Initial database name:           keycloak_db

          Database authentication:           Password authentication

          Monitoring:
            Uncheck "Turn on Performance Insights"
            Uncheck "Enable enhanced monitoring"

          Additional Configuration
            Uncheck "Enable automated backups"
            Check   "Enable encryption"

          Maintenance
            Uncheck "Enable auto minor version upgrade"

          Press "Create database"


    b. Create the app database
       1) In AWS, search for RDS / Select RDS   (as dev.user)
       2) Select Databases -> Press "Create database"
       3) In "Create database"
          Database creation method:  standard create
          Engine type:               PostgreSQL
          Engine version:            PostreSQL 14.6-R1
          Templates:                 Dev/Test
          Availability:              Single DB Instance

          Settings
             DB Instance identifier     app-database
             Master username:           app_user
             Master password            secret12

          Instance configuration
             DB Instance class:              Burstable / db.t3.micro
             Include previous gen classes:   Unchecked

          Storage
             Storage Type:                   General Purpose SSD (gp2)
             Allocated storage:              20 GB
             Enable storage auto-scaling:    Unchecked

		  Connectivity:
		     Compute resource:               Don't connect to an EC2 compute resource
		     Network type:                   IPv4
		     VPC:                            <Choose default VPC / project-vpc>
		     DB Subnet Group:                <choose default subnet>
		     Public Access:                  No   (you can only access this database from inside the cluster)
		     Existing VPC Security Groups:   <Select default VPC>
             Additional VPC security group:  Empty

          Additional Configuration:
             Database Port:                   5432
             Initial database name:           app_db

          Database authentication:           Password authentication

          Monitoring:
            Uncheck "Turn on Performance Insights"
            Uncheck "Enable enhanced monitoring"

          Additional Configuration
            Uncheck "Enable automated backups"
            Check   "Enable encryption"

          Maintenance
            Uncheck "Enable auto minor version upgrade"

          Press "Create database"



    c. Setup OpenSearch
       1) In AWS -> Amazon OpenSearch Service   (as dev.user)
       2) Press "Create domain"
          In "Create domain"
             Domain Name:               app-opensearch

             Domain creation method:    standard

             Templates:
                 choose Dev/Test

             Deployment Option(s)
                 choose Domain without standby
                 Availability zones:  1-AZ


             Engine Options
                 Version:            ElasticSearch 7.10

             Data nodes:
                 Instance Type:             t3.small.search
                 Number of nodes:           3

                 Storage Type:              EBS   (Elastic Block Store)
                 EBS Volume Type:           gp3         NOTE:  gp3 is faster than gp2
                 EBS Storage size per node   10

                 Total Provisioned IPOS:        <default of 3000>
                 Total Provisioned Throughput   <default of 125 MiB/s>


             Dedicated master nodeS:
                Enable Dedicated master nodes:       Unchecked


             Custom endpoint:
                Enable automatic software update:    Unchecked

             Network
                Network:                       Check VPC access
                VPC:                           Select default vpc
                Subnets:                       Select public1-us-east-2a
                Security groups:               Select default

             Fine-grained access Control
                Fine-grained access control:       Checked
                Create master user:                Checked
                   master username:                es_user                # This must match the production application.yaml es.authentication.principal
                   master password:                Secret1@               # This must match the production application.yaml es.authentication.password

             Access Policy:
                Do not set domain level access policy

             Press "Create"

             W A I T        U P         T O        1 0     M I N U T E S    (for AWS to create the OpenSearch domain)


           3. Select Action -> Edit Security Configuration
              Domain Access policy
              -- Select configure domain level access policy
              -- Change the Access policy from "Effect" : "Deny" to "Allow"


      d. Label instances
		 1. Click EC2 -> Instances
		 2. Edited one of the instance name and changed it to keycloak
		 3. Edited one of the instance name and changed it to kubernetes-nodes


11. Create our own certificate authority (for pki client certs)
    NOTE:  Install on the keycloak server to make life easier for you
    a. Create certificate authority:
       learnSSL / howToUseYourCertAuthority_InitialSetup_centos7.txt

    b. Create PKI Client cert #1 with john.smith.12345
       learnSSL / howToUseYourCertAuthority_MakeClientCert_centos7.txt
       NOTE:  Make the Common Name:  JOHN.SMITH.12345

    c. Create PKI client cert #2 with WILL.FRANKLIN.22222
       learnSSL / howToUseYourCertAuthority_MakeClientCert_centos7.txt
       NOTE:  Make the Common Name:  WILL.FRANKLIN.22222


12. Configure your local kubectl command to talk to our new Kubernetes cluster
    NOTE:  Kubernetes is running but there are no pods running at this time
    a. Download the kubectl command
       unix> cd /tmp
       unix> curl -LO https://dl.k8s.io/release/v1.26.0/bin/linux/amd64/kubectl
       unix> sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl

       unix> which kubectl
       /usr/local/bin/kubectl

    b. Erase or move the existing .kube
       unix> mv ~/.kube ~/.kube-localhost

    c. Run aws configure to login as the dev.user   (you will need the dev.user_accessKeys.csv)
       unix> aws configure
       AWS Access Key ID [****************GZ7M]:         <enter the key from the dev.user_accessKeys.csv)
       AWS Secret Access Key [****************DeDp]      <enter the key from the dev.user_accessKeys.csv)
       Default region name [us-gov-west-1]:              <enter>
       Default output format [json]:                      <enter>

    d. Setup kubectl to be configured with your AWS cluster
       unix> aws eks update-kubeconfig --region <REGION_CODE> --name <MY CLUSTER NAME>
       *OR*
       unix> aws eks update-kubeconfig --region us-east-2  --name nccs

       AT THIS POINT, the kubectl command works!!!!!


    e. Verify that you can see the running nodes
       unix> kubectl get nodes

       NAME                                          STATUS   ROLES    AGE     VERSION
       ip-172-31-42-143.us-east-2.compute.internal   Ready    <none>   4h16m   v1.25.6-eks-48e63af

    f. List existing services
       unix> kubectl get services

       NAME         TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE
       kubernetes   ClusterIP   10.100.0.1   <none>        443/TCP   4h37m



13. Get the aws external hostname for keycloak and the app's loadbalancer
    Keycloak will run locally in your running node
    Keycloak's public IP will be the same as the running node's public IP
    a. Get keycloak's external hostname
       1) Go to AWS -> EC2 -> instances
       2) Check the checkbox for the running instance that is the keycloak server
       3) Get the Public IPv4 DNS
          ec2-160-1-14-243.us-gov-west-1.compute.amazonaws.com

    b. For now, the app's real external hostname is not known -- so we hard code it



14. Register the goDaddy domain name that corresponds to the external AWS keycloak and external AWS load balancer names
    a. Use goDaddy to register ec2-160-1-14-243.us-gov-west-1.compute.amazonaws.com with a CNAME of keycloak.traderres.com
       1) Login to goDaddy.com
       2) Go to My Account -> My Products
       3) Click on the "Domain" link for traderres.com
       4) Click "View Domain Settings"
          *or
          https://dcc.godaddy.com/control/traderres.com/settings

       5) In the menu select DNS -> Manage Zones
       6) Click on "View traderres.com"
       7) Under DNS Records, press "Add New Record"
          Type:   CNAME
          Name:   keycloak
          Value   ec2-160-1-14-243.us-gov-west-1.compute.amazonaws.com
          TTL:    Default

    b. Verify that keycloak.traderres.com is found in a DNS lookup
       unix> nslookup keycloak.traderres.com

       Non-authoritative answer:
       keycloak.traderres.com	canonical name = ec2-160-1-14-243.us-gov-west-1.compute.amazonaws.com.
       Name:	ec2-160-1-14-243.us-gov-west-1.compute.amazonaws.com
       Address: 18.218.246.201


	c. Use godaddy to register the *SAME* name used by keyclock (ec2-160-1-14-243.us-gov-west-1.compute.amazonaws.com) with a CNAME of app.traderres.com
	   NOTE:  THIS IS TEMPORARY -- we will replace it with the real name later on
	          WE ARE DOING THIS JUST TO GET THE APP'S SERVER CERT
		1) Login to godaddy.com
		2) Go to My Account -> My Products
		3) Click on the "Domain" link for traderres.com
		4) Click "View Domain Settings"
		   *or
		   https://dcc.godaddy.com/control/traderres.com/settings

		5) In the menu select DNS -> Manage Zones
		6) Click on "View traderres.com"
		7) Under DNS Records, press "Add New Record"
		   Type:   CNAME
		   Name:   app
		   Value   ec2-160-1-14-243.us-gov-west-1.compute.amazonaws.com
		   TTL:    Default


    d. Verify that app.traderres.com is found in a DNS lookup
       unix> nslookup app.traderres.com

		Non-authoritative answer:
		app.traderres.com	canonical name = ae512df1bdc3646ac961142b36441bc8-225527351.us-east-2.elb.amazonaws.com.
		Name:	ae512df1bdc3646ac961142b36441bc8-225527351.us-east-2.elb.amazonaws.com
		Address: 3.133.203.102
		Name:	ae512df1bdc3646ac961142b36441bc8-225527351.us-east-2.elb.amazonaws.com
		Address: 3.131.215.226



15. Create server certs with Let's Encrypt for the load-balancer (app.traderres.com) and keycloak (keycloak.traderres.com)
    NOTE:  The public Let's Encrypt certs are required to make sure that it all works in Firefox

    a. Create API keys in godaddy.com
       WARNING:  When creating the API key, this is the ONLY moment you can view the "secret" and the "key"

       1) Go to https://developer.godaddy.com/
       2) Login with your godaddy account
       3) Click on API keys
          *OR*
          https://developer.godaddy.com/keys
       4) Create New API Key
       5) In the popup
          Give it a name
          Select production
          Press "Next"
       6) Copy the "key" and "secret" values



    b. Set the "key" and "secret" values in the authenticate.sh script
       1) Ssh to the kubernetes instance
          unix> ssh -i ~/.ssh/node-for-kubunetes-instance.pem ec2-user@18.218.246.201

       2) Download the authenticate.sh script by going here:
          unix> mkdir /home/ec2-user/certbot
          unix> cd    /home/ec2-user/certbot
          unix> wget https://raw.githubusercontent.com/traderres/webClass/master/learnAWS/authenticate.sh
          unix> chmod ugo+x authentication.sh         # Make sure this script is executable

       2) Modify the authenticate.sh
          unix> vi  /home/ec2-user/certbot/authenticate.sh

          Change these values
             GODADDY_API_KEY="go-daddy-api-key-is-here"
             GODADDY_API_SECRET="go-daddy-secret-value-is-here"


    c. Install snapd on your linux box
       If you are installing snapd on Amazon Linux 2, follow these steps:
         ssh to amazon linux 2 box
         unix> sudo yum-config-manager --add-repo https://people.canonical.com/~mvo/snapd/amazon-linux2/snapd-amzn2.repo
         unix> sudo yum install snapd

       If you are installing on CentOS 8, follow these steps
         unix> unix> sudo dnf install snapd



    d. Enable the snapd.socket
       unix> sudo systemctl enable --now snapd.socket

    e. Enable classic snap support
       unix> sudo ln -s /var/lib/snapd/snap /snap

    f. Install the Certbot
       unix> sudo snap install --classic certbot
       NOTE:  If you get the warning:  too early for operation, device not yet seeded or device model not acknowledged,
              then wait 60 seconds and try again

    g. Prepare the Certbot command
       unix> sudo ln -s /snap/bin/certbot /usr/bin/certbot

    h. Verify that the snapd service is running
       unix> sudo systemctl status snapd

       You should see this
		● snapd.service - Snap Daemon
		   Loaded: loaded (/usr/lib/systemd/system/snapd.service; disabled; vendor preset: disabled)
		   Active: active (running) since Mon 2023-06-12 21:27:43 UTC; 18min ago
		 Main PID: 6348 (snapd)
		   CGroup: /system.slice/snapd.service
				   └─6348 /usr/libexec/snapd/snapd



    i. Use certbot to generate & download a valid "Let's Encrypt" server certificate for keycloak.traderres.com    [good for 90 days]
       NOTE:  this command uses the authenticate.sh script to verify that the dns entry is valid
       unix> sudo certbot certonly --manual --preferred-challenges dns --manual-auth-hook /home/ec2-user/certbot/authenticate.sh --config-dir /home/ec2-user/certbot/ -d keycloak.traderres.com

       NOTE:  First time, you will be prompted for your email address
       	    Enter email address (used for urgent renewal and security notices)
			- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			Please read the Terms of Service at
			https://letsencrypt.org/documents/LE-SA-v1.3-September-21-2022.pdf. You must
			agree in order to register with the ACME server. Do you agree?
			- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			(Y)es/(N)o: Y

			- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			Would you be willing, once your first certificate is successfully issued, to
			share your email address with the Electronic Frontier Foundation, a founding
			partner of the Let's Encrypt project and the non-profit organization that
			develops Certbot? We'd like to send you email about our work encrypting the web,
			EFF news, campaigns, and ways to support digital freedom.
			- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			(Y)es/(N)o: N


       You should see this:
		   Successfully received certificate.
		   Certificate is saved at: /home/ec2-user/certbot/live/keycloak.traderres.com/fullchain.pem
		   Key is saved at:         /home/ec2-user/certbot/live/keycloak.traderres.com/privkey.pem
		   This certificate expires on 2023-06-19.
		   These files will be updated when the certificate renews.
		   Certbot has set up a scheduled task to automatically renew this certificate in the background.


    j. Delete the TXT record in goDaddy or wait 600 seconds
       a. Go to https://dcc.godaddy.com/control/portfolio/traderres.com/settings
       b. Click on the DNS tab
       c. Delete the TXT _acme-challenge.app record


    k. Use certbot to generate & download a valid "Let's Encrypt" server certificate for app.traderres.com  [good for 90 days]
       unix> sudo certbot certonly --manual --preferred-challenges dns --manual-auth-hook /home/ec2-user/certbot/authenticate.sh --config-dir /home/ec2-user/certbot/ -d app.traderres.com

       You should see this:
			Successfully received certificate.
			Certificate is saved at: /home/ec2-user/certbot/live/app.traderres.com/fullchain.pem
			Key is saved at:         /home/ec2-user/certbot/live/app.traderres.com/privkey.pem
			This certificate expires on 2023-06-19.
			These files will be updated when the certificate renews.
			Certbot has set up a scheduled task to automatically renew this certificate in the background.


    l. Delete the TXT record in goDaddy or wait 600 seconds
       a. Go to https://dcc.godaddy.com/control/portfolio/traderres.com/settings
       b. Click on the DNS tab
       c. Delete the TXT _acme-challenge.app record



       You should have these files in the /home/ec2-user/certbot/ directory
			/home/ec2-user/certbot/authenticate.sh
			/home/ec2-user/certbot/accounts/acme-v02.api.letsencrypt.org/directory/68b94de449e93940f9dee6a35ccf9d4d/private_key.json
			/home/ec2-user/certbot/accounts/acme-v02.api.letsencrypt.org/directory/68b94de449e93940f9dee6a35ccf9d4d/meta.json
			/home/ec2-user/certbot/accounts/acme-v02.api.letsencrypt.org/directory/68b94de449e93940f9dee6a35ccf9d4d/regr.json
			/home/ec2-user/certbot/renewal/keycloak.traderres.com.conf
			/home/ec2-user/certbot/renewal/app.traderres.com.conf
			/home/ec2-user/certbot/archive/keycloak.traderres.com/cert1.pem
			/home/ec2-user/certbot/archive/keycloak.traderres.com/privkey1.pem
			/home/ec2-user/certbot/archive/keycloak.traderres.com/chain1.pem
			/home/ec2-user/certbot/archive/keycloak.traderres.com/fullchain1.pem
			/home/ec2-user/certbot/archive/app.traderres.com/cert1.pem
			/home/ec2-user/certbot/archive/app.traderres.com/privkey1.pem
			/home/ec2-user/certbot/archive/app.traderres.com/chain1.pem
			/home/ec2-user/certbot/archive/app.traderres.com/fullchain1.pem
			/home/ec2-user/certbot/live/README
			/home/ec2-user/certbot/live/keycloak.traderres.com/README
			/home/ec2-user/certbot/live/app.traderres.com/README




16. Install Java 11 JDK on the keycloak server
    NOTE:  Keycloak is an app running on the kubernetes instance
    a. Ssh to the kubernetes instance
       unix> ssh -i ~/.ssh/node-for-kubunetes-instance.pem ec2-user@18.218.246.201

    b. Install Java JDK 11 or later
       unix> sudo amazon-linux-extras install java-openjdk11

    c. Verify Java JDK 11 is installed
       unix> java -version
       openjdk version "11.0.18" 2023-01-17 LTS
       OpenJDK Runtime Environment (Red_Hat-11.0.18.0.10-1.amzn2.0.1) (build 11.0.18+10-LTS)
       OpenJDK 64-Bit Server VM (Red_Hat-11.0.18.0.10-1.amzn2.0.1) (build 11.0.18+10-LTS, mixed mode, sharing)



17. Create & install the keycloak certificates on the running instance
    NOTE:  Keycloak Server has Java 11 JDK's keytool
           If your development env uses an older Java JDK, then build the cert with the older Java JDK

    We need to install the files to here:
        /opt/keycloak/keycloak.keystore.jks
        /opt/keycloak/keycloak.truststore.jks

        ASSUMPTIONS:
           1) Your root-ca is on the keycloak server in /home/ec2-user/root-ca

           2) Your certbot is on the keycloak server in /home/ec2-user/certbot
                 And, so you have server cert files here:
                        /home/ec2-user/certbot/archive/app.traderres.com/
                        /home/ec2-user/certbot/archivee/keycloak.traderres.com/

                 If you are not running certbot on the keycloak server, then you need to upload files to
                        /home/ec2-user/certbot/archive on the keycloak server

                        Upload the files from my box to this keycloak server box
                        unix> cd ~/certbot
       					unix> scp  -i ~/.ssh/node-for-kubunetes-instance.pem  -r /home/ec2-user/certbot/archive ec2-user@18.218.246.201:/tmp


    a. Create the keycloak keystore
        1) ssh to the running instance that holds keycloak
           unix> ssh -i ~/.ssh/node-for-kubunetes-instance.pem  ec2-user@18.218.246.201

        2) Examine the 3 files that makeup the full chain / Split the full-chain into 3 files / Find the server cert
           NOTE:  The server cert has this:
                        CN=keycloak.traderres.com

		   unix> sudo -s
           unix> cd /home/ec2-user/certbot/archive/keycloak.traderres.com
           unix> cat fullchain1.pem | awk 'BEGIN {n=1};  split_after==1{n++;split_after=0} /-----END CERTIFICATE-----/ {split_after=1} {print > "fullchainkc" n ".pem"}'
                 -- Now, you have 3 new files:  fullchainkc1.pem, fullchainkc2.pem, fullchainkc3.pem

		   unix> openssl x509 -in fullchainkc1.pem -noout -text | grep 'keycloak.traderres.com'     # This one holds the server cert if you see CN=keycloak.traderres.com
		   unix> openssl x509 -in fullchainkc2.pem -noout -text | grep 'keycloak.traderres.com'
		   unix> openssl x509 -in fullchainkc3.pem -noout -text | grep 'keycloak.traderres.com'

        3) Generate the server.p12 file from the server cert
           unix> export SERVER_CRT=fullchainkc1.pem    # holds the cert that has CN=keycloak.traderres.com
		   unix> export SERVER_KEY=privkey1.pem
		   unix> export INTERMEDIATE_CA=fullchainkc2.pem
           unix> openssl pkcs12 -export -in $SERVER_CRT -inkey $SERVER_KEY -out server.p12 -name 'my-server-cert' -CAfile $INTERMEDIATE_CA -caname root
                 Enter Export Password: changeit
                 Verify Password:       changeit

        4) Convert the server.p12 into keycloak.keystore.jks
           unix> mkdir -p /opt/keycloak
           unix> rm -f /opt/keycloak/keycloak.keystore.jks
           unix> keytool -importkeystore -deststorepass changeit -destkeypass changeit -destkeystore /opt/keycloak/keycloak.keystore.jks  -srckeystore server.p12 -srcstoretype PKCS12 -srcstorepass changeit -alias 'my-server-cert'

        5) Import the 3 pem files into the keycloak.keystore.jks
           unix> keytool -import -alias "keycloak1"  -keystore /opt/keycloak/keycloak.keystore.jks  -file fullchainkc1.pem    -srcstorepass changeit  -deststorepass changeit    # If it's already imported, then don't bother
           unix> keytool -import -alias "keycloak2"  -keystore /opt/keycloak/keycloak.keystore.jks  -file fullchainkc2.pem    -srcstorepass changeit  -deststorepass changeit
           unix> keytool -import -alias "keycloak3"  -keystore /opt/keycloak/keycloak.keystore.jks  -file fullchainkc3.pem    -srcstorepass changeit  -deststorepass changeit


    d. Generate the keycloak truststore
       truststore needs to include the godaddy CA used for keycloak.traderres.com and intermediate CA
       truststore needs to include the self-signed CA used for PKI clients   (no intermediate)
       unix> cd /home/ec2-user/certbot/archive/keycloak.traderres.com
       unix> keytool -import -alias "keycloak1"  -keystore /opt/keycloak/keycloak.truststore.jks  -file fullchainkc1.pem  -storepass changeit
       unix> keytool -import -alias "keycloak2"  -keystore /opt/keycloak/keycloak.truststore.jks  -file fullchainkc2.pem -storepass changeit
       unix> keytool -import -alias "keycloak3"  -keystore /opt/keycloak/keycloak.truststore.jks  -file fullchainkc3.pem  -storepass changeit
       unix> keytool -import -alias "our-ca"     -keystore /opt/keycloak/keycloak.truststore.jks  -file /home/ec2-user/root-ca/public/root.pem  -storepass changeit


	   At this point, we have these 2 files:
	        /opt/keycloak/keycloak.keystore.jks
	        /opt/keycloak/keycloak.truststore.jks



18. Initialize Keycloak as a service on the running instance
    NOTE:  Keycloak is a container running on the kubernetes instance
    a. Ssh to the kubernetes instance
       unix> ssh -i ~/.ssh/node-for-kubunetes-instance.pem ec2-user@18.218.246.201

    b. Download keycloak 21.0.1 to the /opt/keycloak directory
       unix> sudo -s
       unix> cd /tmp
       unix> wget https://github.com/keycloak/keycloak/releases/download/21.0.1/keycloak-21.0.1.zip

    c. Install keycloak to the /opt/keycloak directory
       unix> mkdir -p /opt/keycloak
	   unix> unzip /tmp/keycloak-21.0.1.zip -d /opt/keycloak
       -- Now, you should have /opt/keycloak/keycloak-21.0.1

       unix> rm /tmp/keycloak-21.0.1.zip

    d. **OPTIONAL** Upload any jar files with custom key cloak themes to /opt/keycloak/keycloak-21.0.1/providers

    e. Build keycloak (as root)
       unix> sudo -s
       unix> cd /opt/keycloak/keycloak-21.0.1
       unix> bin/kc.sh build
       unix> exit

    f. Create a keycloak user
       unix> sudo groupadd keycloak
       unix> sudo useradd keycloak -c "Mr Keycloak" -g "keycloak" -m

    g. Change ownership so that the /opt/keycloak directory is owned by the keycloak user
       unix> sudo chown keycloak:keycloak -R /opt/keycloak

    h. Verify that keycloak runs from the command line
       NOTE:  Assumes that keycloak's default JRE is Java 11
              To find a version of java in your path
              unix> readlink -f `which java`

              If it's not, then adjust the /opt/keycloak/keycloak-21.0.1/bin/kc.sh and add these entries on line 2:
              unix> sudo -s
              unix> su - keycloak
              unix> vi /opt/keycloak/keycloak-21.0.1/bin/kc.sh

                   export JAVA_HOME=/usr/lib/jvm/java-11-openjdk-11.0.18.0.10-1.amzn2.0.1.x86_64       # REPLACE this with your real Java JDK 11 path
                   export PATH=${JAVA_HOME}/bin:$PATH
              unix> exit


       unix> sudo -s
       unix> su - keycloak
       unix> /opt/keycloak/keycloak-21.0.1/bin/kc.sh start --http-enabled=false --https-port=8444 --https-key-store-file=/opt/keycloak/keycloak.keystore.jks --https-key-store-type=JKS --https-key-store-password=changeit --https-trust-store-file=/opt/keycloak/keycloak.truststore.jks --https-trust-store-type=JKS --https-trust-store-password=changeit --https-client-auth=request --log-level=INFO --hostname-strict-https=false --hostname-strict=false --hostname=keycloak.traderres.com

       Verify it comes-up listening on port 0.0.0.0:8444

       Press Control-C to kill it




    i. Create a keycloak service
       unix> sudo vi /etc/systemd/system/keycloak.service

		###################################################################################
		# Filename:  keycloak.service
		#
		# Purpose:
		#   Describe how the keycloak service runs
		#
		# Notes:
		#   If you update this file, then follow these steps:
		#   unix> sudo systemctl daemon-reload
		#   unix> sudo systemctl start keycloak
		#
		#   Look at the log
		#   unix> sudo journalctl -fu keycloak
		###################################################################################
		[Unit]
		Description=Keycloak Application Server
		After=syslog.target network.target
		StartLimitIntervalSec=1d
		StartLimitBurst=3

		[Service]
		Type=simple
		Restart=on-failure
		RestartSec=2s

		# Disable timeout logic and wait until process is stopped
		TimeoutStopSec=0

		# SIGTERM signal is used to stop the Java process
		KillSignal=SIGTERM

		# Send the signal only to the JVM rather than its control group
		KillMode=process
		User=keycloak
		Group=keycloak
		RemainAfterExit=yes
		LimitNOFILE=102642
		ExecStart=/opt/keycloak/keycloak-21.0.1/bin/kc.sh start --http-enabled=false --https-port=8444 --https-key-store-file=/opt/keycloak/keycloak.keystore.jks --https-key-store-type=JKS --https-key-store-password=changeit --https-trust-store-file=/opt/keycloak/keycloak.truststore.jks --https-trust-store-type=JKS --https-trust-store-password=changeit --https-client-auth=request --log-level=INFO --hostname-strict-https=false --hostname-strict=false --hostname=keycloak.traderres.com

		# Database Options
		Environment=KC_DB=postgres
		Environment=KC_DB_URL=jdbc:postgresql://keycloak.csbk2jnrc8ao.us-east-2.rds.amazonaws.com/keycloak_db
		Environment=KC_DB_USERNAME=keycloak_user
		Environment=KC_DB_PASSWORD=secret123

		[Install]
		WantedBy=multi-user.target

     j. Update Database options in the /etc/systemd/system/keycloak.service to match the keycloak database in AWS
        a. Go into AWS -> RDS
        b. Click on the keyclaok-database
        c. In the "Connectivity & security" tab get the endpoint
           -- It should look something like this:  keycloak-database.csbk2jnrc8ao.us-east-2.rds.amazonaws.com

        d. Set that endpoint in
        unix> sudo vi /etc/systemd/system/keycloak.service

			Environment=KC_DB_URL=jdbc:postgresql://keycloak-database.csbk2jnrc8ao.us-east-2.rds.amazonaws.com/keycloak_db


     k. Reload systemctl daemon
        unix> sudo systemctl daemon-reload

     l. Start the service
        unix> sudo systemctl start keycloak

     m. Look at the service log
        unix> sudo journalctl -fu keycloak

     n. Verify that you can connect to keycloak
        Open a browser
        Connect to https://keycloak.traderres.com:8444/


19. Configure keycloak's admin account
    a. Setup the admin account
       1) Stop keycloak
          ssh to the running instance
          unix> ssh -i ~/.ssh/node-for-kubunetes-instance.pem ec2-user@18.218.246.201
          unix> sudo systemctl stop keycloak

       2) Set the admin username and password with ENV variables
          unix> sudo vi /etc/systemd/system/keycloak.service

          Add these 2 environment variables

          		Environment=KEYCLOAK_ADMIN=keycloak
          		Environment=KEYCLOAK_ADMIN_PASSWORD=secret12


            When finished, the systemd file should look like this:
			###################################################################################
			# Filename:  keycloak.service
			#
			# Purpose:
			#   Describe how the keycloak service runs
			#
			# Notes:
			#   If you update this file, then follow these steps:
			#   unix> sudo systemctl daemon-reload
			#   unix> sudo systemctl start keycloak
			#
			#   Look at the log
			#   unix> sudo journalctl -fu keycloak
			###################################################################################
			[Unit]
			Description=Keycloak Application Server
			After=syslog.target network.target
			StartLimitIntervalSec=1d
			StartLimitBurst=3

			[Service]
			Type=simple
			Restart=on-failure
			RestartSec=2s

			# Disable timeout logic and wait until process is stopped
			TimeoutStopSec=0

			# SIGTERM signal is used to stop the Java process
			KillSignal=SIGTERM

			# Send the signal only to the JVM rather than its control group
			KillMode=process
			User=keycloak
			Group=keycloak
			RemainAfterExit=yes
			LimitNOFILE=102642
			ExecStart=/opt/keycloak/keycloak-21.0.1/bin/kc.sh start --http-enabled=false --https-port=8444 --https-key-store-file=/opt/keycloak/keycloak.keystore.jks --https-key-store-type=JKS --https-key-store-password=changeit --https-trust-store-file=/opt/keycloak/keycloak.truststore.jks --https-trust-store-type=JKS --https-trust-store-password=changeit --https-client-auth=request --log-level=INFO --hostname-strict-https=false --hostname-strict=false --hostname=keycloak.traderres.com

			# Database Options
			Environment=KC_DB=postgres
			Environment=KC_DB_URL=jdbc:postgresql://keycloak.csbk2jnrc8ao.us-east-2.rds.amazonaws.com/keycloak_db
			Environment=KC_DB_USERNAME=keycloak_user
			Environment=KC_DB_PASSWORD=secret123

			Environment=KEYCLOAK_ADMIN=keycloak
			Environment=KEYCLOAK_ADMIN_PASSWORD=secret12

			[Install]
			WantedBy=multi-user.target



       3) Update the service
          unix> sudo systemctl daemon-reload

       4) Startup the service
          unix> sudo systemctl start keycloak

       5) Use a browser to connect to keycloak
          Connect to https://keycloak.traderres.com:8444/
          Press "Admin Console"
          Enter admin username:   keycloak
          Enter admin password:   secret12
          -- Verify that you can get in


    b. Configure the keycloak settings
       1) Connect to https://keycloak.traderres.com:8444/

       2) Select Realms -> Create realm: MyRealm
          Enabled:  On
          Press "Create"

	   3) Create an x509 authentication flow
	   	a. Click on Authentication
		b. Click on browser
		c. Selection Action -> Duplicate
		   Name:  x509 authentication flow
		d. Delete Everything
		e. Press "Add execution"
		   Select  Cookie and press "Add"
		   Change Cookie's Requirement to "Alternate"

		f. Press "Add step"
		   1) Press the "next" button a few times until you see x509/Validate Username Form
		   2) Select x509/Validate Username Form
		   3) Change X509/Validate Username From to Alternate
		   4) Press the "Settings" button

		   5) In the X509/Validate Username Form Config

			  Alias:                                        x509 configuration
			  User Identity Source:                         Match SubjectDN using regular expression
			  Regular expression to extract user identity:  cn=(.*?)(?:,|$)
			  User mapping method:                          Username or Email
			  Check certificate validity:                   On
			  Bypass identity confirmation                  Off

              Press "Save"

		   6) In x509 authentication flow, select Action -> Bind flow
			  Choose "Browser flow"
			  Press "Save"




		 4) Create the client: nccs-webapp
			a. Click on Clients
			b. Press "Create client"

			General Settings
			  Client type:           OpenID Connect
			  Client ID:             nccs-webapp
			  Name:                  nccs web app
			  Always display in UI:  Off
			  Press "Next"
			  Press "Next"
			  Press "Save"

			Access Settings:
			Root URL:              https://app.traderres.com/nccs
			Home URL:              https://app.traderres.com/nccs

			Capability Config:
			  Client authentication  On
			  Authorization          On
			  Authentication Flow:   Check Standard flow

			Login Settings
			   Login theme:               keycloak
			   Consent required:          Off
			   Display client on screen:  Off

			Press "Save"


		 5) Click on nccs-webapp / Credentials Tab
			Client Authenticator:  Client ID and Secret
            -- We will need this secret key in the deployment yaml file

		 6) Click on "Advanced" Tab
			Go to Authentication flow overrides
			Browser Flow:  x509 authentication flow
			Press "Save"


		 7) Create the realm role
		    a. Press Realm roles
		    b. Press "Create role"
			a. Create a role called NCCS_SUPERUSER


		 8) Assign that role to your test user
			a. Click on Users
			b. Press "Add User"
			c. Username:       Lastname.first
            d. Press "create"

			d. Click on "role Mappings"
			e. Press Assign Role
			f. Assign the NCCS_SUPERUSER role to this user


		 9) Tell keycloak to provide the roles to spring boot
			a. Click on Client Scopes
			b. Select roles
			c. In the settings tab for 'roles'
			   Include in token scope: On
               press "Save"

			d. Click on Client Scopes
			e. Select roles
			f. Select Mappers Tab
			g. Select Realm Roles
			f. In the settings for "Realm Role'
				  Add to ID Token:     On
				  Add to access token: On
				  Add to userinfo:     On




20. Configure certificates for the load-balancer (external hostname used to access the webapp)
    NOTE:  The webapp needs a load-balancer truststore to work correctly
           The webapp needs a special custom.cacerts file (that has the load-balancer chain and self-signed CA)

       ASSUMPTIONS:
           1) Your root-ca is on the keycloak server in /home/ec2-user/root-ca

           2) Your certbot is on the keycloak server in /home/ec2-user/certbot
                 And, so you have server cert files here:
                        /home/ec2-user/certbot/archive/app.traderres.com/
                        /home/ec2-user/certbot/archivee/keycloak.traderres.com/

                 If you are not running certbot on the keycloak server, then you need to upload files to
                        /home/ec2-user/certbot/archive on the keycloak server

                        Upload the files from my box to this keycloak server box
                        unix> cd ~/certbot
       					unix> scp  -i ~/.ssh/node-for-kubunetes-instance.pem  -r /home/ec2-user/certbot/archive ec2-user@18.218.246.201:/tmp


    a. Generate this file:  webapp.keystore.jks
       NOTE:  This file should should have the server cert for app.traderres.com in it

       1) ssh to the keycloak server
          ssh -i
          unix> sudo -s

       2) Examine the 3 files that makeup the full chain of the fullchain1.pem / Split it up into 3 files / Find the server cert
           unix> cd /home/ec2-user/certbot/archive/app.traderres.com
           unix> cat fullchain1.pem | awk 'BEGIN {n=1};  split_after==1{n++;split_after=0} /-----END CERTIFICATE-----/ {split_after=1} {print > "fullchain_part" n ".pem"}'
		   -- Now, we have 3 files called called fullchainkc1.pem, fullchainkc2.pem, fullchainkc3.pem

		   unix> openssl x509 -in fullchain_part1.pem -noout -text | grep 'app.traderres.com'        # Holds the server cert
		   unix> openssl x509 -in fullchain_part2.pem -noout -text | grep 'app.traderres.com'
		   unix> openssl x509 -in fullchain_part3.pem -noout -text | grep 'app.traderres.com'

        3) Generate the server.p12 file from the server cert
           unix> export SERVER_CRT=fullchain_part1.pem       # the cert that has CN=app.traderres.com
		   unix> export SERVER_KEY=privkey1.pem
		   unix> export INTERMEDIATE_CA=fullchain_part2.pem
           unix> openssl pkcs12 -export -in $SERVER_CRT -inkey $SERVER_KEY -out server.p12 -name 'my-server-cert' -CAfile $INTERMEDIATE_CA -caname root
           Enter Export Password: changeit
           Verify Password:       changeit

        4) Convert the server.p12 into webapp.keystore.jks
           unix> rm -f webapp.keystore.jks
           unix> keytool -importkeystore -deststorepass changeit -destkeypass changeit -destkeystore webapp.keystore.jks  -srckeystore server.p12 -srcstoretype PKCS12 -srcstorepass changeit -alias 'my-server-cert'




    b. Generate this file:  webapp.truststore.jks
       1) Import each file into the new webapp.truststore.jks file
          unix> cd /home/ec2-user/certbot/archive/app.traderres.com
          unix> rm -f webapp.truststore.jks
          unix> keytool -import -alias "new-lb1"  -keystore webapp.truststore.jks -file fullchain_part1.pem  -storepass changeit
          unix> keytool -import -alias "new-lb2"  -keystore webapp.truststore.jks -file fullchain_part2.pem  -storepass changeit
          unix> keytool -import -alias "new-lb3"  -keystore webapp.truststore.jks -file fullchain_part3.pem  -storepass changeit

        2) Import the self-signed root CA pem file into webapp.truststore.jks
           unix> keytool -import -alias "our-ca"  -keystore webapp.truststore.jks -file /home/ec2-user/root-ca/public/root.pem  -storepass changeit


    c. Generate this file:  custom.cacerts
       NOTE:  This is needed so that the spring security oauth2 authenticator can talk to the keycloak server

       1) Get the path of the cacerts file
          unix> find /usr/lib/jvm -iname cacerts -print

       2) Copy that file to custom.cacerts
          unix> cd /home/ec2-user/certbot/archive/app.traderres.com
          unix> sudo cp /usr/lib/jvm/java-11-openjdk-11.0.19.0.7-1.amzn2.0.1.x86_64/lib/security/cacerts  custom.cacerts   # Get this path from previous step
          unix> chmod ugo+rw custom.cacerts

       3) Import the certs into custom.cacerts
          unix> keytool -import -alias "new-lb1"  -keystore  custom.cacerts  -file fullchain_part1.pem  -storepass changeit
          unix> keytool -import -alias "new-lb2"  -keystore  custom.cacerts  -file fullchain_part2.pem  -storepass changeit
          unix> keytool -import -alias "new-lb3"  -keystore  custom.cacerts  -file fullchain_part3.pem  -storepass changeit
          unix> keytool -import -alias "our-ca"   -keystore  custom.cacerts  -file /home/ec2-user/root-ca/public/root.pem   -storepass changeit



21.  Get the environment values for the kubernetes deployment yaml files
     NOTE:  Fill-in this section with real values

	   env:
		   - name: POSTGRES_HOSTNAME
			 value: "server-running-postgres"
		   - name: POSTGRES_DB_USERNAME
			 value: "app1_user"
		   - name: POSTGRES_DB_PASSWORD
			 value: "secret"
		   - name: POSTGRES_DB_NAME
			 value: "app1_db"
		   - name: POSTGRES_SCHEMA_NAME
			 value: "app1_db"
		   - name: POSTGRES_POOL_SIZE
		     value: "50"
		   - name: ES_URL
			 value: "https://search-sf328-itwh3bby3wl3s7t6ur6pph2rti.us-gov-west-1.es.amazonaws.com:443"
		   - name: ES_USERNAME
			 value: "es_user"
		   - name: ES_PASSWORD
			 value: "es_secret"
		   - name: KEYCLOAK_CLIENT_ID
			 value: "nccs-webapp"
		   - name: KEYCLOAK_CLIENT_SECRET
			 value: "gyG7oTbHbenKecReYOJIg4F2fTaUtGDp"
		   - name: KEYCLOAK_ISSUER_URI
        	 value: "https://keycloak.rbr-tech.com:8444/realms/MyRealm"
		   - name: INCOMING_KEYSTORE_FILEPATH
			 value: "/shared-readonly/incoming/keystore.jks"
		   - name: INCOMING_KEYSTORE_PASSWORD
			 value: "changeit"
		   - name: INCOMING_TRUSTSTORE_FILEPATH
			 value: "/shared-readonly/incoming/truststore.jks"
		   - name: INCOMING_TRUSTSTORE_PASSWORD
			 value: "changeit"
		   - name: JAVA_TOOL_OPTIONS
			 value: -Xms250m -Xmx250m - -Demail.mode=off -Djavax.net.ssl.trustStore=/shared/certs/custom.cacerts -Djavax.net.ssl.trustStorePassword=changeit



22. Setup PersistentVolumes so you can share certs among the pods
    Goal is to make these files available to all pods:
       shared/certs/custom.cacerts                           #   Used by spring-boot so it trusts keycloak server's cert
       shared/certs/nccs.webapp.keystore.jks                 #   INCOMING_KEYSTORE_FILEPATH
       shared/certs/nccs.webapp.truststore.jks               #   INCOMING_TRUSTSTORE_FILEPATH

    See https://repost.aws/knowledge-center/eks-persistent-storage     # BE WARNED:  This is set for commercial (not aws-gov) and there are typos


   a. Install the eksctl program for linux
      unix> ARCH=amd64         # this is also for x86_64
      unix> PLATFORM=$(uname -s)_$ARCH
      unix> cd /tmp
      unix> curl -sLO "https://github.com/weaveworks/eksctl/releases/latest/download/eksctl_$PLATFORM.tar.gz"
      unix> tar xvf eksctl_Linux_amd64.tar.gz
      unix> sudo mv /tmp/eksctl /usr/local/bin

   b. Grant the CSI Driver Policy to the eksNodeRole in AWS IAM  (so that the nodes have the authority to read/write to the EBS volumes)
      a. Go to IAM -> Roles -> EksNodeRole
      b. Grant this policy: AmazonEBSCSIDriverPolicy

   c. Create an identify provider
      unix> eksctl utils associate-iam-oidc-provider --cluster <MY-CLUSTER-NAME> --approve

   d. Verify that you can see your identity provider
      unix> aws iam list-open-id-connect-providers

      You should see something like this:
		{
			"OpenIDConnectProviderList": [
				{
					"Arn": "arn:aws-us-gov:iam::527362555097:oidc-provider/oidc.eks.us-gov-west-1.amazonaws.com/id/DA006D8E0177E850A3A0489D305D960B"
				}
			]
		}

   e. Create an IAM trust policy file using the arn and id from above
	   {
		 "Version": "2012-10-17",
		 "Statement": [
		   {
			 "Effect": "Allow",
			 "Principal": {
			   "Federated": "<REPLACE WITH ENTIRE Arn STRING>"
			 },
			 "Action": "sts:AssumeRoleWithWebIdentity",
			 "Condition": {
			   "StringEquals": {
				 "<REPLACE WITH OID STRING>:aud": "sts.amazonaws.com",
				 "<REPLACE WITH OID STRING>:sub": "system:serviceaccount:kube-system:ebs-csi-controller-sa"
			   }
			 }
		   }
		 ]
	   }

	   For us, it looks like this:

	   {
		 "Version": "2012-10-17",
		 "Statement": [
		   {
			 "Effect": "Allow",
			 "Principal": {
			   "Federated": "arn:aws-us-gov:iam::527362555097:oidc-provider/oidc.eks.us-gov-west-1.amazonaws.com/id/DA006D8E0177E850A3A0489D305D960B"
			 },
			 "Action": "sts:AssumeRoleWithWebIdentity",
			 "Condition": {
			   "StringEquals": {
				 "oidc.eks.us-gov-west-1.amazonaws.com/id/DA006D8E0177E850A3A0489D305D960B:aud": "sts.amazonaws.com",
				 "oidc.eks.us-gov-west-1.amazonaws.com/id/DA006D8E0177E850A3A0489D305D960B:sub": "system:serviceaccount:kube-system:ebs-csi-controller-sa"
			   }
			 }
		   }
		 ]
	   }


  f. Create the role:  AmazonEKS_EBS_CSI_DriverRole
     unix>  aws iam create-role  --role-name AmazonEKS_EBS_CSI_DriverRole  --assume-role-policy-document file://"trust-policy.json"

  g. Attach this new role to the AmazonEBSCSIDriverPolicy amazon policy
     unix> aws iam attach-role-policy  --policy-arn arn:aws:iam::aws:policy/service-role/AmazonEBSCSIDriverPolicy  --role-name AmazonEKS_EBS_CSI_DriverRole

  h. Deploy the driver (for aws-gov-cloud)
     unix> export YOUR_ACCOUNT_ID=527362555097
     unix> export YOUR_CLUSTER_NAME=nccs
     unix> aws eks create-addon --cluster-name ${YOUR_CLUSTER_NAME} --addon-name aws-ebs-csi-driver  --service-account-role-arn arn:aws-us-gov:iam::${YOUR_ACCOUNT_ID}:role/AmazonEKS_EBS_CSI_DriverRole
           NOTE:  This command is set for aws-gov-cloud


  i. Test the Amazon EBS CSI driver:
     unix> git clone https://github.com/kubernetes-sigs/aws-ebs-csi-driver.git
     unix> cd aws-ebs-csi-driver/examples/kubernetes/dynamic-provisioning/
     unix> kubectl apply -f manifests/

		   NOTE:
		      -- This creates a 4 Gi persistent volume claim called ebs-claim

				storageclass.yaml
				-----------------
				apiVersion: storage.k8s.io/v1
                kind: StorageClass
                metadata:
                  name: ebs-sc
                provisioner: ebs.csi.aws.com
                volumeBindingMode: WaitForFirstConsumer


				claim.yaml
				----------
				apiVersion: v1
				kind: PersistentVolumeClaim
				metadata:
				  name: ebs-claim
				spec:
				  accessModes:
					- ReadWriteOnce
				  storageClassName: ebs-sc
				  resources:
					requests:
					  storage: 4Gi


				pod.yaml   (keeps appending every 5 seconds to /data/out.txt)
				--------
				apiVersion: v1
                kind: Pod
                metadata:
                  name: app
                spec:
                  containers:
                  - name: app
                    image: centos
                    command: ["/bin/sh"]
                    args: ["-c", "while true; do echo $(date -u) >> /data/out.txt; sleep 5; done"]
                    volumeMounts:
                    - name: persistent-storage
                      mountPath: /data
                  volumes:
                  - name: persistent-storage
                    persistentVolumeClaim:
                      claimName: ebs-claim





     You should see this:
       persistentvolumeclaim/ebs-claim created
       pod/app created
       storageclass.storage.k8s.io/ebs-sc created


 j. Describe the ebs-sc storage class:
    unix> kubectl describe storageclass ebs-sc

    You should see something like this:
		Name:            ebs-sc
		IsDefaultClass:  No
		Annotations:     kubectl.kubernetes.io/last-applied-configuration={"apiVersion":"storage.k8s.io/v1","kind":"StorageClass","metadata":{"annotations":{},"name":"ebs-sc"},"provisioner":"ebs.csi.aws.com","volumeBindingMode":"WaitForFirstConsumer"}

		Provisioner:           ebs.csi.aws.com
		Parameters:            <none>
		AllowVolumeExpansion:  <unset>
		MountOptions:          <none>
		ReclaimPolicy:         Delete
		VolumeBindingMode:     WaitForFirstConsumer
		Events:                <none>

 l. Watch the pods and wait for app status to be running
    unix> kubectl get pods --watch

	You should see this:
		NAME                               READY   STATUS             RESTARTS         AGE
		app                                1/1     Running            0                84s


 m. View the persistent volume that was created
    unix> kubectl get pv

    You should see this:
		NAME                                       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM               STORAGECLASS   REASON   AGE
		pvc-d960c622-4a01-4a2f-8209-4d6debff2090   4Gi        RWO            Delete           Bound    default/ebs-claim   ebs-sc                  112s


 n. View the detailed information on your persistent volume
    unix> kubectl describe pv pvc-d960c622-4a01-4a2f-8209-4d6debff2090

    You should see this:
		Name:              pvc-d960c622-4a01-4a2f-8209-4d6debff2090
		Labels:            <none>
		Annotations:       pv.kubernetes.io/provisioned-by: ebs.csi.aws.com
						   volume.kubernetes.io/provisioner-deletion-secret-name:
						   volume.kubernetes.io/provisioner-deletion-secret-namespace:
		Finalizers:        [kubernetes.io/pv-protection external-attacher/ebs-csi-aws-com]
		StorageClass:      ebs-sc
		Status:            Bound
		Claim:             default/ebs-claim
		Reclaim Policy:    Delete
		Access Modes:      RWO
		VolumeMode:        Filesystem
		Capacity:          4Gi
		Node Affinity:
		  Required Terms:
			Term 0:        topology.ebs.csi.aws.com/zone in [us-gov-west-1c]
		Message:
		Source:
			Type:              CSI (a Container Storage Interface (CSI) volume source)
			Driver:            ebs.csi.aws.com
			FSType:            ext4
			VolumeHandle:      vol-00c084488e5310556
			ReadOnly:          false
			VolumeAttributes:      storage.kubernetes.io/csiProvisionerIdentity=1684347075383-8081-ebs.csi.aws.com
		Events:                <none>

  o. Verify that the pod is writing data to the volume:
     unix> kubectl exec -it app -- cat /data/out.txt

     You should see the date time repeated
     	Wed May 17 18:37:46 UTC 2023
        Wed May 17 18:37:51 UTC 2023
        Wed May 17 18:37:56 UTC 2023
        Wed May 17 18:38:01 UTC 2023
        Wed May 17 18:38:06 UTC 2023
        Wed May 17 18:38:11 UTC 2023
        Wed May 17 18:38:16 UTC 2023
        Wed May 17 18:38:21 UTC 2023
        Wed May 17 18:38:26 UTC 2023
        Wed May 17 18:38:31 UTC 2023
        Wed May 17 18:38:36 UTC 2023
        Wed May 17 18:38:41 UTC 2023
        Wed May 17 18:38:46 UTC 2023
        Wed May 17 18:38:51 UTC 2023
        Wed May 17 18:38:56 UTC 2023
        Wed May 17 18:39:01 UTC 2023

  p. Stop the pod that is appending
     a. Delete the pod
        unix> kubectl delete pod app

     b. Delete the PersistentVolumeClaim (which deletes the PersistentVolume)
        unix> kubectl delete pvc ebs-claim

     c. Delete the storage class
        unix> kubectl delete sc ebs-sc


  q. Create the **REAL** storage class called "app-sc" for our webapps
     unix> vi app-storage-class.yaml

#############################################################
# app-storage-class.yaml
#
# volumeBindingModes include Immediate and WaitForFirstConsumer
#############################################################
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: app-sc
provisioner: ebs.csi.aws.com
volumeBindingMode: Immediate

		 unix> kubectl apply -f app-storage-class.yaml



  r. Create the **REAL** persistent volume claim called "app-pvc-certs" for our webapps to readonly
     unix> vi app-certs-pvc.yaml

#############################################################
#  app-certs-pvc.yaml
#
# Defines the PersistentVolumeClaim for our certs (so the containers can read the certs)
#############################################################
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: app-certs-pvc
spec:
  accessModes:
    - ReadWriteOnce
  storageClassName: app-sc
  resources:
    requests:
      storage: 1Gi


     unix> kubectl apply -f app-certs-pvc.yaml



 s. Add this section to the deployment.yaml

    volumeMounts:
    - name: persistent-storage
      mountPath: /shared/certs
  volumes:
  - name: persistent-storage
    persistentVolumeClaim:
      claimName: app-certs-pvc




23. Upload the shared certs into the /shared/certs persistent volume
    a. Create a temporary pod (called app2) that has this PVC mounted
       unix> vi app2-pod.yaml

################################
# app2-pod.yaml
################################
apiVersion: v1
kind: Pod
metadata:
  name: app2
spec:

  volumes:
  - name: app-certs-pv
    persistentVolumeClaim:
      claimName: app-certs-pvc

  containers:
  - name: app2
    image: centos
    command: ["/bin/sh"]
    args: ["-c", "while true; do echo "hi"; sleep 5; done"]
    volumeMounts:
    - name: app-certs-pv
      mountPath: /shared/certs





    b. Deploy the pod
       unix> kubectl apply -f app2-pod.yaml

    c. Verify that the pod is up
       unix> kubectl logs -f app2
       hi
       hi
       hi


    d. Use the kubectl cp command to copy the file from your local filesystem to the pod's /shared/certs directory
       unix> cd /home/adam/certbot/archive/app.traderres.com
       unix> kubectl cp custom.cacerts         app2:/shared/certs/custom.cacerts
       unix> kubectl cp webapp.keystore.jks    app2:/shared/certs/webapp.keystore.jks
       unix> kubectl cp webapp.truststore.jks  app2:/shared/certs/webapp.truststore.jks

    e. Verify that the files are there
       unix> kubectl exec app2 -it /bin/sh
       container> cd /shared/certs
       container> ls -l

       -- You should see your 3 files

    f. Delete the running pod
       unix> kubectl delete pod app2


24. Use Kubernetes to deploy the webapp

    a. Delete existing deployment
       unix> kubectl delete deployment nccs-deployment

    b. Create the deployment script by adding the "env" section with Java settings
       unix> vi nccs-deployment-v1.yaml

#############################################################################
#  nccs-deployment-v1.yaml
#
# Purpose:   Tell kubernetes how to deploy the NCCS web app(s)
#
# Usage
#  1. Follow the steps to setup AWS credentials (so you can build & deploy)
#     https://github.com/traderres/webClass/blob/master/learnAWS/howToBuildAndPushToAmazonECR.txt
#
#  2. Build and push the containers to the Amazon ECR (image repository)
#     unix> mvn -Djib.to.auth.username=AWS -Djib.to.auth.password=$PASSWORD clean package -Pprod -PbuildImageAndPush
#
#  3. Edit the environment variables in this yaml file to match reality -- e.g., set the POSTGRES_HOSTNAME
#     a. Also edit the image name (in this yaml file) to make sure it matches what was pushed to the Amazon ECR
#
#  4. Tell kubernetes to deploy the sync service
#     unix> kubectl delete deployment nccs-deployment
#     unix> kubectl apply -f nccs-deployment-v2.2.3.yaml
#
#  5. Get the name of the running pod  (it changes every time)
#     unix> kubectl get pods
#
#     NAME                                            READY   STATUS         RESTARTS   AGE
#     nccs-deployment-69c9fd9db6-6wkcf                1/1     Running        0          19s
#
#  6. Look at the pod log to verify that the NCCS webapp is up
#     uniX> kubectl logs -f nccs-deployment-69c9fd9db6-6wkcf
#
# Notes:
#  A) The running pods do not have DNS so we need hostAliases to create an entry in /etc/hosts
#     that can resolve the keycloak.rbr-tech.com to 160.1.14.243
#     Use nslookup keycloak.rbr-tech.com to verify the IP
#  B) If you want 5 copies of the webapp, then change replicas to 5 (in this file)
#############################################################################
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nccs-deployment

spec:
  selector:
    matchLabels:
      app: nccs-backend
  replicas: 1
  strategy:
    type:  Recreate
  template:
    metadata:
      name: nccs-backend
      labels:
         app: nccs-backend
    spec:
      hostAliases:
      - ip: "160.1.14.243"
        hostnames:
          - "keycloak.rbr-tech.com"

      volumes:
      - name: app-certs-pv
        persistentVolumeClaim:
          claimName: app-certs-pvc

      containers:
      - image: 527362555097.dkr.ecr.us-gov-west-1.amazonaws.com/nccs:backend-2.2.3-SNAPSHOT
        imagePullPolicy: Always
        volumeMounts:
        - name: app-certs-pv
          mountPath: /shared/certs

        name: nccs-backend

        env:
           - name: POSTGRES_HOSTNAME
             value: "nccs.cgl3wyvjvqtu.us-gov-west-1.rds.amazonaws.com"
           - name: POSTGRES_DB_USERNAME
             value: "nccs_user"
           - name: POSTGRES_DB_PASSWORD
             value: "secret12"
           - name: POSTGRES_DB_NAME
             value: "nccs_db"
           - name: POSTGRES_SCHEMA_NAME
             value: "nccs_db"
           - name: POSTGRES_POOL_SIZE
             value: "50"
           - name: ES_URL
             value: "https://vpc-nccs-wxin7j6ech5f4i6bvhptdwldcu.us-gov-west-1.es.amazonaws.com:443"
           - name: ES_USERNAME
             value: "nccs_user"
           - name: ES_PASSWORD
             value: "Secret1@"
           - name: KEYCLOAK_CLIENT_ID
             value: "nccs-webapp"
           - name: KEYCLOAK_CLIENT_SECRET
             value: "gyG7oTbHbenKecReYOJIg4F2fTaUtGDp"
           - name: KEYCLOAK_ISSUER_URI
             value: "https://keycloak.rbr-tech.com:8444/realms/MyRealm"
           - name: INCOMING_KEYSTORE_FILEPATH
             value: "/shared/certs/nccs.webapp.keystore.jks"
           - name: INCOMING_KEYSTORE_PASSWORD
             value: "changeit"
           - name: INCOMING_TRUSTSTORE_FILEPATH
             value: "/shared/certs/nccs.webapp.truststore.jks"
           - name: INCOMING_TRUSTSTORE_PASSWORD
             value: "changeit"
           - name: JAVA_TOOL_OPTIONS
             value: -Xms1024m -Xmx1024m -Demail.mode=off -Djavax.net.ssl.trustStore=/shared/certs/custom.cacerts -Djavax.net.ssl.trustStorePassword=changeit




	 c. Verify that there are no special chars in the file by looking for them
		unix> cat -v -e nccs-deployment-v1.yaml

     d. Convert all tabs to spaces in the yaml file
        unix>

	 e. We create the deployment
		unix> kubectl create -f nccs-deployment-v1.yaml

	 f. Get a listing of the pods
		unix> kubectl get pods

		NAME                               READY   STATUS    RESTARTS   AGE
		nccs-deployment-c469974cb-tj4kk   1/1     Running   0          10s



	 g. Have AWS create and expose the load balancer service
		unix> kubectl expose deployment nccs-deployment --type=LoadBalancer --name=sf328-loadbalancer --port=443
		NOTE:  This create a new external hostname and IP address


	 h. Modify the created load balancer service by setting
		unix> kubectl edit service sf328-loadbalancer

		   targetPort=8443
		   sessionAffinity=ClientIP


	 i. Get the external hostname for this load balancer service
		unix> kubectl get services

		NAME                 TYPE           CLUSTER-IP     EXTERNAL-IP                                                               PORT(S)         AGE
		kubernetes           ClusterIP      10.100.0.1     <none>                                                                    443/TCP         27h
		sf328-loadbalancer   LoadBalancer   10.100.66.32   a913ec0732a4d4726a6d186c8233e52f-1165139498.us-east-2.elb.amazonaws.com   443:30493/TCP   5s



	 j. Update godaddy's cname record for app.traderres.com so that it corresponds to the new external hostname
		a. Go to https://dcc.godaddy.com/control/portfolio/traderres.com/settings
        b. Click on the DNS tab
		c. Edit the old CNAME record for "app"    (this corresponds to app.traderres.com)
		   Type:  CNAME
		   Name:  app
		   Value: a913ec0732a4d4726a6d186c8233e52f-1165139498.us-east-2.elb.amazonaws.com

		d. Press "Save"



	 k. Restart the keycloak server
		ssh to the running instance
		unix> ssh -i ~/.ssh/node-for-kubunetes-instance.pem ec2-user@18.218.246.201
		unix> sudo systemctl restart keycloak




25. Verify it works
    a. Create a pki client cert
    b. Import it into a browser
    c. Attempt to connect to https://app.traderres.som/sf




Troubleshooting
---------------
 A. Ssh to the running pod
    unix> kubectl get pods

    unix> kubectl exec -it nccs-deployment-5c944dc79f-sb8lc /bin/bash
    unix> curl https://keycloak.traderres.com:8444/realms/MyRealm
    -- Verify that you get info cleanly (without error)




How to Shutdown the entire AWS cluster (so you're not being billed for anything)
--------------------------------------------------------------------------------
 1. Go into ECR, and delete the repository images

 2. Delete the node group
    Go into EKS -> Clusters -> sf -> Compute
    Highlight the node group -> Delete

 3. Delete the OpenSearch domain
    Go into OpenSearch -> Click on sf328 domain ->

 4. Delete Postgres RDS
    Go into RDS -> Database
    Select the keycloak -> Action -> Delete
    Uncheck "Create final snapshot"
    Delete

    Go into RDS -> Database
    Select the sf328 -> Action -> Delete
    Uncheck "Create final snapshot"
    Delete

 5. Delete the EKS Cluster (lsat)
    Go into EKS -> Clusters -> sf -> delete

 6. Delete the EC2 Load balancer
    Go into EC2 -> Load balancers -> Action -> Delete









When deploying on AWS, remember that you need 2 signed server-certs
 1) Server Cert #1 will be used by keycloak
    Create it with subject alternative name = hostname, external IP, and internal IP
    NOTE:  Make sure the hostname is *FIRST* in the subect alternative name

 2) Server Cert #2 will be used by the sprint boot web app
    Create it with subject alternative name = external hostname, external IP
    NOTE:  Make sure the hostname is *FIRST* in the subect alternative name