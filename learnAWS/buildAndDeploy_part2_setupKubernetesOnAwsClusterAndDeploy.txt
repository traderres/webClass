How to Setup Kubernetes on AWS Cluster and Deploy using Keycloak Server for PKI Authentication
----------------------------------------------------------------------------------------------


General Approach
 1. User uses a browser to hit Java Web App
    -- User presents PKI certificate to Java Web App

 2. Spring Security redirects user to the Keycloak server
    -- User presents PKI certificate to keycloak

 3. User is presented a keycloak login page  (or it can be bypassed)
    -- User presses "Submit" button on keycloak login page
    -- User is redirected to the Java Web App with keycloak credentials
       *OR*
    -- If bypass setting is enabled, user goes directly to Java Web App with keycloak credentials

 4. Spring Security detects that authentication is successful
    -- Java code gets the user's roles and any additional info and adds MyUserInfo to the principal object

    NOTE:  Redirecting the user to the keycloak server is the most secure way of implementing security (according to the Keycloak folks)



ASSUMPTIONS:
 A) You can build your spring boot webapp as a container
    See learnKeycloak / howToConfigureKeycloakToUsePkiAuthenticationOnLocalhost.txt
    See learnAWS / buildAndDeploy_part1_buildWebappsAsRdaOrContainer.txt
 B) You have an AWS account
 C) You have installed the AWS CLI tool
 D) You have a registered domain called "traderres.com"



Goal: Deploy this webapp so anyone can get to it using https://www.traderres.com/sf


Setup local kubectl that is *NOT* part of minikube
---------------------------------------------------
 1. Remove the existing mini kube setup
    unix> mv ~/.kube ~/.kube-localhost

 2. Comment out this alias
    unix> vi ~/.bashrc
    ##   alias kubectl="minikube kubectl --"

 3. Download & install kubectl
    unix> cd /tmp
    unix> curl -LO https://dl.k8s.io/release/v1.26.0/bin/linux/amd64/kubectl
    unix> sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl

    unix> which kubectl
    /usr/local/bin/kubectl

 4. Set my kubectl configuration (so running kubectl connects to the AWS cluster)
    unix> aws eks update-kubeconfig --region us-east-1 --name sf

    You should see this:
        Added new context arn:aws:eks:us-east-1:524647912468:cluster/sf to /home/adam/.kube/config

 5. Login to the server
    unix> kubectl get services
    -- Now, your kubectl is setup to your cluster




Make the build and push to AWS ECR
----------------------------------
 1. Run aws configure
    unix> aws configure

    AWS Access Key ID [None]:    SECRET_KEY_ID
    AWS Secret Access Key:       SECRET_ACCESS_KEY
    Region:                      us-gov-west-1
    Default Output format:       json

 2. Get the authentication token
    unix> aws ecr get-login-password --region us-gov-west-1 | docker login --username AWS --password-stdin 527362555097.dkr.ecr.us-gov-west-1.amazonaws.com

 3. Adjust the pom.xml
    Change the buildImage profile
        <image>527362555097.dkr.ecr.us-gov-west-1.amazonaws.com/frms:${project.artifactId}-${project.version}</image>


 4. Build the image
    unix> mvn clean package -Pprod -PbuildImage

 5. Use Docker to push the image up
    unix> docker push  527362555097.dkr.ecr.us-gov-west-1.amazonaws.com/frms:sync-service-1.0.9-SNAPSHOT
    unix> docker push  527362555097.dkr.ecr.us-gov-west-1.amazonaws.com/frms:backend-1.0.9-SNAPSHOT




General Approach
----------------
 1. Setup AWS Account / Create Users / Grant CLI Access  (so we can push up builds to our AWS ECR Registry)
 2. Setup AWS CNI Policy / so dev.user can make changes to kubernetes
 3. Setup AWS ECR Registry (as dev.user)   which will hold our builds to be deployed)
 4. Configure the Amazon VPC (created by default for the dev.user)
 5. Create the EKS Cluster (as dev.user)
 6. Finish configuring CNI Policy
 7. Create the keypair and inbound rule
 8. Create Kubernetes Node Group
 9. SSH to the node instance to update the yum packages of the running instance
10. Initialize AWS-hosted resources (exist outside of the kubernetes cluster)
    NOTE:  postgres and OpenSearch do not run inside kubernetes
    a. Setup 2 RDS / postgres instances (one for the webapp and one for keycloak)
    b. Setup OpenSearch
11. Create our own certificate authority (for pki client certs)
12. Configure your local kubectl command to talk to our new Kubernetes cluster
13. Get the aws external hostnames for keycloak and the app's loadbalancer
14. Register the godayy domain name that correspond to the external AWS keycloak and external AWS load balancer names
15. Create server certs with Let's Encrypt for the load-balancer (app.traderres.com) and keycloak (keycloak.traderres.com)
16. Install Java 11 JDK on the keycloak server
17. Create & install the keycloak certificates on the running instance
18. Initialize Keycloak as a service on the running instsance
19. Configure keycloak
20. Configure certificates for the load-balancer (external hostname used to access the webapp)
21. Build and Push the webapp to Amazon ECR
22. Use Kubernetes to deploy the webapp
23. Verify it works



Procedure
---------
 1. Setup AWS Account / Create Users / Grant CLI Access  (so we can push up builds to our AWS ECR Registry)
    Goal:  Setup a user that can run the CLI to push-up builds
    a. Go to https://aws.com/

    b. Create the "administrators" group
       1) In AWS, go to Services -> IAM
       2) On the left, click on User groups
       3) Press "Create group"
          User group name:  administrators

       4) In the "Attach permissions policies"
          Add these role:
            AdministratorAccess


    b. Create the dev.user
       1) In AWS, go to Services -> IAM
       2) On the left, click on Users
       3) Press "Add Users"
       4) In "User details"
          User name:  dev.user
          Check "Provide user access to the AWS Management Console"
          Check "I want to create an IAM user"


          Custom password
             custom password:  enter it
             Uncheck "User must create a new password at next sign-in)

          Press "Next"

       5) In "Set permissions"
          Select "Attach policies directly"
          Search for CNI
          Check Off theses roles:  AmazonEKS_CNI_Policy
          Press "Next"

       6) Press "Create user"
          NOTE:  Grab the console sign-in link:   https://524647912468.signin.aws.amazon.com/console

       7) Add this user to the "administrators group"
          Return the user lists
          Click on the "dev.user" link
          Click on "Groups"
          Press "Add user to groups"
          Check "administrators"
          Press "Add user to group(s)"


       8) Create access keys for the dev.user
          1) Click on "Users"
          2) Click on dev.user
          3) Click on "Security Credentials"
          4) Click on "Create access key"
          5) Select Command Line interface
             Select "I understand the above"
             Press "Next"

          6) Description tag value:  leave it blank
             Press "Create access key"

          7) Download the key by pressing "Download .csv file"
            --> Save dev.user_accessKeys.csv to your ~/Downloads

           -- Now, the user called "dev.user" should have the authority to push up to the AWS ECR Registry


    c. Logout as root user


 2. Setup AWS CNI Policy (as the dev.user)
    a. Login as dev.user
       https://524647912468.signin.aws.amazon.com/console

    b. Verify that you have a VPC (created for you)
       Select your VPC, Press Action -> Edit VPC Settings
       -- Verify that "Enable DNS resolution" is checked
       -- Verify that "Enable DNS hostnames"  is checked
       -- Verify that you have subnets already created for you
       -- Verify that you have an Internet gateway created for you

    c. Create this role: eksClusterRole
       1) Go to AWS IAM page
       2) Click on Roles
       3) Press "Create Role"
       4) In Select trusted entity, choose "AWS service"
          In Use Cases for other AWS services, select EKS
          Select EKS - Cluster
          Press "Next"

       5) In "Add permissions", go with defaults and press "Next"

       6) In Name, review, and create
          Role name:  eksClusterRole
          Press "Create Role"

       7) In Roles, Check on eksClusterRole
          Select "Add permissions" -> Attach Policies
          Search for AmazonEKS and press Enter
          Check AmazonEKS_CNI_Policy
          Press "Add Permission"

       8) In the "Roles/ eksClusterRole page, select Trust relationships
          Verify that you see this:
			  {
				  "Version": "2012-10-17",
				  "Statement": [
					  {
						  "Effect": "Allow",
						  "Principal": {
							  "Service": "eks.amazonaws.com"
						  },
						  "Action": "sts:AssumeRole"
					  }
				  ]
			  }

    b. Create this role:  eksNodeRole
       1) Go to AWS IAM page
       2) Click on Roles
       3) Press "Create Role"
       4) In Select trusted entity, choose "AWS service"
          In Use Cases for other AWS services, select EKS
          Select EKS - Cluster
          Press "Next"
       5) In "Add permissions", go with defaults and press "Next"
       6) In Name, review, and create
          Role name:  eksNodeRole
          Press "Create Role"

       7) In Roles, Click on eksNodeRole
       8) Select "Add permissions" -> Attach Policies
          Search for AmazonEKS and press Enter
          Check AmazonEKS_CNI_Policy
          Check AmazonEKSWorkerNodePolicy
          Press "Add Permission"

       9) In the Roles / eksNodeRole, remove the AmazonEKSClusterPolicy
          -- In Permissions policies, check AmazonEKSClusterPolicy
          -- Press "Remove"

      10) In the Roles / eksNodeRole, Add the AmazonEC2ContainerRegistryReadOnly
          -- In Permissions policies, select Add permissions -> Attach policies
          -- Search for AmazonEC2container
          -- Check AmazonEC2ContainerRegistryReadOnly
          -- Press "Add permissions"

          At this point eksNodeRole, should have 3 policies:
          		AmazonEKSWorkerNodePolicy
           		AmazonEC2ContainerRegistryReadOnly
           		AmazonEKS_CNI_Policy,

     11) Click on "Trust relationships" (all of the worker nodes are running on ec2 hosted servers / this granting rights to the ec2 hosted instsances)
         Press "Edit trust policy"

         Find this line:
           "Service": "eks.amazonaws.com"

         Replace with this line:
           "Service": "ec2.amazonaws.com"

         Press "Update policy"



    c. Create this role:  AmazonEKS_VPC_CNI_Role
       1) Go to AWS IAM page
       2) Click on Roles
       3) Press "Create Role"
       4) In Select trusted entity, choose "AWS service"
          In Use Cases for other AWS services, select EKS
          Select EKS - Cluster
          Press "Next"
       5) In "Add permissions", go with defaults and press "Next"
       6) In Name, review, and create
          Role name:  AmazonEKS_VPC_CNI_Role
          Press "Create Role"

       7) In Roles, Click on AmazonEKS_VPC_CNI_Role
       8) Select "Add permissions" -> Attach Policies
          Search for cni and press Enter
          Check AmazonEKS_CNI_Policy
          Press "Add Permission"
       9) In Permissions policies, remove AmazonEKSClusterPolicy policy
          -- Check AmazonEKSClusterPolicy and press "Remove"


 3. Setup AWS ECR Registry (as dev.user)   which will hold our builds to be deployed
    a. Connect to AWS as dev.user and go to your console
    b. Search Services for ECR -> Select Elastic Container Registry
    c. Press "Get Started"
    d. In "Create repository"
       Visibility settings:  Private
       Repository name:      traderres
       In DOD:               Turn on KMS encryption
       Press "Create repository"

    e. Copy the URI:  524647912468.dkr.ecr.us-east-2.amazonaws.com/traderres

    f. Check your repository and press "View push commands"
       -- This has the procedures for using the AWS CLI to connect


 4. Configure the Amazon VPC (created by default for the dev.user)
    NOTE:  Default settings should be fine
    NOTE:  We can change the subnets are this point



 5. Create the EKS Cluster (as dev.user)
    a. Login as the dev.user

    b. Search Services for EKS -> Select Elastic Kubernetes Service  (as dev.user)

    c. Select "Add Cluster" -> Create

    d. In "Configure Cluster"
       Name:                  sf
       Kubernetes version:    1.25  (or the latest)
       Cluster service role:  eksClusterRole
       Press "Next"

       Configure Kubernetes service IP address range:  Unchecked


    e. In Networking
       VPC:                               Choose default vpc
       Subnets:                           auto-selected both subnets for you
       Security groups:                   Choose the default security group
       Choose cluster IP address family:  IPv4
       Cluster endpoint access:           Public
       Press "Next"

    f. In Configure Logging
       Leave it all off for now
       Press "Next"

    g. In "Select add-ons"
       Press "Next"

    h. In "Configure selected add-ons settings"
       Go with default and press "Next"

    i. In "Review and Create"
       Press "Create"

       W A I T    U P    T O    1 0     M I N      (for AWS to create it)

       -- Right now, we have a cluster with no nodes


 6. Finish configuring CNI Policy
    a. Get the OpenID Connect provider URL
       1) Configure your AWS CLI to talk to your new cluster
           unix> aws configure

	       	AWS Access Key ID:     <enter the first entry form the downloaded csv file>
    	   	AWS Secret Access Key: <enter the 2nd entry from the downloaded csv file>
       		Default region name:   us-east-2    (you get this from the AWS console, look next to your name and look at the default region)
       		Default output format  json

       2) Get the cluster info:
          unix> aws eks describe-cluster --name sf --query "cluster.identity.oidc.issuer" --output text
          https://oidc.eks.us-east-1.amazonaws.com/id/ID_FROM_DESCRIBE_CLUSTER




    b. Grant anyone in our account to EKS/VPC/CNI
       1) Click on Roles
       2) Click on AmazonEKS_VPC_CNI_Role
       3) Click on "Trust relationships"
       4) Edit trust policy

          Replace the trust policy with this  (no tabs):
          Replace ID_FROM_DESCRIBE_CLUSTER with the value from the step above
          REPLACE us-east-2 with us-east-2 (if needed)

{
    "Version": "2012-10-17",
    "Statement": [
    {
        "Effect": "Allow",
        "Principal": {
              "Federated": "arn:aws:iam::524647912468:oidc-provider/oidc.eks.us-east-1.amazonaws.com/id/ID_FROM_DESCRIBE_CLUSTER"
         },
         "Action": "sts:AssumeRoleWithWebIdentity",
         "Condition": {
         "StringEquals": {
              "oidc.eks.us-east-1.amazonaws.com/id/ID_FROM_DESCRIBE_CLUSTER:aud": "sts.amazonaws.com",
              "oidc.eks.us-east-1.amazonaws.com/id/ID_FROM_DESCRIBE_CLUSTER:sub": "system:serviceaccount:kube-system:aws-node"
              }
            }
        }
   ]
}


NOTE:  If you have multiple clusters, then you would have multiple statements:

{
    "Version": "2012-10-17",
    "Statement": [
    {
        "Effect": "Allow",
        "Principal": {
              "Federated": "arn:aws:iam::524647912468:oidc-provider/oidc.eks.us-east-1.amazonaws.com/id/ID_FROM_DESCRIBE_CLUSTER"
         },
         "Action": "sts:AssumeRoleWithWebIdentity",
         "Condition": {
         "StringEquals": {
              "oidc.eks.us-east-1.amazonaws.com/id/ID_FROM_DESCRIBE_CLUSTER:aud": "sts.amazonaws.com",
              "oidc.eks.us-east-1.amazonaws.com/id/ID_FROM_DESCRIBE_CLUSTER:sub": "system:serviceaccount:kube-system:aws-node"
              }
            }
        },

      {
        "Effect": "Allow",
        "Principal": {
              "Federated": "arn:aws:iam::524647912468:oidc-provider/oidc.eks.us-east-1.amazonaws.com/id/ID_FROM_DESCRIBE_CLUSTER"
         },
         "Action": "sts:AssumeRoleWithWebIdentity",
         "Condition": {
         "StringEquals": {
              "oidc.eks.us-east-1.amazonaws.com/id/ID_FROM_DESCRIBE_CLUSTER:aud": "sts.amazonaws.com",
              "oidc.eks.us-east-1.amazonaws.com/id/ID_FROM_DESCRIBE_CLUSTER:sub": "system:serviceaccount:kube-system:aws-node"
              }
            }
        }


   ]
}


     8) Press "Update policy"





 7. Create the keypair and inbound rule
    a. Go to EC2
    b. Look for Network & Security -> Key Pairs
    c. Press "Create key pair"
       Name:   node-for-kubunetes-instance
       Type:   RSA
       Format: PEM
       Press "Create key pair"
              -- You will be prompted to download the node-for-kubernetes-instance.pem

    d. Add an inbound rule for this node so that you can ssh from anywhere
       1) Go to EC2
       2) Click on Resources -> Security groups
       3) Check the default security group and press Action -> Edit Inbound Rules
       4) Press "Add Rule"
          Type:   SSH
          Source: Anywhere-IPv4
          Press "Save rule"

    e. Add another inbound rule for our default security group  (to let all traffic in and out)
       1) Go to EC2 Dashboard
       2) Click on Resoures -> Security groups
       3) Check the default security group and press Action -> Edit Inbound Rules
       4) Press "Add Rule"
              Type:   All Traffic
              Source: Anywhere-IPv4
                      0.0.0.0/0
              Press "Save rule"


 8. Create Kubernetes Node Group  (as dev.user)
	a. Go to Amazon Elastic Kubernetes Services
	b. Click on your cluster (sf)
	c. Click on "Compute"
	d. Press "Add node group"
	e. In "Configure node group"
		   Name:           sf-node-group
		   Node IAM Role:  eksNodeRole
		   Press "Next"

	f. In "Node group compute configuration"
	   AMI Type:       Amazon Linux 2 (AL2_x86_64)
	   Capacity Type:  On-Demand                        (in DOD, we would have reserved instances)
	   Instance types  t3.large only
	   Disk size:      20 GiB

	   In Node group scaling configuration
		 Desired Size:   1 nodes
		 Minimum size:   1 nodes
		 Maximum size:   1 nodes         (so the whole kubernetes env is run on a SINGLE server)

	   In Node group update configuration   (this is the part of the auto-scaling features built into EKS)
	   -- Go with defaults

	   Pres "Next"


	g. In "Specify Networking"
		1) Select the both subnets
		2) Select "Configure ssh access for nodes"
		   -- In the warning, press "Enable"
           -- Subnets:                       Select both
		   -- SSH Key pair:                  Select node-for-kubernetes-instance
		   -- Allow SSH remote access from:  Selected security groups
		   -- For security groups:           Select default security group

		Press "Next"

	h. In "Review and Create"
		Press "Create"

		NOTE:  At this point, I'm being charged for the t3.large (which costs $2/day)

	i. W A I T      U P    T O       2      M I N       F O R     A W S    (to create the node group)

	j. While waiting, get the public IP of your instance
	   a. Go to the EC2 Dashboard
	   b. Check the checkbox on your newly-created instance
	   c. Look at the bottom details
		  -- You should see your public IP address

    k. Add the default security group to our running instance
       a. Go to EC2 -> Instances
       b. Check the checkbox next to our running instance
       c. Selection Actions -> Security -> Change security groups
       d. In "Associated security groups"
          Search for default
          Add it to the list
          press "Save"


 9. SSH to the node instance to update the yum packages of the running instance
    a. Get the public hostname or IP
       1) Go to EC2 -> Instances -> Check our running instance
       2) Get the public IPv4 address or Public IPv4 DNS hostname from the details

    b. Attempt to ssh to it
       1) Copy your node-for-kubunetes-instance.pem to your ~/.ssh directory
          unix> cp ~/Downloads/node-for-kubunetes-instance.pem  ~/.ssh

       2) Adjust the permissions so only you can read it:
          unix> chmod go-rwx ~/.ssh/node-for-kubunetes-instance.pem

       3) Attempt to ssh
          unix> ssh -i ~/.ssh/node-for-kubunetes-instance.pem ec2-user@18.218.246.201

       4) Once connected, then do a yum update
          unix> sudo yum update

          NOTE:  If there is a linux kernel update, then you should reboot the instance
                 with sudo reboot


10. Initialize AWS-hosted resources (exist outside of the kubernetes cluster)   (as dev.user)
    NOTE:  postgres and OpenSearch do not run inside kubernetes
    a. Create the keycloak database
       1) In AWS, search for RDS / Select RDS   (as dev.user)
       2) Select Databases -> Press "Create database"
       3) In "Create database"
          Database creation method:  standard create
          Engine type:               PostgreSQL
          Engine version:            PostreSQL 14.6-R1
          Templates:                 Dev/Test
          Availability:              Single DB Instance

          Settings
             DB Instance identifier     keycloak          NOTE:  This is not the same as the database name
             Master username:           keycloak_user
             Master password            secret123

          Instance configuration
             DB Instance class:             Burstable / db.t3.micro
             Include previous gen classes:  Unchecked

          Storage
             Storage Type:                General Purpose SSD (gp2)
             Allocated storage:           20 GB
             Enable storage autoscaling:  Unchecked

		  Connectivity:
		     Network type:                   IPv4
		     VPC:                            <Choose default VPC>
		     DB Subnet Group:                <choose default subnet>
		     Public Access:                  No   (you can only access this database from inside the cluster)
		     Existing VPC Security Groups:   <Select default VPC>
             Additional VPC security group:  Empty

                                             NOTE:  If I want to make the database open to all, set the VPC security group to include "Default"

          Additional Configuration:
             Database Port:                   5432
             Initial database name:           keycloak_db

          Database authentication:           Password authentication

          Monitoring:
            Uncheck "Turn on Performance Insights"
            Uncheck "Enable enhanced monitoring"

          Additional Configuration
            Uncheck "Enable automated backups"
            Check   "Enable encryption"

          Maintenance
            Uncheck "Enable auto minor version upgrade"

          Press "Create database"


    b. Create the app database
       1) In AWS, search for RDS / Select RDS   (as dev.user)
       2) Select Databases -> Press "Create database"
       3) In "Create database"
          Database creation method:  standard create
          Engine type:               PostgreSQL
          Engine version:            PostreSQL 14.6-R1
          Templates:                 Dev/Test
          Availability:              Single DB Instance

          Settings
             DB Instance identifier     sf328
             Master username:           sf328_user
             Master password            secret12

          Instance configuration
             DB Instance class:              Burstable / db.t3.micro
             Include previous gen classes:   Unchecked

          Storage
             Storage Type:                   General Purpose SSD (gp2)
             Allocated storage:              20 GB
             Enable storage autoscaling:     Unchecked


		  Connectivity:
		     Network type:                   IPv4
		     VPC:                            <Choose default VPC>
		     DB Subnet Group:                <choose default subnet>
		     Public Access:                  No   (you can only access this database from inside the cluster)
		     Existing VPC Security Groups:   <Select default VPC>
             Additional VPC security group:  Empty


          Additional Configuration:
             Database Port:                   5432
             Initial database name:           sf328_db

          Database authentication:           Password authentication

          Monitoring:
            Uncheck "Turn on Performance Insights"
            Uncheck "Enable enhanced monitoring"

          Additional Configuration
            Uncheck "Enable automated backups"
            Check   "Enable encryption"

          Maintenance
            Uncheck "Enable auto minor version upgrade"

          Press "Create database"



    c. Setup OpenSearch
       1) In AWS -> Amazon OpenSearch Service   (as dev.user)
       2) Press "Create domain"
          In "Create domain"
             Domain Name:               sf328

             Domain creation method:    standard

             Enable custom endpoint:    Unchecked
             Deployment type:              Development and testing
             Version:                   7.10

             Availability Zone:         1-AZ
             Instance Type:             t3.small.search

             Number of nodes:           2

             Storage Type:              EBS   (Elastic Block Store)
             EBS Volume Type:           gp3         NOTE:  gp3 is faster than gp2
             EBS Storage size per node   10

             Total Privisions IPOS:        <default of 3000>
             Total Provisioned Throughput  <default of 125 MiB/s>

             Enable Dedicated master nodes:       Unchecked

             Enable automatic software update:    Unchecked

             Network
                Check VPC (access)
                Select subnets
                Select default security groups


             Fine-grained access control:       Checked
             Create master user:                Checked
                 master username:               sf328_user             # This must match the production application.yaml es.authentication.principal
                 master password:               Secret1@               # This must match the production application.yaml es.authentication.password

             Access Policy:
                Do not set domain level access policy

             Press "Create"

             W A I T        U P         T O        1 0     M I N U T E S    (for AWS to create the OpenSearch domain)


           3. Select Action -> Edit Security Configuration
              Domain Access policy
              -- Select configure domain level access policy
              -- Change the Access policy from "Effect" : "Deny" to "Allow"


      d. Label instances
		 1. Click EC2 -> Instances
		 2. Edited one of the instance name and changed it to keycloak
		 3.. Edited one of the instance name and changed it to webapps


11. Create our own certificate authority (for pki client certs)
    NOTE:  Install on the keycloak server to make life easier for you
    a. Create certificate authority:
       learnSSL / howToUseYourCertAuthority_InitialSetup_centos7.txt

    b. Create PKI Client cert #1 with john.smith.12345
       learnSSL / howToUseYourCertAuthority_MakeClientCert_centos7.txt
       NOTE:  Make the Common Name:  JOHN.SMITH.12345

    c. Create PKI client cert #2 with WILL.FRANKLIN.22222
       learnSSL / howToUseYourCertAuthority_MakeClientCert_centos7.txt
       NOTE:  Make the Common Name:  WILL.FRANKLIN.22222


12. Configure your local kubectl command to talk to our new Kubernetes cluster
    NOTE:  Kubernetes is running but there are no pods running at this time
    a. Download the kubectl command

    b. Erase or move the existing .kube
       unix> rm -rf ~/.kube

    c. Setup kubectl to be configured with your AWS cluster
       unix> aws eks update-kubeconfig --region <REGION_CODE> --name <MY CLUSTER NAME>
       *OR*
       unix> aws eks update-kubeconfig --region us-east-2  --name sf

    d. Verify that you can see the running nodes
       unix> kubectl get nodes

       NAME                                          STATUS   ROLES    AGE     VERSION
       ip-172-31-42-143.us-east-2.compute.internal   Ready    <none>   4h16m   v1.25.6-eks-48e63af


    e. List existing services
       unix> kubectl get services

       NAME         TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE
       kubernetes   ClusterIP   10.100.0.1   <none>        443/TCP   4h37m



13. Get the aws external hostname for keycloak and the app's loadbalancer
    Keycloak will run locally in your running node
    Keycloak's public IP will be the same as the running node's public IP
    a. Get keycloak's external hostname
       1) Go to AWS -> EC2 -> instances
       2) Check the checkbox for the running instance
       3) Get the Public IPv4 DNS
          ec2-18-218-246-201.us-east-2.compute.amazonaws.com

    b. For now, the app's real external hostname is not known -- so we hard code it



14. Register the godayy domain name that correspond to the external AWS keycloak and external AWS load balancer names
    a. Use godaddy to register ec2-18-218-246-201.us-east-2.compute.amazonaws.com with a CNAME of keycloak.traderres.com
       1) Login to godaddy.com
       2) Go to My Account -> My Products
       3) Click on the "Domain" link for traderres.com
       4) Click "View Domain Settings"
          *or
          https://dcc.godaddy.com/control/traderres.com/settings

       5) In the menu select DNS -> Manage Zones
       6) Click on "View traderres.com"
       7) Under DNS Records, press "Add New Record"
          Type:   CNAME
          Name:   keycloak
          Value   ec2-18-218-246-201.us-east-2.compute.amazonaws.com
          TTL:    Default

    b. Verify that keycloak.traderres.com is found in a DNS lookup
       unix> nslookup keycloak.traderres.com

       Non-authoritative answer:
       keycloak.traderres.com	canonical name = ec2-18-218-246-201.us-east-2.compute.amazonaws.com.
       Name:	ec2-18-218-246-201.us-east-2.compute.amazonaws.com
       Address: 18.218.246.201


	c. Use godaddy to register the *SAME* name used by keyclock (ec2-18-218-246-201.us-east-2.compute.amazonaws.com) with a CNAME of app.traderres.com
	   NOTE:  THIS IS TEMPORARY -- we will replace it with the real name later on
	          WE ARE DOING THIS JUST TO GET THE APP'S SERVER CERT
		1) Login to godaddy.com
		2) Go to My Account -> My Products
		3) Click on the "Domain" link for traderres.com
		4) Click "View Domain Settings"
		   *or
		   https://dcc.godaddy.com/control/traderres.com/settings

		5) In the menu select DNS -> Manage Zones
		6) Click on "View traderres.com"
		7) Under DNS Records, press "Add New Record"
		   Type:   CNAME
		   Name:   app
		   Value   ec2-18-218-246-201.us-east-2.compute.amazonaws.com
		   TTL:    Default


    d. Verify that app.traderres.com is found in a DNS lookup
       unix> nslookup app.traderres.com

		Non-authoritative answer:
		app.traderres.com	canonical name = ae512df1bdc3646ac961142b36441bc8-225527351.us-east-2.elb.amazonaws.com.
		Name:	ae512df1bdc3646ac961142b36441bc8-225527351.us-east-2.elb.amazonaws.com
		Address: 3.133.203.102
		Name:	ae512df1bdc3646ac961142b36441bc8-225527351.us-east-2.elb.amazonaws.com
		Address: 3.131.215.226



15. Create server certs with Let's Encrypt for the load-balancer (app.traderres.com) and keycloak (keycloak.traderres.com)
    NOTE:  The public Let's Encrypt certs are required to make sure that it all works in Firefox
    a. Create API keys in godaddy.com
       1) Go to https://developer.godaddy.com/
       2) Login with your godaddy account
       3) Click on API keys
          *OR*
          https://developer.godaddy.com/keys
       4) Create New API Key
       5) In the popup
          Give it a name
          Select production
          Press "Next"
       6) Copy the "key" and "secret" values

    b. Set the "key" and "secret" values in the authenticate.sh script
       1) Download the authenticate.sh script by going here:
          unix> cd /home/adam/certbox
          unix> wget https://raw.githubusercontent.com/traderres/webClass/master/learnAWS/authenticate.sh

       2) Modify the authenticate.sh
          unix> vi /home/adam/certbot/authenticate.sh

          Change these values
             GODADDY_API_KEY="go-daddy-api-key-is-here"
             GODADDY_API_SECRET="go-daddy-secret-value-is-here"


    c. Install snapd on your linux box
       unix> sudo dnf install snapd          # Install snapd on centos 8

    d. Enable the snapd.socket
       unix> sudo systemctl enable --now snapd.socket

    e. Enable classic snap support
       unix> sudo ln -s /var/lib/snapd/snap /snap

    f. Install the Certbot
       unix> sudo snap install --classic certbot

    g. Prepare the Certbot command
       unix> sudo ln -s /snap/bin/certbot /usr/bin/certbot

    h. Use certbot to generate a signed server certificate for keycloak.traderres.com
       NOTE:  this command uses the authenticate.sh script to verify that the dns entry is valid
       unix> sudo certbot certonly --manual --preferred-challenges dns --manual-auth-hook /home/adam/certbot/authenticate.sh --config-dir /home/adam/certbot/ -d keycloak.traderres.com

       You should see this:
		   Successfully received certificate.
		   Certificate is saved at: /home/adam/certbot/live/keycloak.traderres.com/fullchain.pem
		   Key is saved at:         /home/adam/certbot/live/keycloak.traderres.com/privkey.pem
		   This certificate expires on 2023-06-19.
		   These files will be updated when the certificate renews.
		   Certbot has set up a scheduled task to automatically renew this certificate in the background.


    i. Use certbot to generate a signed server certificate for app.traderres.com
       unix> sudo certbot certonly --manual --preferred-challenges dns --manual-auth-hook /home/adam/certbot/authenticate.sh --config-dir /home/adam/certbot/ -d app.traderres.com

       You should see this:
			Successfully received certificate.
			Certificate is saved at: /home/adam/certbot/live/app.traderres.com/fullchain.pem
			Key is saved at:         /home/adam/certbot/live/app.traderres.com/privkey.pem
			This certificate expires on 2023-06-19.
			These files will be updated when the certificate renews.
			Certbot has set up a scheduled task to automatically renew this certificate in the background.


       You should have these files:
			/home/adam/certbot/accounts/acme-v02.api.letsencrypt.org/directory/dca0cb294974effc7178f301802f3366/private_key.json
			/home/adam/certbot/accounts/acme-v02.api.letsencrypt.org/directory/dca0cb294974effc7178f301802f3366/meta.json
			/home/adam/certbot/accounts/acme-v02.api.letsencrypt.org/directory/dca0cb294974effc7178f301802f3366/regr.json
			/home/adam/certbot/renewal/keycloak.traderres.com.conf
			/home/adam/certbot/renewal/app.traderres.com.conf
			/home/adam/certbot/archive/keycloak.traderres.com/cert1.pem
			/home/adam/certbot/archive/keycloak.traderres.com/privkey1.pem
			/home/adam/certbot/archive/keycloak.traderres.com/chain1.pem
			/home/adam/certbot/archive/keycloak.traderres.com/fullchain1.pem
			/home/adam/certbot/archive/app.traderres.com/cert1.pem
			/home/adam/certbot/archive/app.traderres.com/privkey1.pem
			/home/adam/certbot/archive/app.traderres.com/chain1.pem
			/home/adam/certbot/archive/app.traderres.com/fullchain1.pem
			/home/adam/certbot/live/README
			/home/adam/certbot/live/keycloak.traderres.com/README
			/home/adam/certbot/live/app.traderres.com/README
			/home/adam/certbot/authenticate.sh



16. Install Java 11 JDK on the keycloak server
    NOTE:  Keycloak is an app running on the kubernetes instance
    a. Ssh to the kubernetes instance
       unix> ssh -i ~/.ssh/node-for-kubunetes-instance.pem ec2-user@18.218.246.201

    b. Install Java JDK 11 or later
       unix> sudo amazon-linux-extras install java-openjdk11

    c. Verify Java JDK 11 is installed
       unix> java -version
       openjdk version "11.0.18" 2023-01-17 LTS
       OpenJDK Runtime Environment (Red_Hat-11.0.18.0.10-1.amzn2.0.1) (build 11.0.18+10-LTS)
       OpenJDK 64-Bit Server VM (Red_Hat-11.0.18.0.10-1.amzn2.0.1) (build 11.0.18+10-LTS, mixed mode, sharing)



17. Create & install the keycloak certificates on the running instance
    NOTE:  Keycloak Server has Java 11 JDK's keytool
           If your development env uses an older Java JDK, then build the cert with the older Java JDK

    We need to install the files to here:
        /opt/keycloak/keycloak.keystore.jks
        /opt/keycloak/keycloak.truststore.jks

    a. Upload the let's encrypt certs to the running instance
       unix> chown adam:adam -R /home/adam/certbot
       unix> scp  -i ~/.ssh/node-for-kubunetes-instance.pem  -r /home/adam/certbot/archive ec2-user@18.218.246.201:/tmp

    b. Upload our public/root.pem (from our custom.ca) to the running instance
       unix> scp  -i ~/.ssh/node-for-kubunetes-instance.pem  /home/adam/root-ca/public/root.pem ec2-user@18.218.246.201:/tmp/self-signed.ca.pem

    c. Create the keycloak keystore
        1) ssh to the running instance
           unix> ssh  -i ~/.ssh/node-for-kubunetes-instance.pem  ec2-user@18.218.246.201

        2) Examine the 3 files that makeup the full chain / Split it up into 3 files / Find the server cert
           NOTE:  The server cert has this:
                        CN=keycloak.traderres.com

           unix> cd /tmp/archive/keycloak.traderres.com
           unix> cat fullchain1.pem
           -- Split this up into 3 files called fullchainkc1.pem, fullchainkc2.pem, fullchainkc3.pem

		   unix> openssl x509 -in fullchainkc1.pem -noout -text | grep 'keycloak.traderres.com'     # This one holds the server cert
		   unix> openssl x509 -in fullchainkc2.pem -noout -text | grep 'keycloak.traderres.com'
		   unix> openssl x509 -in fullchainkc3.pem -noout -text | grep 'keycloak.traderres.com'

        3) Generate the server.p12 file from the server cert
           unix> export SERVER_CRT=fullchainkc1.pem
		   unix> export SERVER_KEY=privkey1.pem
		   unix> export INTERMEDIATE_CA=fullchainkc2.pem
           unix> openssl pkcs12 -export -in $SERVER_CRT -inkey $SERVER_KEY -out server.p12 -name 'my-server-cert' -CAfile $INTERMEDIATE_CA -caname root
           Enter Export Password: changeit
           Verify Password:       changeit

        4) Convert the server.p12 into keycloak.keystore.jks
           unix> mkdir -p /opt/keycloak
           unix> rm -f /opt/keycloak/keycloak.keystore.jks
           unix> keytool -importkeystore -deststorepass changeit -destkeypass changeit -destkeystore /opt/keycloak/keycloak.keystore.jks  -srckeystore server.p12 -srcstoretype PKCS12 -srcstorepass changeit -alias 'my-server-cert'

        5) For keycloak keystore, import the 3 pem files into the keycloak.keystore.jks
           unix> keytool -import -alias "keycloak1"  -keystore /opt/keycloak/keycloak.keystore.jks  -file fullchainkc1.pem   # If it's already imported, then don't bother
           unix> keytool -import -alias "keycloak2"  -keystore /opt/keycloak/keycloak.keystore.jks  -file fullchainkc2.pem
           unix> keytool -import -alias "keycloak3"  -keystore /opt/keycloak/keycloak.keystore.jks  -file fullchainkc3.pem


    d. Generate the keycloak truststore
       truststore needs to include the godaddy CA used for keycloak.traderres.com and intermediate CA
       truststore needs to include the self-signed CA used for PKI clients   (no intermediate)
       unix> cd /tmp/archive/keycloak.traderres.com
       unix> keytool -import -alias "keycloak1"  -keystore /opt/keycloak/keycloak.truststore.jks  -file fullchainkc1.pem  -storepass changeit
             password: change it
             verify:   changeit

       unix> keytool -import -alias "keycloak2"  -keystore /opt/keycloak/keycloak.truststore.jks  -file fullchainkc2.pem -storepass changeit
       unix> keytool -import -alias "keycloak3"  -keystore /opt/keycloak/keycloak.truststore.jks  -file fullchainkc3.pem  -storepass changeit
       unix> keytool -import -alias "our-ca"     -keystore /opt/keycloak/keycloak.truststore.jks  -file /tmp/self-signed.ca.pem  -storepass changeit


	   At this point, we have these 2 files:
	        /opt/keycloak/keycloak.keystore.jks
	        /opt/keycloak/keycloak.truststore.jks



18. Initialize Keycloak as a service on the running instsance
    NOTE:  Keycloak is a container running on the kubernetes instance
    a. Ssh to the kubernetes instance
       unix> ssh -i ~/.ssh/node-for-kubunetes-instance.pem ec2-user@18.218.246.201

    b. Download keycloak 21.0.1 to the /opt/keycloak directory
       unix> sudo -s
       unix> cd /tmp
       unix> wget https://github.com/keycloak/keycloak/releases/download/21.0.1/keycloak-21.0.1.zip

    c. Install keycloak to the /opt/keycloak directory
       unix> mkdir -p /opt/keycloak
	   unix> unzip /tmp/keycloak-21.0.1.zip -d /opt/keycloak
       -- Now, you should have /opt/keycloak/keycloak-21.0.1


    d. Build keycloak (as root)
       unix> sudo -s
       unix> cd /opt/keycloak/keycloak-21.0.1
       unix> bin/kc.sh build
       unix> exit

    e. Create a keycloak user
       unix> sudo groupadd keycloak
       unix> sudo useradd keycloak -c "Mr Keycloak" -g "keycloak" -m

    f. Change ownership so that the /opt/keycloak directory is owned by the keycloak user
       unix> sudo chown keycloak:keycloak -R /opt/keycloak

    g. Verify that keycloak runs from the command line
       NOTE:  Assumes that keycloak's default JRE is Java 11
              To find a version of java in your path
              unix> readlink -f `which java`

              If it's not, then adjust the /opt/keycloak/keycloak-21.0.1/bin/kc.sh and add these entries on line 2:
              unix> sudo -s
              unix> su - keycloak
              unix> vi /opt/keycloak/keycloak-21.0.1/bin/kc.sh

                   export JAVA_HOME=/usr/lib/jvm/java-11-openjdk-11.0.18.0.10-1.amzn2.0.1.x86_64       # REPLACE this with your real Java JDK 11 path
                   export PATH=${JAVA_HOME}/bin:$PATH


       unix> sudo -s
       unix> su - keycloak
       unix> /opt/keycloak/keycloak-21.0.1/bin/kc.sh start --http-enabled=false --https-port=8444 --https-key-store-file=/opt/keycloak/keycloak.keystore.jks --https-key-store-type=JKS --https-key-store-password=changeit --https-trust-store-file=/opt/keycloak/keycloak.truststore.jks --https-trust-store-type=JKS --https-trust-store-password=changeit --https-client-auth=request --log-level=INFO --hostname-strict-https=false --hostname-strict=false --hostname=keycloak.traderres.com

       Verify it comes-up listening on port 0.0.0.0:8444

       Press Control-C to kill it




    h. Create a keycloak service
       unix> sudo vi /etc/systemd/system/keycloak.service

		###################################################################################
		# Filename:  keycloak.service
		#
		# Purpose:
		#   Describe how the keycloak service runs
		#
		# Notes:
		#   If you update this file, then follow these steps:
		#   unix> sudo systemctl daemon-reload
		#   unix> sudo systemctl start keycloak
		#
		#   Look at the log
		#   unix> sudo journalctl -fu keycloak
		###################################################################################
		[Unit]
		Description=Keycloak Application Server
		After=syslog.target network.target
		StartLimitIntervalSec=1d
		StartLimitBurst=3

		[Service]
		Type=simple
		Restart=on-failure
		RestartSec=2s

		# Disable timeout logic and wait until process is stopped
		TimeoutStopSec=0

		# SIGTERM signal is used to stop the Java process
		KillSignal=SIGTERM

		# Send the signal only to the JVM rather than its control group
		KillMode=process
		User=keycloak
		Group=keycloak
		RemainAfterExit=yes
		LimitNOFILE=102642
		ExecStart=/opt/keycloak/keycloak-21.0.1/bin/kc.sh start --http-enabled=false --https-port=8444 --https-key-store-file=/opt/keycloak/keycloak.keystore.jks --https-key-store-type=JKS --https-key-store-password=changeit --https-trust-store-file=/opt/keycloak/keycloak.truststore.jks --https-trust-store-type=JKS --https-trust-store-password=changeit --https-client-auth=request --log-level=INFO --hostname-strict-https=false --hostname-strict=false --hostname=keycloak.traderres.com

		# Database Options
		Environment=KC_DB=postgres
		Environment=KC_DB_URL=jdbc:postgresql://keycloak.csbk2jnrc8ao.us-east-2.rds.amazonaws.com/keycloak_db
		Environment=KC_DB_USERNAME=keycloak_user
		Environment=KC_DB_PASSWORD=secret123

		[Install]
		WantedBy=multi-user.target

     i. Reload systemctl daemon
        unix> sudo systemctl daemon-reload

     j. Start the service
        unix> sudo systemctl start keycloak

     k. Look at the service log
        unix> sudo journalctl -fu keycloak

     l. Verify that you can connect to keycloak
        Open a browser
        Connect to https://keycloak.traderres.com:8444/


19. Configure keycloak's admin account
    a. Setup the admin account
       1) Stop keycloak
          ssh to the running instance
          unix> ssh -i ~/.ssh/node-for-kubunetes-instance.pem ec2-user@18.218.246.201
          unix> sudo systemctl stop keycloak

       2) Set the admin username and password with ENV variables
          unix> sudo vi /etc/systemd/system/keycloak.service

          Add these 2 environment variables

          		Environment=KEYCLOAK_ADMIN=keycloak
          		Environment=KEYCLOAK_ADMIN_PASSWORD=secret12


          When finished, the systemd file should look like this:
			###################################################################################
			# Filename:  keycloak.service
			#
			# Purpose:
			#   Describe how the keycloak service runs
			#
			# Notes:
			#   If you update this file, then follow these steps:
			#   unix> sudo systemctl daemon-reload
			#   unix> sudo systemctl start keycloak
			#
			#   Look at the log
			#   unix> sudo journalctl -fu keycloak
			###################################################################################
			[Unit]
			Description=Keycloak Application Server
			After=syslog.target network.target
			StartLimitIntervalSec=1d
			StartLimitBurst=3

			[Service]
			Type=simple
			Restart=on-failure
			RestartSec=2s

			# Disable timeout logic and wait until process is stopped
			TimeoutStopSec=0

			# SIGTERM signal is used to stop the Java process
			KillSignal=SIGTERM

			# Send the signal only to the JVM rather than its control group
			KillMode=process
			User=keycloak
			Group=keycloak
			RemainAfterExit=yes
			LimitNOFILE=102642
			ExecStart=/opt/keycloak/keycloak-21.0.1/bin/kc.sh start --http-enabled=false --https-port=8444 --https-key-store-file=/opt/keycloak/keycloak.keystore.jks --https-key-store-type=JKS --https-key-store-password=changeit --https-trust-store-file=/opt/keycloak/keycloak.truststore.jks --https-trust-store-type=JKS --https-trust-store-password=changeit --https-client-auth=request --log-level=INFO --hostname-strict-https=false --hostname-strict=false --hostname=keycloak.traderres.com

			# Database Options
			Environment=KC_DB=postgres
			Environment=KC_DB_URL=jdbc:postgresql://keycloak.csbk2jnrc8ao.us-east-2.rds.amazonaws.com/keycloak_db
			Environment=KC_DB_USERNAME=keycloak_user
			Environment=KC_DB_PASSWORD=secret123

			Environment=KEYCLOAK_ADMIN=keycloak
			Environment=KEYCLOAK_ADMIN_PASSWORD=secret12

			[Install]
			WantedBy=multi-user.target



       3) Update the service
          unix> sudo systemctl daemon-reload

       4) Startup the service
          unix> sudo systemctl start keycloak

       5) Use a browser to connect to keycloak
          Connect to https://keycloak.traderres.com:8444/
          Press "Admin Console"
          Enter admin username
          Enter admin password
          -- Verify that you can get in


    b. Configure the keycloak settings
       1) Connect to https://keycloak.traderres.com:8444/

       2) Select Realms -> Create realm: MyRealm


	   3) Create an x509 authentication flow
		a. Click on Authentication
		b. Click on browser
		c. Selection Action -> Duplicate
		   Name:  x509 authentication flow
		d. Delete Everything
		e. Press "Add execution"
		   Select  Cookie and press "Add"
		   Change Cookie's Requirement to "Alternate"

		f. Press "Add step"
		   1) Press the "next" button a few times until you see x509/Validate Username Form
		   2) Select x509/Validate Username Form
		   3) Change X509/Validate Username From to Alternate
		   4) Press the "Settings" button

		   5) In the X509/Validate Username Form Config

			  Alias:                                        x509 configuration
			  User Identity Source:                         Match SubjectDN using regular expression
			  Regular expression to extract user identity:  cn=(.*?)(?:,|$)
			  User mapping method:                          Username or Email
			  Check certificate validity:                   On
			  Bypass identity confirmation                  Off

		   6) In x509 authentication flow, select Action -> Bind flow
			  Choose "Browser flow"
			  Press "Save"




		 4) Create the client: sf328-webapp
			a. Click on Clients
			b. Press "Create client"

			General Settings
			  Client type:           OpenID Connect
			  Client ID:             sf328-webapp
			  Name:                  SF328 Submissions
			  Always display in UI:  Off
			  Press "Next"
			  Press "Next"
			  Press "Save"

			Access Settings:
			Root URL:              https://app.traderres.com/sf
			Home URL:              https://app.traderres.com/sf

			Capability Config:
			  Client authentication  On
			  Authorization          On
			  Authentication Flow:   Check Standard flow

			Login Settings
			   Login theme:               keycloak
			   Consent required:          Off
			   Display client on screen:  Off

			Press "Save"


		 5) Click on SF328-webapp / Credentials Tab
			Client Authenticator:  Client ID and Secret

		 6) Click on "Advanced"
			Go to Authentication flow overrides
			Browser Flow:  x509 authentication flow
			Press "Save"


		 7) Create the realm role
		    a. Press Realm roles
		    b. Press "Create role"
			a. Create a role called SF328_USER


		 8) Assign that role to your test user
			a. Click on Users
			b. Press "Add User"
			c. Username:       Lastname.first
            d. Press "create"

			d. Click on "role Mappings"
			e. Press Assign Role
			f. Assign the SF328_USER role to this user


		 9) Tell keycloak to provide the roles to spring boot
			a. Click on Client Scopes
			b. Select roles
			c. In the settings for 'roles'
			   Include in token scope: On

			d. Click on Client Scopes
			e. Select roles
			f. Select Mappers
			g. Select Realm Roles
			f. In the settings for "Realm Role'
				  Add to ID Token:     On
				  Add to access token: On
				  Add to userinfo:     On




20. Configure certificates for the load-balancer (external hostname used to access the webapp)
    NOTE:  The webapp needs a load-balancer truststore to work correctly
           The webapp needs a special custom.cacerts file (that has the lob chain and self-signed CA)

    NOTE:  You should have the signed cert files for app.traderres.com here:
			/home/adam/certbot/archive/app.traderres.com/cert1.pem
			/home/adam/certbot/archive/app.traderres.com/privkey1.pem
			/home/adam/certbot/archive/app.traderres.com/chain1.pem
			/home/adam/certbot/archive/app.traderres.com/fullchain1.pem

    a. Generate this file:  webapp.keystore.jks
       NOTE:  This file should should have the server cert for app.traderres.com in it

       1) Examine the 3 files that makeup the full chain of the fullchain1.pem / Split it up into 3 files / Find the server cert
           NOTE:  The server cert has this:
                        CN=app.traderres.com

           unix> cd /home/adam/certbot/archive/app.traderres.com
           unix> cat fullchain1.pem
           -- Split this up into 3 files called fullchainkc1.pem, fullchainkc2.pem, fullchainkc3.pem

		   unix> openssl x509 -in fullchain_part1.pem -noout -text | grep 'app.traderres.com'        # Holds the server cert
		   unix> openssl x509 -in fullchain_part2.pem -noout -text | grep 'app.traderres.com'
		   unix> openssl x509 -in fullchain_part3.pem -noout -text | grep 'app.traderres.com'

        3) Generate the server.p12 file from the server cert
           unix> export SERVER_CRT=fullchain_part1.pem
		   unix> export SERVER_KEY=privkey1.pem
		   unix> export INTERMEDIATE_CA=fullchain_part2.pem
           unix> openssl pkcs12 -export -in $SERVER_CRT -inkey $SERVER_KEY -out server.p12 -name 'my-server-cert' -CAfile $INTERMEDIATE_CA -caname root
           Enter Export Password: changeit
           Verify Password:       changeit

        4) Convert the server.p12 into webapp.keystore.jks
           unix> rm -f webapp.keystore.jks
           unix> keytool -importkeystore -deststorepass changeit -destkeypass changeit -destkeystore webapp.keystore.jks  -srckeystore server.p12 -srcstoretype PKCS12 -srcstorepass changeit -alias 'my-server-cert'




    b. Generate this file:  webapp.truststore.jks
       1) Break-up the app.traderres.com/fullchain1.pem file into 3 files:
               fullchain_part1.pem
               fullchain_part2.pem
               fullchain_part3.pem

       2) Import each file into the new webapp.truststore.jks file
          unix> cd /home/adam/certbot/archive/app.traderres.com
          unix> rm -f webapp.truststore.jks
          unix> keytool -import -alias "new-lb1"  -keystore webapp.truststore.jks -file fullchain_part1.pem  -storepass changeit
          unix> keytool -import -alias "new-lb2"  -keystore webapp.truststore.jks -file fullchain_part2.pem  -storepass changeit
          unix> keytool -import -alias "new-lb3"  -keystore webapp.truststore.jks -file fullchain_part3.pem  -storepass changeit

          # Import the self-signed root CA pem file into webapp.truststore.jks
          unix> keytool -import -alias "our-ca"  -keystore webapp.truststore.jks -file /path/to/own-self-signed/root-ca/pem  -storepass changeit


    c. Generate this file:  custom.cacerts
       NOTE:  This is needed so that the spring security oauth2 authenticator can talk to the keycloak server
       unix> cp /usr/lib/jvm/java-1.8.0-openjdk/jre/lib/security/cacerts custom.cacerts
       unix> chmod ugo+rw custom.cacerts

       unix> keytool -import -alias "new-lb1"  -keystore  custom.cacerts  -file fullchain_part1.pem  -storepass changeit
       unix> keytool -import -alias "new-lb2"  -keystore  custom.cacerts  -file fullchain_part2.pem  -storepass changeit
       unix> keytool -import -alias "new-lb3"  -keystore  custom.cacerts  -file fullchain_part3.pem  -storepass changeit
       unix> keytool -import -alias "our-ca"   -keystore  custom.cacerts  -file /path/to/own-self-signed/root-ca/pem   -storepass changeit


21. Build and Push the webapp to Amazon ECR
    NOTE:  Normally, your kubernetes pod would refer to a volume and read the files from there
           But, we are going to embed the custom.cacerts, webapp.keystore.jks, and webapp.truststore.jks in the webapp (for now)

    a. Get the client id secret key
       1) Go to  https://keycloak.traderres.com:8444/
       2) Click on Admin Console
       3) Enter the admin user/password
       4) Click on Realms -> MyRealm
       5) Click on Clients
       6) Click on sf328-webapp
       7) Click on the "Credentials" tab
          -- Get the client secret

    a. Build the webapp with some certificates embedded (for now)
       Copy the custom.cacerts, webapp.keystore.jks, webapp.truststore.jks to the sf328/sf328-backend/src/main/prod_resources/ directory

    b. Make sure the production application.yaml has these setting:

			##########################################################
			# SSL Settings
			##########################################################
			server:
			  port: 8443
			  ssl:
				key-store: sf328-backend/src/main/prod_resources/webapp.keystore.jks
				key-store-password: changeit
				key-store-type: JKS
				client-auth: need
				trust-store: sf328-backend/src/main/prod_resources/webapp.truststore.jks
				trust-store-password: changeit
				trust-store-type: JKS
				enabled: true

    c. Make sure the production application.yaml has
            server.servlet.context-path: /sf


    d. Make sure the production application.yaml has these keycloak settings:

			##########################################################
			# Keycloak Settings for Spring Security
			##########################################################
			spring.security.oauth2.client.registration.keycloak.client-id: sf328-webapp
			spring.security.oauth2.client.registration.keycloak.client-secret: <CLIENT_SECRET_FROM_KEYCLOAK_SERVER>
			spring.security.oauth2.client.registration.keycloak.authorization-grant-type: authorization_code
			spring.security.oauth2.client.registration.keycloak.scope: openid,email,profile
			spring.security.oauth2.client.provider.keycloak.issuer-uri: https://keycloak.traderres.com:8444/realms/MyRealm
			spring.security.oauth2.client.provider.keycloak.user-name-attribute: preferred_username
			spring.security.oauth2.resourceserver.jwt.issuer-uri: https://keycloak.traderres.com:8444/realms/MyRealm


    e. Get the procedures to push up the build up to the Amazon ECR
       1) Connect to aws.com as dev.user
       2) Go to the ECR
       3) Check the "traderres" repository
       4) Press "View push commands"

          The REPOSITORY_URL is 524647912468.dkr.ecr.us-east-2.amazonaws.com/traderres


    f. Get the AWS ECR authentication token  (so docker push will push it up to our Amazon ECR)
       Retrieve the authentication token  (from the "view push commands" step)
       unix> aws ecr get-login-password --region us-east-2 | docker login --username AWS --password-stdin 524647912468.dkr.ecr.us-east-2.amazonaws.com



    g. Build & Push the tag
       1) Edit the sf328-backend/pom.xml

          Change the <to><image> to this:

			  <to>
				   <image>REPOSITORY_URL:${project.artifactId}-${project.version}</image>
			  </to>

          So, it should appear as this:
              <to>
                <image>524647912468.dkr.ecr.us-east-2.amazonaws.com/traderres:${project.artifactId}-${project.version}</image>
              </to>


          When finished, your "buildImage" maven profile should look something like this:

				<profile>
					 <!--    B U I L D    I M A G E       P R O F I L E    -->
					 <id>buildImage</id>

					 <build>
						 <plugins>
							 <plugin>
								 <groupId>com.google.cloud.tools</groupId>
								 <artifactId>jib-maven-plugin</artifactId>
								 <version>3.3.1</version>
								 <configuration>
									 <from>
										 <!-- The source image runs linux with JDK 1.8-362 -->
										 <image>eclipse-temurin:8u362-b09-jdk@sha256:3b83f3fc0d016d7536dfd5e8a98ece451061b7dbb6d5db3ddea2db30b6153b28</image>
									 </from>

									 <to>
										 <image>527362555097.dkr.ecr.us-gov-west-1.amazonaws.com/frms:${project.artifactId}-${project.version}</image>
									 </to>

									 <extraDirectories>
										 <paths>
											 <path>
												 <!-- Copies from 'src/main/prod_resources' into '/sf328-backend/src/main/prod_resources' on the container. -->
												 <from>src/main/prod_resources</from>
												 <into>/backend/src/main/prod_resources</into>
											 </path>
										 </paths>
									 </extraDirectories>

									 <container>
										 <jvmFlags>
											 <jvmFlag> -Dspring.config.location=/backend/src/main/prod_resources/application.yaml</jvmFlag>
										 </jvmFlags>
									 </container>

								 </configuration>

								 <executions>
									 <execution>
										 <phase>package</phase>
										 <goals>
											 <!-- The "dockerBuild" goal requires docker to be installed -->
											 <goal>dockerBuild</goal>
										 </goals>
									 </execution>
								 </executions>

							 </plugin>
						 </plugins>
					 </build>
				 </profile>



				 <profile>
					 <!--    B U I L D      I M A G E      W I T H O U T    D O C K E R     P R O F I L E    -->
					 <id>buildImageWithoutDocker</id>

					 <build>
						 <plugins>
							 <plugin>
								 <groupId>com.google.cloud.tools</groupId>
								 <artifactId>jib-maven-plugin</artifactId>
								 <version>3.3.1</version>
								 <configuration>
									 <from>
										 <!-- The source image runs linux with JDK 1.8-362 -->
										 <image>eclipse-temurin:8u362-b09-jdk@sha256:3b83f3fc0d016d7536dfd5e8a98ece451061b7dbb6d5db3ddea2db30b6153b28</image>
									 </from>

									 <to>
										 <image>traderres/my-public-repo:${project.artifactId}-${project.version}</image>
									 </to>

									 <extraDirectories>
										 <paths>
											 <path>
												 <!-- Copies from 'src/main/prod_resources' into '/sf328-backend/src/main/prod_resources' on the container. -->
												 <from>src/main/prod_resources</from>
												 <into>/backend/src/main/prod_resources</into>
											 </path>
										 </paths>
									 </extraDirectories>

									 <container>
										 <jvmFlags>
											 <jvmFlag> -Dspring.config.location=/backend/src/main/prod_resources/application.yaml</jvmFlag>
										 </jvmFlags>
									 </container>
								 </configuration>

								 <executions>
									 <execution>
										 <phase>package</phase>
										 <goals>
											 <!-- The "build" goal does not require docker to be installed -->
											 <goal>build</goal>
										 </goals>
									 </execution>
								 </executions>

							 </plugin>
						 </plugins>
					 </build>
				 </profile>

       2) Set the version to be 2.0.1-SNAPSHOT
          unix> mvn versions:set -DnewVersion=2.0.1-SNAPSHOT  -DgenerateBackupPoms=false

       3) Build the image
          unix> mvn clean package -Pprod -PbuildImage

       4) Push the image to our Amazon ECR
          unix> docker push 524647912468.dkr.ecr.us-east-2.amazonaws.com/traderres:sf328-backend-2.0.1-SNAPSHOT


22. Use Kubernetes to deploy the webapp
    a. Set my kubectl configuration (so running kubectl connects to the AWS cluster)
       unix> aws eks update-kubeconfig --region us-east-1 --name sf

    a. Delete existing deployment
       unix> kubectl delete deployment sf328-deployment

    b. Create the deployment script by adding the "env" section with Java settings
       unix> vi sf328-deployment-v1.yaml

#############################################################################
#  sf328-deployment-v1.yaml
#
# Notes:
#  1) The running pods do not have DNS so we need hostAliases to create an entry in /etc/hosts
#     that can resolve the keycloak.traderres.com to 18.218.246.201
#     Use nslookup keycloak.traderres.com to verify the IP
#
#############################################################################
apiVersion: apps/v1
kind: Deployment
metadata:
  name: sf328-deployment

spec:
  selector:
    matchLabels:
      app: sf328-backend
  replicas: 1
  strategy:
    type:  Recreate
  template:
    metadata:
      name: kubia
      labels:
         app: sf328-backend
    spec:
      hostAliases:
      - ip: "18.218.246.201"
        hostnames:
          - "keycloak.traderres.com"
      containers:
      - image: 524647912468.dkr.ecr.us-east-2.amazonaws.com/traderres:sf328-backend-2.0.1-SNAPSHOT
        imagePullPolicy: Always
        name: java-backend
        env:
          - name: JAVA_TOOL_OPTIONS
            value: -Xms250m -Xmx250m -Djavax.net.debug=ssl -Djavax.net.ssl.trustStore=/sf328-backend/src/main/prod_resources/custom.cacerts -Djavax.net.ssl.trustStorePassword=changeit




	 c. Verify that there are no special chars in the file by looking for them
		unix> cat -v -e sf328-deployment-v1.yaml

	 d. We create the deployment
		unix> kubectl create -f sf328-deployment-v1.yaml

	 e. Get a listing of the pods
		unix> kubectl get pods

		NAME                               READY   STATUS    RESTARTS   AGE
		sf328-deployment-c469974cb-tj4kk   1/1     Running   0          10s


	 f. Delete the existing load balancer service  (that was temporary)
		unix> kubectl delete service sf328-loadbalancer

	 g. Have AWS create and expose the load balancer service
		unix> kubectl expose deployment sf328-deployment --type=LoadBalancer --name=sf328-loadbalancer --port=443
		NOTE:  This create a new external hostname and IP address


	 h. Modify the created load balancer service by setting
		unix> kubectl edit service sf328-loadbalancer

		   targetPort=8443
		   sessionAffinity=ClientIP


	 i. Get the external hostname for this load balancer service
		unix> kubectl get services

		NAME                 TYPE           CLUSTER-IP     EXTERNAL-IP                                                               PORT(S)         AGE
		kubernetes           ClusterIP      10.100.0.1     <none>                                                                    443/TCP         27h
		sf328-loadbalancer   LoadBalancer   10.100.66.32   a913ec0732a4d4726a6d186c8233e52f-1165139498.us-east-2.elb.amazonaws.com   443:30493/TCP   5s



	 j. Update godaddy's cname record for app.traderres.com so that it corresponds to the new external hostname
		a. Login to godaddy.com
		b. Go to "Manage DNS" for traderres.com
		   *OR*
		   https://dcc.godaddy.com/control/traderres.com/dns

		c. Edit the old CNAME record for app.traderres.com
		   Type:  CNAME
		   Name:  app
		   Value: a913ec0732a4d4726a6d186c8233e52f-1165139498.us-east-2.elb.amazonaws.com

		d. Press "Save"



	 k. Restart the keycloak server
		ssh to the running instance
		unix> ssh -i ~/.ssh/node-for-kubunetes-instance.pem ec2-user@18.218.246.201
		unix> sudo systemctl restart keycloak




23. Verify it works
    a. Create a pki client cert
    b. Import it into a browser
    c. Attempt to connect to https://app.traderres.som/sf




Troubleshooting
---------------
 A. Ssh to the running pod
    unix> kubectl get pods

    unix> kubectl exec -it sf328-deployment-5c944dc79f-sb8lc /bin/bash
    unix> curl https://keycloak.traderres.com:8444/realms/MyRealm
    -- Verify that you get info cleanly (without error)




How to Shutdown the entire AWS cluster (so you're not being billed for anything)
--------------------------------------------------------------------------------
 1. Go into ECR, and delete the repository images

 2. Delete the node group
    Go into EKS -> Clusters -> sf -> Compute
    Highlight the node group -> Delete

 3. Delete the OpenSearch domain
    Go into OpenSearch -> Click on sf328 domain ->

 4. Delete Postgres RDS
    Go into RDS -> Database
    Select the keycloak -> Action -> Delete
    Uncheck "Create final snapshot"
    Delete

    Go into RDS -> Database
    Select the sf328 -> Action -> Delete
    Uncheck "Create final snapshot"
    Delete

 5. Delete the EKS Cluster (lsat)
    Go into EKS -> Clusters -> sf -> delete

 6. Delete the EC2 Load balancer
    Go into EC2 -> Load balancers -> Action -> Delete









When deploying on AWS, remember that you need 2 signed server-certs
 1) Server Cert #1 will be used by keycloak
    Create it with subject alternative name = hostname, external IP, and internal IP
    NOTE:  Make sure the hostname is *FIRST* in the subect alternative name

 2) Server Cert #2 will be used by the sprint boot web app
    Create it with subject alternative name = external hostname, external IP
    NOTE:  Make sure the hostname is *FIRST* in the subect alternative name