How to Setup Java Spring Boot Web App to use PKI Credentials against Keycloak server running in AWS
---------------------------------------------------------------------------------------------------


General Approach
 1. User uses a browser to hit Java Web App
    -- User presents PKI certificate to Java Web App

 2. Spring Security redirects user to the Keycloak server
    -- User presents PKI certificate to keycloak

 3. User is presented a keycloak login page  (or it can be bypassed)
    -- User presses "Submit" button on keycloak login page
    -- User is redirected to the Java Web App with keycloak credentials
       *OR*
    -- If bypass setting is enabled, user goes directly to Java Web App with keycloak credentials

 4. Spring Security detects that authentication is successful
    -- Java code gets the user's roles and any additoinal info and adds MyUserInfo to the principal object

    NOTE:  Redirecting the user to the keycloak server is the most secure way of implementing security (according to the Keycloak folks)



ASSUMPTIONS:
 A) You have an AWS account
 B) You have installed the AWS CLI tool
 C) You have a registered domain called "traderres.com"


Goal: Deploy this webapp so anyone can get to it using https://www.traderres.com/sf


Setup local kubectl that is *NOT* part of minikube
---------------------------------------------------
 1. Remove the existing mini kube setup
    unix> mv ~/.kube ~/.kube-localhost

 2. Comment out this alias
    unix> vi ~/.bashrc
    ##   alias kubectl="minikube kubectl --"

 3. Download & install kubectl
    unix> cd /tmp
    unix> curl -LO https://dl.k8s.io/release/v1.26.0/bin/linux/amd64/kubectl
    unix> sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl

    unix> which kubectl
    /usr/local/bin/kubectl

 4. Set my config
    unix> aws eks update-kubeconfig --region us-east-1 --name sf

    You should see this:
        Added new context arn:aws:eks:us-east-1:524647912468:cluster/sf to /home/adam/.kube/config

 5. Login to the server

    -- Now, your kubectl is setup to your cluster



General Approach
----------------
 1. Setup AWS Account / Create Users / Grant CLI Access  (so we can push up builds to our AWS ECR Registry)
 2. Setup AWS CNI Policy / so dev.user can make changes to kubernetes
 3. Setup AWS ECR Registry (as dev.user)   which will hold our builds to be deployed)
 4. Configure the Amazon VPC (created by default for the dev.user)
 5. Create the EKS Cluster (as dev.user)
 6. Finish configuring CNI Policy
 7. Create the keypair and inbound rule
 8. Create Kubernetes Node Group
 9. SSH to the node instance to update the yum packages of the running instance
10. Initialize AWS-hosted resources (exist outside of the kubernetes cluster)
    NOTE:  postgres and OpenSearch do not run inside kubernetes
    a. Setup 2 RDS / postgres instances (one for the webapp and one for keycloak)
    b. Setup OpenSearch
11. Create our own certificate authority (for pki client certs)
12. Configure your local kubectl command to talk to our new Kubernetes cluster
13. Get the aws external hostnames for keycloak and the app's loadbalancer
14. Register the godayy domain name that correspond to the external AWS keycloak and external AWS load balancer names
15. Create server certs with Let's Encrypt for the load-balancer (app.traderres.com) and keycloak (keycloak.traderres.com)
16. Create & install the keycloak certificates on the running instance
17. Initialize Keycloak as a service on the running instsance
18. Configure keycloak
19. Configure certificates for the load-balancer (external hostname used to access the webapp)
20. Build and Push the webapp to Amazon ECR
21. Use Kubernetes to deploy the webapp
22. Verify it works



Procedure
---------
 1. Setup AWS Account / Create Users / Grant CLI Access  (so we can push up builds to our AWS ECR Registry)
    Goal:  Setup a user that can run the CLI to push-up builds
    a. Go to https://aws.com/

    b. Create the "administrators" group
       1) In AWS, go to Services -> IAM
       2) On the left, click on User groups
       3) Press "Create cgroup"
          User group name:  administrators

       4) In the "Attach permissions policies"
          Add these role:
            AdministratorAccess


    b. Create the dev.user
       1) In AWS, go to Services -> IAM
       2) On the left, click on Users
       3) Press "Add Users"
       4) In "User details"
          User name:  dev.user
          Check "Provide user access to the AWS Management Console"
          Check "I want to create an IAM user"


          Consoel password
             custom password:  enter it
             Uncheck "User must create a new password at next sign-in)

          Press "Next"

       5) In "Set permissions"
          Select "Attach policies directly"
          Search for CNI
          Check Off theses roles:  AmazonEKS_CNI_Policy
          Press "Next"

       6) Press "Create user"
          NOTE:  Grab the console sign-in link:   https://524647912468.signin.aws.amazon.com/console

       7) Add this user to the "administrators group"
          Return the user lists
          Click on the "dev.user" link
          Click on "Groups"
          Press "Add user to groups"
          Check "administrators"
          Press "Add user to group(s)"


       8) Create access keys for the dev.user
          1) Click on "Users"
          2) Click on dev.user
          3) Click on "Security Credentials"
          4) Click on "Create access key"
          5) Select Command Line interface
             Select "I understand the above"
             Press "Next"

          6) Description tag value:  leave it blank
             Press "Create access key"

          7) Download the key by pressing "Download .csv file"
            --> Save dev.user_accessKeys.csv to your ~/Downloads

           -- Now, the user called "dev.user" should have the authority to push up to the AWS ECR Registry


    c. Logout as root user


 2. Setup AWS CNI Policy (as the dev.user)
    a. Login as dev.user
       https://524647912468.signin.aws.amazon.com/console

    b. Verify that you have a VPC (created for you)
       Select your VPC, Press Action -> Edit VPC Settings
       -- Verify that "Enable DNS resolution" is checked
       -- Verify that "Enable DNS hostnames"  is checked
       -- Verify that you have subnets already created for you
       -- Verify that you have an Internet gateway created for you

    c. Create this role: eksClusterRole
       1) Go to AWS IAM page
       2) Click on Roles
       3) Press "Create Role"
       4) In Select trusted entity, choose "AWS service"
          In Use Cases for other AWS services, select EKS
          Select EKS - Cluster
          Press "Next"

       5) In "Add permissions", go with defaults and press "Next"

       6) In Name, review, and create
          Role name:  eksClusterRole
          Press "Create Role"

       7) In Roles, Check on eksClusterRole
          Select "Add permissions" -> Attach Policies
          Search for AmazonEKS and press Enter
          Check AmazonEKS_CNI_Policy
          Press "Add Permission"

       9) In the "Roles/ eksClusterRole page, select Trust relationships
          Verify that you see this:
			  {
				  "Version": "2012-10-17",
				  "Statement": [
					  {
						  "Effect": "Allow",
						  "Principal": {
							  "Service": "eks.amazonaws.com"
						  },
						  "Action": "sts:AssumeRole"
					  }
				  ]
			  }

    b. Create this role:  eksNodeRole
       1) Go to AWS IAM page
       2) Click on Roles
       3) Press "Create Role"
       4) In Select trusted entity, choose "AWS service"
          In Use Cases for other AWS services, select EKS
          Select EKS - Cluster
          Press "Next"
       5) In "Add permissions", go with defaults and press "Next"
       6) In Name, review, and create
          Role name:  eksNodeRole
          Press "Create Role"

       7) In Roles, Click on eksNodeRole
       8) Select "Add permissions" -> Attach Policies
          Search for AmazonEKS and press Enter
          Check AmazonEKS_CNI_Policy
          Check AmazonEKSWorkerNodePolicy
          Press "Add Permission"

       9) In the Roles / eksNodeRole, remove the AmazonEKSClusterPolicy
          -- In Permissions policies, check AmazonEKSClusterPolicy
          -- Press "Remove"

      10) In the Roles / eksNodeRole, remove the AmazonEKSClusterPolicy
          -- In Permissions policies, select Add permissions -> Attach policies
          -- Search for AmazonEC2containers
          -- Check AmazonEC2ContainerRegistryReadOnly
          -- Press "Add permissions"

          At this point eksNodeRole, should have 3 policies:
          		AmazonEKSWorkerNodePolicy
           		AmazonEC2ContainerRegistryReadOnly
           		AmazonEKS_CNI_Policy,

     11) Click on "Trust relationships" (all of the worker nodes are running on ec2 hosted servers / this granting rights to the ec2 hosted instsances)
         Press "Edit trust policy"

         Find this line:
           "Service": "eks.amazonaws.com"

         Raplce with this line:
           "Service": "ec2.amazonaws.com"

         Press "Update policy"



    c. Create this role:  AmazonEKS_VPC_CNI_Role
       1) Go to AWS IAM page
       2) Click on Roles
       3) Press "Create Role"
       4) In Select trusted entity, choose "AWS service"
          In Use Cases for other AWS services, select EKS
          Select EKS - Cluster
          Press "Next"
       5) In "Add permissions", go with defaults and press "Next"
       6) In Name, review, and create
          Role name:  AmazonEKS_VPC_CNI_Role
          Press "Create Role"

       7) In Roles, Click on AmazonEKS_VPC_CNI_Role
       8) Select "Add permissions" -> Attach Policies
          Search for cni and press Enter
          Check AmazonEKS_CNI_Policy
          Press "Add Permission"
       9) In Permissions policies, remove AmazonEKSClusterPolicy policy
          -- Check AmazonEKSClusterPolicy and press "Remove"


 3. Setup AWS ECR Registry (as dev.user)   which will hold our builds to be deployed)
    a. Connect to AWS as dev.user and go to your console
    b. Search Services for ECR -> Select Elastic Container Registry
    c. Press "Get Started"
    d. In "Create repository"
       Visibility settings:  Private
       Repository name:      traderres
       In DOD:               Turn on KMS encryption
       Press "Create repository"

    e. Copy the URI:  524647912468.dkr.ecr.us-east-2.amazonaws.com/traderres

    f. Check your repository and press "View push commands"
       -- This has the procedures for using the AWS CLI to connect


 4. Configure the Amazon VPC (created by default for the dev.user)
    NOTE:  Default settings should be fine
    NOTE:  We can change the subnets are this point



 5. Create the EKS Cluster (as dev.user)
    a. Login as the dev.user

    b. Search Services for EKS -> Select Elastic Kubernetes Service  (as dev.user)

    c. Select "Add Cluster" -> Create

    d. In "Configure Cluster"
       Name:                  sf
       Kubernetes version:    1.25  (or the latest)
       Cluster service role:  eksClusterRole
       Press "Next"

       Configure Kubernetes service IP address range:  Unchecked


    e. In Networking
       VPC:                               Choose default vpc
       Subnets:                           auto-selected both subnets for you
       Security groups:                   Choose the defualt security group
       Choose cluster IP address family:  IPv4
       Cluster endpoint access:           Public
       Press "Next"

    f. In Configure Logging
       Leave it all off for now
       Press "Next"

    g. In "Select add-ons"
       Press "Next"

    h. In "Configure selected add-ons settings"
       Go with default and press "Next"

    i. In "Review and Create"
       Press "Create"

       W A I T    U P    T O    1 0     M I N      (for AWS to create it)

       -- Right now, we have a cluster with no nodes


 6. Finish configuring CNI Policy
    a. Get the OpenID Connect provider URL
       1) Configure your AWS CLI to talk to your new cluster
           unix> aws configure

	       	AWS Access Key ID:     <enter the first entry form the downloaded csv file>
    	   	AWS Secret Access Key: <enter the 2nd entry from the downloaded csv file>
       		Default region name:   us-east-2    (you get this from the AWS console, look next to your name and look at the default region)
       		Default output format  json

       2) Get the cluster info:
          unix> aws eks describe-cluster --name sf --query "cluster.identity.oidc.issuer" --output text
          https://oidc.eks.us-east-1.amazonaws.com/id/ID_FROM_DESCRIBE_CLUSTER




    b. Grant anyone in our account to EKS/VPC/CNI
       1) Click on Roles
       2) Click on AmazonEKS_VPC_CNI_Role
       3) Click on "Trust relationships"
       4) Edit trust policy

          Replace the trust policy with this  (no tabs):
          Replace ID_FROM_DESCRIBE_CLUSTER with the value from the step above
          REPLACE us-east-2 with us-east-2 (if needed)

{
    "Version": "2012-10-17",
    "Statement": [
    {
        "Effect": "Allow",
        "Principal": {
              "Federated": "arn:aws:iam::524647912468:oidc-provider/oidc.eks.us-east-1.amazonaws.com/id/ID_FROM_DESCRIBE_CLUSTER"
         },
         "Action": "sts:AssumeRoleWithWebIdentity",
         "Condition": {
         "StringEquals": {
              "oidc.eks.us-east-1.amazonaws.com/id/ID_FROM_DESCRIBE_CLUSTER:aud": "sts.amazonaws.com",
              "oidc.eks.us-east-1.amazonaws.com/id/ID_FROM_DESCRIBE_CLUSTER:sub": "system:serviceaccount:kube-system:aws-node"
              }
            }
        }
   ]
}

     8) Press "Update policy"





 7. Create the keypair and inbound rule
    a. Go to EC2
    b. Look for Network & Security -> Key Pairs
    c. Press "Create key pair"
       Name:   node-for-kubunetes-instance
       Type:   RSA
       Format: PEM
       Press "Create key pair"
              -- You will be prompted to download the node-for-kubernetes-instance.pem

     b. Add an inbound rule for this node so that you can ssh from anywhere
        1) Go to EC2
        2) Click on Resoures -> Security groups
        3) Check the default security group and press Action -> Edit Inbound Rules
        4) Press "Add Rule"
           Type:   SSH
           Source: Anywhere-IPv4
           Press "Save rule"

     c. Add another inbound rule for our default security group  (to let all traffic in and out)
           1) Go to EC2 Dashboard
           2) Click on Resoures -> Security groups
           3) Check the default security group and press Action -> Edit Inbound Rules
           4) Press "Add Rule"
              Type:   All Traffic
              Source: Anywhere-IPv4
                      0.0.0.0/0
              Press "Save rule"


 8. Create Kubernetes Node Group  (as dev.user)
	a. Go to Amazon Elastic Kuberentes Services
	b. Click on your cluster (sf)
	c. Click on "Compute"
	d. Press "Add node group"
	e. In "Configure node group"
		   Name:           sf-node-group
		   Node IAM Role:  eksNodeRole
		   Press "Next"

	f. In "Node group compute configuration"
	   AMI Type:       Amazon Linux 2 (AL2_x86_64)
	   Capacity Type:  On-Demand                        (in DOD, we would have reserved instances)
	   Instance types  t3.large only
	   Disk size:      20 GiB

	   In Node group scaling configuration
		 Desired Size:   1 nodes
		 Minimum size:   1 nodes
		 Maximum size:   1 nodes         (so the whole kubernetes env is run on a SINGLE server)

	   In Node group update configuration   (this is the part of the auto-scaling features built into EKS)
	   -- Go with defaults

	   Pres "Next"


	g. In "Specify Networking"
		1) Select the both subnets
		2) Select "Configure ssh access for nodes"
		   -- In the warning, press "Enable"
           -- Subnets:                       Select both
		   -- SSH Key pair:                  Select node-for-kubernetes-instance
		   -- Allow SSH rmeote access from:  Selected security groups
		   For security groups:              Select default security group

		Press "Next"

	h. In "Review and Create"
		Press "Create"

		NOTE:  At this point, I'm being charged for the t3.large (which costs $2/day)

	i. W A I T      U P    T O       1 0      M I N       F O R     A W S    (to create the node group)

	j. While waiting, get the public IP of your instance
	   a. Go to the EC2 Dashboard
	   b. Check the checkbox on your newly-created instance
	   c. Look at the bottom details
		  -- You should see your public IP address

    k. Add the default security group to our running instance
       a. Go to EC2 -> Instances
       b. Check the checkbox next to our running instance
       c. Selection Actions -> Security -> Change security groups
       d. In "Associated security groups"
          Search for default
          Add it to the list
          press "Save"


 9. SSH to the node instance to update the yum packages of the running instance
    a. Get the public hostname or IP
       1) Go to EC2 -> Instances -> Check our running instance
       2) Get the public IPv4 address or Public IPv4 DNS hostname from the details

    b. Attmept to ssh to it
       1) Copy your node-for-kubunetes-instance.pem to your ~/.ssh directory
          unix> cp ~/Downloads/node-for-kubunetes-instance.pem  ~/.ssh

       2) Adjust the permissions so only you can read it:
          unix> chmod go-rwx ~/.ssh/node-for-kubunetes-instance.pem

       3) Attempt to ssh
          unix> ssh -i ~/.ssh/node-for-kubunetes-instance.pem ec2-user@18.218.246.201

       4) Once connected, then do a yum update
          unix> sudo yum update

          NOTE:  If there is a linux kernel update, then you should reboot the instance
                 with sudo reboot


10. Initialize AWS-hosted resources (exist outside of the kubernetes cluster)   (as dev.user)
    NOTE:  postgres and OpenSearch do not run inside kubernetes
    a. Create the keycloak database
       1) In AWS, search for RDS / Select RDS   (as dev.user)
       2) Select Databases -> Press "Create database"
       3) In "Create database"
          Database creation method:  standard create
          Engine type:               PostgreSQL
          Engine version:            PostreSQL 14.6-R1
          Templates:                 Dev/Test
          Availability:              Single DB Instance

          Settings
             DB Instance identifier     keycloak          NOTE:  This is not the same as the database name
             Master usrename:           keycloak_user
             Master password            secret123

          Instance configuration
             DB Instance class:             Burstable / db.t3.micro
             Include previous gen classes:  Unchecked

          Storage
             Storage Type:                General Purpose SSD (gp2)
             Allocated storage:           20 GB
             Enable storage autoscaling:  Unchecked

		  Connectivity:
		     Compute resource:               Connect to an EC2 compute resource
             EC2 instance;                   <Select the instance that should be found in EC2 -> Instances -> You should see your 1 instance running>
             DB Subnet Group:                Automatic Setup
             Public Acces:                   No   (you can only access this database from sindie the cluster)
             VPC Security group (firewall):  Choose Existing
             Additional VPC security group:  Empty

                                             NOTE:  If I want to make the database open to all, set the VPC security group to include "Default"

          Additional Configuration:
             Database Port:                   5432
             Initial database name:           sf328_db

          Database authentication:           Password authentication

          Monitoring:
            Uncheck "Turn on Performance Insights"
            Uncheck "Enable enhanced monitoring"

          Additional Configuration
            Uncheck "Enable automated backups"
            Check   "Enable encryption"

          Maintenance
            Uncheck "Enable auto minor version upgrade"

          Press "Create database"


    b. Create the app database
       1) In AWS, search for RDS / Select RDS   (as dev.user)
       2) Select Databases -> Press "Create database"
       3) In "Create database"
          Database creation method:  standard create
          Engine type:               PostgreSQL
          Engine version:            PostreSQL 14.6-R1
          Templates:                 Dev/Test
          Availability:              Single DB Instance

          Settings
             DB Instance identifier     sf328
             Master usrename:           sf328_user
             Master password            secret12

          Instance configuration
             DB Instance class:              Burstable / db.t3.micro
             Include previous gen classes:   Unchecked

          Storage
             Storage Type:                   General Purpose SSD (gp2)
             Allocated storage:              20 GB
             Enable storage autoscaling:     Unchecked


		  Connectivity:
		     Compute resource:               Connect to an EC2 compute resource
             EC2 instance;                   <Select the instance that should be found in EC2 -> Instances -> You should see your 1 instance running>
             DB Subnet Group:                Automatic Setup
             Public Acces:                   No   (you can only access this database from sindie the cluster)
             VPC Security group (firewall):  Choose Existing
             Additional VPC security group:  Empty
                                             NOTE:  Choose "Default" security group as it is wide open


          Additional Configuration:
             Database Port:                   5432
             Initial database name:           sf328_db

          Database authentication:           Password authentication

          Monitoring:
            Uncheck "Turn on Performance Insights"
            Uncheck "Enable enhanced monitoring"

          Additional Configuration
            Uncheck "Enable automated backups"
            Check   "Enable encryption"

          Maintenance
            Uncheck "Enable auto minor version upgrade"

          Press "Create database"



    c. Setup OpenSearch
       1) In AWS -> Amazon OpenSearch Service   (as dev.user)
       2) Press "Create domain"
          In "Create domain"
             Domain Name:               sf328
             Enable custom endpoint:    Unchecked
             Deployment type:           Development and testing
             Version:                   7.10

             Availability Zone:         1-AZ
             Instance Type:             t3.small.search

             Number of nodes:           2

             Storage Type:              EBS   (Elastic Block Store)
             EBS Volumne Type:          gp3         NOTE:  gp3 is faster than gp2
             EBS Storage size per node   10

             Total Privisions IPOS:        <default of 3000>
             Total Provisioned Throughput  <default of 125 MiB/s>

             Enable Dedicated master nodes:       Unchecked

             Enable automatic software update:    Unchecked

             Network
                Check "Public access"

             Fine-grained access control:       Checked
             Create master user:                Checked
                 master username:               sf328_user             # This must match the production application.yaml es.authentication.principal
                 master password:               Secret1@               # This must match the production application.yaml es.authentication.password

             Access Policy:
                Do not set domain level access policy

             Press "Create"

             W A I T        U P         T O        1 0     M I N U T E S    (for AWS to create the OpenSearch domain)




11. Create our own certificate authority (for pki client certs)
    a. Create certificate authority:
       learnSSL / howToUseYourCertAuthority_InitialSetup_centos7.txt

    b. Create PKI Client cert with john.smith.12345
       learnSSL / howToUseYourCertAuthority_MakeClientCert_centos7.txt
       NOTE:  Make the Common Name:  JOHN.SMITH.12345

    c. Create PKI client cert with WILL.FRANKLIN.22222
       learnSSL / howToUseYourCertAuthority_MakeClientCert_centos7.txt
       NOTE:  Make the Common Name:  WILL.FRANKLIN.22222


12. Configure your local kubectl command to talk to our new Kubernetes cluster
    NOTE:  Kubernetes is running but there are no pods running at this time
    a. Download the kubectl command

    b. Erase or move the existing .kube
       unix> rm -rf ~/.kube

    c. Setup kubectl to be configured with your AWS cluster
       unix> aws eks update-kubeconfig --region <REGION_CODE> --name <MY CLUSTER NAME>
       *OR*
       unix> aws eks update-kubeconfig --region us-east-2  --name sf

    d. Verify that you can see the running nodes
       unix> kubectl get nodes

       NAME                                          STATUS   ROLES    AGE     VERSION
       ip-172-31-42-143.us-east-2.compute.internal   Ready    <none>   4h16m   v1.25.6-eks-48e63af


    e. List existing services
       unix> kubectl get services

       NAME         TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE
       kubernetes   ClusterIP   10.100.0.1   <none>        443/TCP   4h37m



13. Get the aws external hostnames for keycloak and the app's loadbalancer
    Keycloak will run locally in your running node
    Keycloak's public IP will be the same as the running node's public IP
    a. Get keycloak's external hostname
       1) Go to AWS -> EC2 -> instances
       2) Check the checkbox for the running instance
       3) Get the Public IPv4 DNS
          ec2-18-218-246-201.us-east-2.compute.amazonaws.com

    b. Create a kubernetes load balancer service file
       unix> vi /tmp/load-balancer-service.yaml

apiVersion: v1
kind: Service
metadata:
  name: sf328-load-balancer-service
spec:
  selector:
    app: example
  ports:
    - port: 443
      targetPort: 8443
  type: LoadBalancer


    c. Create the externa load-balancer service  (should generate an external IP and hostname)
  	   unix> kubectl create -f /tmp/load-balancer-service.yaml

	d. Get the external load-balancer's hostname
	   unix> kubectl get services

	   NAME                          TYPE           CLUSTER-IP     EXTERNAL-IP                                                              PORT(S)         AGE
       kubernetes                    ClusterIP      10.100.0.1     <none>                                                                   443/TCP         4h47m
       sf328-load-balancer-service   LoadBalancer   10.100.98.77   ae512df1bdc3646ac961142b36441bc8-225527351.us-east-2.elb.amazonaws.com   443:30896/TCP   2m

       The app's external hostname will be this:  ae512df1bdc3646ac961142b36441bc8-225527351.us-east-2.elb.amazonaws.com




14. Register the godayy domain name that correspond to the external AWS keycloak and external AWS load balancer names
    a. Use godaddy to register ec2-18-218-246-201.us-east-2.compute.amazonaws.com with a CNAME of keycloak.traderres.com
       1) Login to godaddy.com
       2) Go to My Account -> My Products
       3) Click on the "Domain" link for traderres.com
       4) Click "View Domain Settings"
          *or
          https://dcc.godaddy.com/control/traderres.com/settings

       5) In the menu select DNS -> Manage Zones
       6) Click on "View traderres.com"
       7) Under DNS Records, press "Add New Record"
          Type:   CNAME
          Name:   keycloak
          Value   ec2-18-218-246-201.us-east-2.compute.amazonaws.com
          TTL:    Default

    b. Verify that keycloak.traderres.com is found in a DNS lookup
       unix> nslookup keycloak.traderres.com

       Non-authoritative answer:
       keycloak.traderres.com	canonical name = ec2-18-218-246-201.us-east-2.compute.amazonaws.com.
       Name:	ec2-18-218-246-201.us-east-2.compute.amazonaws.com
       Address: 18.218.246.201


	c. Use godaddy to register ae512df1bdc3646ac961142b36441bc8-225527351.us-east-2.elb.amazonaws.com with a CNAME of app.traderres.com
		1) Login to godaddy.com
		2) Go to My Account -> My Products
		3) Click on the "Domain" link for traderres.com
		4) Click "View Domain Settings"
		   *or
		   https://dcc.godaddy.com/control/traderres.com/settings

		5) In the menu select DNS -> Manage Zones
		6) Click on "View traderres.com"
		7) Under DNS Records, press "Add New Record"
		   Type:   CNAME
		   Name:   app
		   Value   ae512df1bdc3646ac961142b36441bc8-225527351.us-east-2.elb.amazonaws.com
		   TTL:    Default


    d. Verify that app.traderres.com is found in a DNS lookup
       unix> nslookup app.traderres.com

		Non-authoritative answer:
		app.traderres.com	canonical name = ae512df1bdc3646ac961142b36441bc8-225527351.us-east-2.elb.amazonaws.com.
		Name:	ae512df1bdc3646ac961142b36441bc8-225527351.us-east-2.elb.amazonaws.com
		Address: 3.133.203.102
		Name:	ae512df1bdc3646ac961142b36441bc8-225527351.us-east-2.elb.amazonaws.com
		Address: 3.131.215.226



15. Create server certs with Let's Encrypt for the load-balancer (app.traderres.com) and keycloak (keycloak.traderres.com)
    NOTE:  The public Let's Encrypt certs are required to make sure that it all works in Firefox
    a. Create API keys in godaddy.com
       1) Go to https://developer.godaddy.com/
       2) Login with your godaddy account
       3) Click on API keys
          *OR*
          https://developer.godaddy.com/keys
       4) Create New API Key
       5) In the popup
          Give it a name
          Select production
          Press "Next"
       6) Copy the "key" and "secret" values

    b. Set the "key" and "secret" values in the authenticate.sh script
       1) Download the authenticate.sh script by going here:
               https://raw.githubusercontent.com/traderres/webClass/master/learnAWS/authenticate.sh

       2) Modify the authenticate.sh
          unix> vi /home/adam/certbot/authenticate.sh

          Change these values
             GODADDY_API_KEY="go-daddy-api-key-is-here"
             GODADDY_API_SECRET="go-daddy-secret-value-is-here"


    c. Install snapd on your linux box
       unix> sudo dnf install snapd          # Install snapd on centos 8

    d. Enable the snapd.socket
       unix> sudo systemctl enable --now snapd.socket

    e. Enable classic snap support
       unix> sudo ln -s /var/lib/snapd/snap /snap

    f. Install the Certbot
       unix> sudo snap install --classic certbot

    g. Prepare the Certbot command
       unix> sudo ln -s /snap/bin/certbot /usr/bin/certbot

    h. Use certbot to generate a signed server certificate for keycloak.traderres.com
       NOTE:  this command uses the authenticate.sh script to verify that the dns entry is valid
       unix> sudo certbot certonly --manual --preferred-challenges dns --manual-auth-hook /home/adam/certbot/authenticate.sh --config-dir /home/adam/certbot/ -d keycloak.traderres.com

       You should see this:
		   Successfully received certificate.
		   Certificate is saved at: /home/adam/certbot/live/keycloak.traderres.com/fullchain.pem
		   Key is saved at:         /home/adam/certbot/live/keycloak.traderres.com/privkey.pem
		   This certificate expires on 2023-06-19.
		   These files will be updated when the certificate renews.
		   Certbot has set up a scheduled task to automatically renew this certificate in the background.


    i. Use certbot to generate a signed server certificate for app.traderres.com
       unix> sudo certbot certonly --manual --preferred-challenges dns --manual-auth-hook /home/adam/certbot/authenticate.sh --config-dir /home/adam/certbot/ -d app.traderres.com

       You should see this:
			Successfully received certificate.
			Certificate is saved at: /home/adam/certbot/live/app.traderres.com/fullchain.pem
			Key is saved at:         /home/adam/certbot/live/app.traderres.com/privkey.pem
			This certificate expires on 2023-06-19.
			These files will be updated when the certificate renews.
			Certbot has set up a scheduled task to automatically renew this certificate in the background.


       You should have these files:
			/home/adam/certbot/accounts/acme-v02.api.letsencrypt.org/directory/dca0cb294974effc7178f301802f3366/private_key.json
			/home/adam/certbot/accounts/acme-v02.api.letsencrypt.org/directory/dca0cb294974effc7178f301802f3366/meta.json
			/home/adam/certbot/accounts/acme-v02.api.letsencrypt.org/directory/dca0cb294974effc7178f301802f3366/regr.json
			/home/adam/certbot/renewal/keycloak.traderres.com.conf
			/home/adam/certbot/renewal/app.traderres.com.conf
			/home/adam/certbot/archive/keycloak.traderres.com/cert1.pem
			/home/adam/certbot/archive/keycloak.traderres.com/privkey1.pem
			/home/adam/certbot/archive/keycloak.traderres.com/chain1.pem
			/home/adam/certbot/archive/keycloak.traderres.com/fullchain1.pem
			/home/adam/certbot/archive/app.traderres.com/cert1.pem
			/home/adam/certbot/archive/app.traderres.com/privkey1.pem
			/home/adam/certbot/archive/app.traderres.com/chain1.pem
			/home/adam/certbot/archive/app.traderres.com/fullchain1.pem
			/home/adam/certbot/live/README
			/home/adam/certbot/live/keycloak.traderres.com/README
			/home/adam/certbot/live/app.traderres.com/README
			/home/adam/certbot/authenticate.sh



16. Create & install the keycloak certificates on the running instance
    NOTE:  Keycloak Server has Java 11 JDK's keytool
           If your development env uses an older Java JDK, then build the cert with the older Java JDK

    We need to install the files to here:
        /opt/keycloak/keycloak.keystore.jks
        /opt/keycloak/keycloak.truststore.jks

    a. Upload the let's encrypt certs to the running instance
       unix> chown adam:adam -R /home/adam/certbot
       unix> scp  -i ~/.ssh/node-for-kubunetes-instance.pem  -r /home/adam/certbot/archive ec2-user@18.218.246.201:/tmp

    b. Upload our public/root.pem (from our custom.ca) to the running instance
       unix> scp  -i ~/.ssh/node-for-kubunetes-instance.pem  /home/adam/root-ca/public/root.pem ec2-user@18.218.246.201:/tmp/self-signed.ca.pem

    c. Create the keycloak keystore
        1) ssh to the running instance
           unix> ssh  -i ~/.ssh/node-for-kubunetes-instance.pem  ec2-user@18.218.246.201

        2) Examine the 3 files that makeup the full chain / Split it up into 3 files / Find the server cert
           NOTE:  The server cert has this:
                        CN=keycloak.traderres.com

           unix> cd /tmp/archive/keycloak.traderres.com
           unix> cat fullchain1.pem
           -- Split this up into 3 files called fullchainkc1.pem, fullchainkc2.pem, fullchainkc3.pem

		   unix> openssl x509 -in fullchainkc1.pem -noout -text | grep 'CN=keycloak.traderres.com'     # This one holds the server cert
		   unix> openssl x509 -in fullchainkc2.pem -noout -text | grep 'CN=keycloak.traderres.com'
		   unix> openssl x509 -in fullchainkc3.pem -noout -text | grep 'CN=keycloak.traderres.com'

        3) Generate the server.p12 file from the server cert
           unix> export SERVER_CRT=fullchainkc1.pem
		   unix> export SERVER_KEY=privkey1.pem
		   unix> export INTERMEDIATE_CA=fullchainkc2.pem
           unix> openssl pkcs12 -export -in $SERVER_CRT -inkey $SERVER_KEY -out server.p12 -name 'my-server-cert' -CAfile $INTERMEDIATE_CA -caname root
           Enter Export Password: changeit
           Verify Password:       changeit

        4) Convert the server.p12 into keycloak.keystore.jks
           unix> mkdir -p /opt/keycloak
           unix> keytool -importkeystore -deststorepass changeit -destkeypass changeit -destkeystore /opt/keycloak/keycloak.keystore.jks  -srckeystore server.p12 -srcstoretype PKCS12 -srcstorepass changeit -alias 'my-server-cert'

        5) For keycloak keystore, import the 3 pem files into the keycloak.keystore.jks
           unix> keytool -import -alias "keycloak1"  -keystore /opt/keycloak/keycloak.keystore.jks  -file fullchainkc1.pem   # If it's already imported, then don't bother
           unix> keytool -import -alias "keycloak2"  -keystore /opt/keycloak/keycloak.keystore.jks  -file fullchainkc2.pem
           unix> keytool -import -alias "keycloak3"  -keystore /opt/keycloak/keycloak.keystore.jks  -file fullchainkc3.pem


    d. Generate the keycloak truststore
       truststore needs to include the godaddy CA used for keycloak.traderres.com and intermediate CA
       truststore needs to include the self-signed CA used for PKI clients   (no intermediate)
       unix> cd /tmp/archive/keycloak.traderres.com
       unix> keytool -import -alias "keycloak1"  -keystore /opt/keycloak/keycloak.truststore.jks  -file fullchainkc1.pem
             password: change it
             verify:   changeit

       unix> keytool -import -alias "keycloak2"  -keystore /opt/keycloak/keycloak.truststore.jks  -file fullchainkc2.pem
       unix> keytool -import -alias "keycloak3"  -keystore /opt/keycloak/keycloak.truststore.jks  -file fullchainkc3.pem
       unix> keytool -import -alias "our-ca"     -keystore /opt/keycloak/keycloak.truststore.jks  -file /tmp/self-signed.ca.pem


	   At this point, we have these 2 files:
	        /opt/keycloak/keycloak.keystore.jks
	        /opt/keycloak/keycloak.truststore.jks



17. Initialize Keycloak as a service on the running instsance
    NOTE:  Keycloak is a container running on the kubernetes instance
    a. Ssh to the kubernetes instance
       unix> ssh -i ~/.ssh/node-for-kubunetes-instance.pem ec2-user@18.218.246.201

    b. Install Java JDK 11 or later
       unix> sudo amazon-linux-extras install java-openjdk11

    c. Verify Java JDK 11 is installed
       unix> java -version
       openjdk version "11.0.18" 2023-01-17 LTS
       OpenJDK Runtime Environment (Red_Hat-11.0.18.0.10-1.amzn2.0.1) (build 11.0.18+10-LTS)
       OpenJDK 64-Bit Server VM (Red_Hat-11.0.18.0.10-1.amzn2.0.1) (build 11.0.18+10-LTS, mixed mode, sharing)

    d. Download keycloak 21.0.1 to the /opt/keycloak directory
       unix> sudo -s
       unix> cd /tmp
       unix> wget https://github.com/keycloak/keycloak/releases/download/21.0.1/keycloak-21.0.1.zip

    e. Install keycloak to the /opt/keycloak directory
       unix> mkdir -p /opt/keycloak
	   unix> unzip /tmp/keycloak-21.0.1.zip -d /opt/keycloak
       -- Now, you should have /opt/keycloak/keycloak-21.0.1

    f. Create a keycloak user
       unix> sudo groupadd keycloak
       unix> sudo useradd keycloak -c "Mr Keycloak" -g "keycloak" -m

    g. Change ownership so that the /opt/keycloak directory is owned by the keycloak user
       unix> sudo chown keycloak:keycloak -R /opt/keycloak

    h. Build keycloak
       unix> cd /opt/keycloak/keycloak-21.0.1
       unix> bin/kc.sh build

    i. Verify that keycloak froms the command line
       unix> sudo -s
       unix> su - keycloak
       unix> /opt/keycloak/keycloak-21.0.1/bin/kc.sh start --http-enabled=false --https-port=8444 --https-key-store-file=/opt/keycloak/keycloak.keystore.jks --https-key-store-type=JKS --https-key-store-password=changeit --https-trust-store-file=/opt/keycloak/keycloak.truststore.jks --https-trust-store-type=JKS --https-trust-store-password=changeit --https-client-auth=request --log-level=INFO --hostname-strict-https=false --hostname-strict=false --hostname=keycloak.traderres.com

       Verify it comes-up listening on port 0.0.0.0:8444

       Press Control-C to kill it


    j. Create a keycloak service
       unix> sudo vi /etc/systemd/system/keycloak.service

		###################################################################################
		# Filename:  keycloak.service
		#
		# Purpose:
		#   Describe how the keycloak service runs
		#
		# Notes:
		#   If you update this file, then follow these steps:
		#   unix> sudo systemctl daemon-reload
		#   unix> sudo systemctl start keycloak
		#
		#   Look at the log
		#   unix> sudo journalctl -fu keycloak
		###################################################################################
		[Unit]
		Description=Keycloak Application Server
		After=syslog.target network.target
		StartLimitIntervalSec=1d
		StartLimitBurst=3

		[Service]
		Type=simple
		Restart=on-failure
		RestartSec=2s

		# Disable timeout logic and wait until process is stopped
		TimeoutStopSec=0

		# SIGTERM signal is used to stop the Java process
		KillSignal=SIGTERM

		# Send the signal only to the JVM rather than its control group
		KillMode=process
		User=keycloak
		Group=keycloak
		RemainAfterExit=yes
		LimitNOFILE=102642
		ExecStart=/opt/keycloak/keycloak-21.0.1/bin/kc.sh start --http-enabled=false --https-port=8444 --https-key-store-file=/opt/keycloak/keycloak.keystore.jks --https-key-store-type=JKS --https-key-store-password=changeit --https-trust-store-file=/opt/keycloak/keycloak.truststore.jks --https-trust-store-type=JKS --https-trust-store-password=changeit --https-client-auth=request --log-level=INFO --hostname-strict-https=false --hostname-strict=false --hostname=keycloak.traderres.com

		# Database Options
		Environment=KC_DB=postgres
		Environment=KC_DB_URL=jdbc:postgresql://keycloak.csbk2jnrc8ao.us-east-2.rds.amazonaws.com/keycloak_db
		Environment=KC_DB_USERNAME=keycloak_user
		Environment=KC_DB_PASSWORD=secret123

		[Install]
		WantedBy=multi-user.target

     k. Reload systemctl daemon
        unix> sudo systemctl daemon-reload

     l. Start the service
        unix> sudo systemctl start keycloak

     m. Look at the service log
        unix> sudo journalctl -fu keycloak

     n. Verify that you can connect to keycloak
        Open a browser
        Connect to https://keycloak.traderres.com:8444/


18. Configure keycloak
    a. Setup the admin account
       1) Stop keycloak
          ssh to the running instance
          unix> ssh -i ~/.ssh/node-for-kubunetes-instance.pem ec2-user@18.218.246.201
          unix> sudo systemctl stop keycloak

       2) Set the admin username and password with ENV variables
          unix> sudo vi /etc/systemd/system/keycloak.service

          Add these 2 environment variables

          		Environment=KEYCLOAK_ADMIN=keycloak
          		Environment=KEYCLOAK_ADMIN_PASSWORD=secret12


          When finished, the systemd file should look like this:
			###################################################################################
			# Filename:  keycloak.service
			#
			# Purpose:
			#   Describe how the keycloak service runs
			#
			# Notes:
			#   If you update this file, then follow these steps:
			#   unix> sudo systemctl daemon-reload
			#   unix> sudo systemctl start keycloak
			#
			#   Look at the log
			#   unix> sudo journalctl -fu keycloak
			###################################################################################
			[Unit]
			Description=Keycloak Application Server
			After=syslog.target network.target
			StartLimitIntervalSec=1d
			StartLimitBurst=3

			[Service]
			Type=simple
			Restart=on-failure
			RestartSec=2s

			# Disable timeout logic and wait until process is stopped
			TimeoutStopSec=0

			# SIGTERM signal is used to stop the Java process
			KillSignal=SIGTERM

			# Send the signal only to the JVM rather than its control group
			KillMode=process
			User=keycloak
			Group=keycloak
			RemainAfterExit=yes
			LimitNOFILE=102642
			ExecStart=/opt/keycloak/keycloak-21.0.1/bin/kc.sh start --http-enabled=false --https-port=8444 --https-key-store-file=/opt/keycloak/keycloak.keystore.jks --https-key-store-type=JKS --https-key-store-password=changeit --https-trust-store-file=/opt/keycloak/keycloak.truststore.jks --https-trust-store-type=JKS --https-trust-store-password=changeit --https-client-auth=request --log-level=INFO --hostname-strict-https=false --hostname-strict=false --hostname=keycloak.traderres.com

			# Database Options
			Environment=KC_DB=postgres
			Environment=KC_DB_URL=jdbc:postgresql://keycloak.csbk2jnrc8ao.us-east-2.rds.amazonaws.com/keycloak_db
			Environment=KC_DB_USERNAME=keycloak_user
			Environment=KC_DB_PASSWORD=secret123

			Environment=KEYCLOAK_ADMIN=keycloak
			Environment=KEYCLOAK_ADMIN_PASSWORD=secret12

			[Install]
			WantedBy=multi-user.target



       3) Update the service
          unix> sudo systemctl daemon-reload

       4) Startup the service
          unix> sudo systemctl start keycloak

       5) Use a browser to connect to keycloak
          Connect to https://keycloak.traderres.com:8444/
          Press "Admin Console"
          Enter admin username
          Enter admin password
          -- Verify that you can get in


    b. Configure the keycloak settings
       1) Connect to https://keycloak.traderres.com:8444/admin/master/console/

       2) Select Realms -> Create new realm: MyRealm


	   3) Create an x509 authentication flow
		a. Click on Authentication
		b. Click on browser
		c. Selection Action -> Duplicate
		   Name:  x509 authentication flow
		d. Delete Everything
		e. Press "Add execution"
		   Select  Cookie and press "Add"
		   Change Cookie's Requirement to "Alternaive"

		f. Press "Add step"
		   1) Press the "next" button a few times until you see x509/Validate Username Form
		   2) Select x509/Validate Username Form
		   3) Change X509/Validate Username From to Alternate
		   4) Press the "Settings" button

		   5) In the X509/Validate Username Form Config

			  Alias:                                        x509 configuration
			  User Identity Source:                         Match SubjectDN using regular expression
			  Regular expression to extract user identity:  cn=(.*?)(?:,|$)
			  User mapping method:                          Username or Email
			  Check certificate validity:                   On
			  Bypass identity confirmation                  On

		   6) In x509 authentication flow, select Action -> Bind flow
			  Choose "Browser flow"
			  Press "Save"




		 4) Create the client: sf328-webapp
			a. Click on Clients
			b. Press "Create client"

			General Settings
			  Client type:           OpenID Connect
			  Client ID:             sf328-webapp
			  Name:                  SF328 Submissions
			  Always display in UI:  Off
			  Press "Next"
			  Press "Next"
			  Press "Save"

			Access Settings:
			Root URL:              https://app.traderres.com/sf
			Home URL:              https://app.traderres.com/sf

			Capability Config:
			  Client authentication  On
			  Authorization          On
			  Authentication Flow:   Check Standard flow

			Login Settings
			   Login theme:               keycloak
			   Consent required:          Off
			   Display client on screen:  Off

			Press "Save"


		 5) Click on SF328-webapp / Credentials Tab
			Client Authenticator:  Client ID and Secret

		 6) Click on "Advanced"
			Go to Authentication flow overrides
			Browser Flow:  x509 authentication flow
			Press "Save"


		 7) Create the realm role
		    a. Press Relam roles
		    b. Press "Create role"
			a. Create a role called SF328_USER


		 8) Assign that role to your test user
			a. Click on Users
			b. Press "Add User"
			c. Username:       Lastname.first
            d. Press "create"

			d. Click on "role Mappings"
			e. Press Assign Role
			f. Assign the SF328_USER role to this user


		 9) Tell keycloak to provide the roles to spring boot
			a. Click on Client Scopes
			b. Select roles
			c. In the settings for 'roles'
			   Include in token scope: On

			d. Click on Client Scopes
			e. Select roles
			f. Select Mappers
			g. Select Realm Roles
			f. In the settings for "Realm Role'
				  Add to ID Token:     On
				  Add to access token: On
				  Add to userinfo:     On




19. Configure certificates for the load-balancer (external hostname used to access the webapp)
    NOTE:  The webapp needs a load-balancer truststore to work correctly
           The webapp needs a special custom.cacerts file (that has the lob chain and self-signed CA)

    NOTE:  You should have the signed cert files for app.traderres.com here:
			/home/adam/certbot/archive/app.traderres.com/cert1.pem
			/home/adam/certbot/archive/app.traderres.com/privkey1.pem
			/home/adam/certbot/archive/app.traderres.com/chain1.pem
			/home/adam/certbot/archive/app.traderres.com/fullchain1.pem

    a. Generate this file:  webapp.keystore.jks
       NOTE:  This file should should have the server cert for app.traderres.com in it

       1) Examine the 3 files that makeup the full chain of the fullchain1.pem / Split it up into 3 files / Find the server cert
           NOTE:  The server cert has this:
                        CN=app.traderres.com

           unix> cd /home/adam/certbot/archive/app.traderres.com
           unix> cat fullchain1.pem
           -- Split this up into 3 files called fullchainkc1.pem, fullchainkc2.pem, fullchainkc3.pem

		   unix> openssl x509 -in fullchain_part1.pem -noout -text | grep 'app.traderres.com'        # Holds the server cert
		   unix> openssl x509 -in fullchain_part2.pem -noout -text | grep 'app.traderres.com'
		   unix> openssl x509 -in fullchain_part3.pem -noout -text | grep 'app.traderres.com'

        3) Generate the server.p12 file from the server cert
           unix> export SERVER_CRT=fullchain_part1.pem
		   unix> export SERVER_KEY=privkey1.pem
		   unix> export INTERMEDIATE_CA=fullchain_part2.pem
           unix> openssl pkcs12 -export -in $SERVER_CRT -inkey $SERVER_KEY -out server.p12 -name 'my-server-cert' -CAfile $INTERMEDIATE_CA -caname root
           Enter Export Password: changeit
           Verify Password:       changeit

        4) Convert the server.p12 into webapp.keystore.jks
           unix> rm webapp.keystore.jks
           unix> keytool -importkeystore -deststorepass changeit -destkeypass changeit -destkeystore webapp.keystore.jks  -srckeystore server.p12 -srcstoretype PKCS12 -srcstorepass changeit -alias 'my-server-cert'




    b. Generate this file:  webapp.truststore.jks
       1) Break-up the app.traderres.com/fullchain1.pem file into 3 files:
               fullchain_part1.pem
               fullchain_part2.pem
               fullchain_part3.pem

       2) Import each file into the new webapp.truststore.jks file
          unix> cd /home/adam/certbot/archive/app.traderres.com
          unix> keytool -import -alias "new-lb1"  -keystore webapp.truststore.jks -file fullchain_part1.pem  -storepass changeit
          unix> keytool -import -alias "new-lb2"  -keystore webapp.truststore.jks -file fullchain_part2.pem  -storepass changeit
          unix> keytool -import -alias "new-lb3"  -keystore webapp.truststore.jks -file fullchain_part3.pem  -storepass changeit

          # Import the self-signed root CA pem file into webapp.truststore.jks
          unix> keytool -import -alias "our-ca"  -keystore webapp.truststore.jks -file /path/to/own-self-signed/root-ca/pem  -storepass changeit


    c. Generate this file:  custom.cacerts
       NOTE:  This is needed so that the spring security oauth2 authenticator can talk to the keycloak server
       unix> cp /usr/lib/jvm/java-1.8.0-openjdk/jre/lib/security/cacerts custom.cacerts
       unix> chmod ugo+rw custom.cacerts

       unix> keytool -import -alias "new-lb1"  -keystore  custom.cacerts  -file fullchain_part1.pem  -storepass changeit
       unix> keytool -import -alias "new-lb2"  -keystore  custom.cacerts  -file fullchain_part2.pem  -storepass changeit
       unix> keytool -import -alias "new-lb3"  -keystore  custom.cacerts  -file fullchain_part3.pem  -storepass changeit
       unix> keytool -import -alias "our-ca"   -keystore  custom.cacerts  -file /path/to/own-self-signed/root-ca/pem   -storepass changeit


20. Build and Push the webapp to Amazon ECR
    NOTE:  Normally, your kubernetes pod would refer to a volume and read the files from there
           But, we are going to embed the custom.cacerts, webapp.keystore.jks, and webapp.truststore.jks in the webapp (for now)

    a. Get the client id secret key
       1) Go to  https://keycloak.traderres.com:8444/
       2) Click on Admin Console
       3) Enter the admin user/password
       4) Click on Realms -> MyRealm
       5) Click on Clients
       6) Click on sf328-webapp
       7) Click on the "Credentials" tab
          -- Get the client secret

    a. Build the webapp with some certificates embedded (for now)
       Copy the custom.cacerts, webapp.keystore.jks, webapp.truststore.jks to the sf328/sf328-backend/src/main/prod_resources/ directory

    b. Make sure the production application.yaml has these setting:

			##########################################################
			# SSL Settings
			##########################################################
			server:
			  port: 8443
			  ssl:
				key-store: sf328-backend/src/main/prod_resources/webapp.keystore.jks
				key-store-password: changeit
				key-store-type: JKS
				client-auth: need
				trust-store: sf328-backend/src/main/prod_resources/webapp.truststore.jks
				trust-store-password: changeit
				trust-store-type: JKS
				enabled: true

    c. Make sure the production application.yaml has these keycloak settings:

			##########################################################
			# Keycloak Settings for Spring Security
			##########################################################
			spring.security.oauth2.client.registration.keycloak.client-id: sf328-webapp
			spring.security.oauth2.client.registration.keycloak.client-secret: <CLIENT_SECRET_FROM_KEYCLOAK_SERVER>
			spring.security.oauth2.client.registration.keycloak.authorization-grant-type: authorization_code
			spring.security.oauth2.client.registration.keycloak.scope: openid,email,profile
			spring.security.oauth2.client.provider.keycloak.issuer-uri: https://keycloak.traderres.com:8444/realms/MyRealm
			spring.security.oauth2.client.provider.keycloak.user-name-attribute: preferred_username
			spring.security.oauth2.resourceserver.jwt.issuer-uri: https://keycloak.traderres.com:8444/realms/MyRealm


    d. Get the procedures to push up the build up to the Amazon ECR
       1) Connect to aws.com as dev.user
       2) Go to the ECR
       3) Check the "traderres" repository
       4) Press "View push commands"

          The REPOSITORY_URL is 524647912468.dkr.ecr.us-east-2.amazonaws.com/traderres


    e. Get the AWS ECR authentication token  (so docker push will push it up to our Amazon ECR)
       Retrieve the authentication token  (from the "view push commands" step)
       unix> aws ecr get-login-password --region us-east-2 | docker login --username AWS --password-stdin 524647912468.dkr.ecr.us-east-2.amazonaws.com



    f. Build & Push the tag
       1) Edit the sf328-backend/pom.xml

          Change the <to><image> to this:

			  <to>
				   <image>REPOSITORY_URL:${project.artifactId}-${project.version}</image>
			  </to>

          So, it should appear as this:
              <to>
                <image>524647912468.dkr.ecr.us-east-2.amazonaws.com/traderres:${project.artifactId}-${project.version}</image>
              </to>

       2) Set the versoin to be 2.0.1-SNAPSHOT
          unix> mvn versions:set -DnewVersion=2.0.1-SNAPSHOT  -DgenerateBackupPoms=false

       3) Build the image
          unix> mvn clean package -Pprod -PbuildImage

       4) Push the image to our Amazon ECR
          unix> docker push 524647912468.dkr.ecr.us-east-2.amazonaws.com/traderres:sf328-backend-2.0.1-SNAPSHOT


21. Use Kubernetes to deploy the webapp
    a. Get the token
       unix> aws ecr get-login-password --region us-east-2 | docker login --username AWS --password-stdin 524647912468.dkr.ecr.us-east-2.amazonaws.com

    a. Delete existing deployment
       unix> kubectl delete deployment sf328-deployment

    b. Create the deployment script by adding the "env" section with Java settings
       unix> vi sf328-deployment-v1.yaml

#############################################################################
#  sf328-deployment-v1.yaml
#
# Notes:
#  1) The running pods do not have DNS so we need hostAliases to create an entry in /etc/hosts
#     that can resolve the keycloak.traderres.com to 18.218.246.201
#     Use nslookup keycloak.traderres.com to verify the IP
#
#############################################################################
apiVersion: apps/v1
kind: Deployment
metadata:
  name: sf328-deployment

spec:
  selector:
    matchLabels:
      app: sf328-backend
  replicas: 1
  strategy:
    type:  Recreate
  template:
    metadata:
      name: kubia
      labels:
         app: sf328-backend
    spec:
      hostAliases:
      - ip: "18.218.246.201"
        hostnames:
          - "keycloak.traderres.com"
      containers:
      - image: 524647912468.dkr.ecr.us-east-2.amazonaws.com/traderres:sf328-backend-2.0.1-SNAPSHOT
        imagePullPolicy: Always
        name: java-backend
        env:
          - name: JAVA_TOOL_OPTIONS
            value: -Xms250m -Xmx250m -Djavax.net.debug=ssl -Djavax.net.ssl.trustStore=/sf328-backend/src/main/prod_resources/custom.cacerts -Djavax.net.ssl.trustStorePassword=changeit




	 c. Verify that there are no special chars in the file by looking for them
		unix> cat -v -e sf328-deployment-v1.yaml

	 d. We create the deployment
		unix> kubectl create -f sf328-deployment-v1.yaml

	 e. Get a listing of the pods
		unix> kubectl get pods

		NAME                               READY   STATUS    RESTARTS   AGE
		sf328-deployment-c469974cb-tj4kk   1/1     Running   0          10s


	 f. Delete the existing load balancer service  (that was temporary)
		unix> kubectl delete service sf328-loadbalancer

	 g. Have AWS create and expose the load balancer service
		unix> kubectl expose deployment sf328-deployment --type=LoadBalancer --name=sf328-loadbalancer --port=443
		NOTE:  This create a new external hostname and IP address


	 h. Modify the created load balancer service by setting
		unix> kubectl edit service sf328-loadbalancer

		   targetPort=8443
		   sessionAffinity=ClientIP


	 i. Get the external hostname for this load balancer service
		unix> kubectl get services

		NAME                 TYPE           CLUSTER-IP     EXTERNAL-IP                                                               PORT(S)         AGE
		kubernetes           ClusterIP      10.100.0.1     <none>                                                                    443/TCP         27h
		sf328-loadbalancer   LoadBalancer   10.100.66.32   a913ec0732a4d4726a6d186c8233e52f-1165139498.us-east-2.elb.amazonaws.com   443:30493/TCP   5s



	 j. Update godaddy's cname record for app.traderres.com so that it corresponds to the new external hostname
		a. Login to godaddy.com
		b. Go to "Manage DNS" for traderres.com
		   *OR*
		   https://dcc.godaddy.com/control/traderres.com/dns

		c. Edit the old CNAME record for app.traderres.com
		   Type:  CNAME
		   Name:  app
		   Value: a913ec0732a4d4726a6d186c8233e52f-1165139498.us-east-2.elb.amazonaws.com

		d. Press "Save"



	 k. Restart the keycloak server
		ssh to the running instance
		unix> ssh -i ~/.ssh/node-for-kubunetes-instance.pem ec2-user@18.218.246.201
		unix> sudo systemctl restart keycloak




22. Verify it works
    a. Create a pki client cert
    b. Import it into a browser
    c. Attempt to connect to https://app.traderres.som/sf




Troubleshooting
---------------
 A. Ssh to the running pod
    unix> kubectl get pods

    unix> kubectl exec -it sf328-deployment-5c944dc79f-sb8lc /bin/bash
    unix> curl https://keycloak.traderres.com:8444/realms/MyRealm
    -- Verify that you get info cleanly (without error)




How to Shutdown the entire AWS cluster (so you're not being billed for anything)
--------------------------------------------------------------------------------
 1. Go into ECR, and delete the repository images

 2. Delete the node group
    Go into EKS -> Clusters -> sf -> Compute
    Highlight the node group -> Delete

 3. Delete the OpenSearch domain
    Go into OpenSearch -> Click on sf328 domain ->

 4. Delete Postgres RDS
    Go into RDS -> Database
    Select the keycloak -> Action -> Delete
    Uncheck "Create final snapshot"
    Delete

    Go into RDS -> Database
    Select the sf328 -> Action -> Delete
    Uncheck "Create final snapshot"
    Delete

 5. Delete the EKS Cluster (lsat)
    Go into EKS -> Clusters -> sf -> delete

 6. Delete the EC2 Load balancer
    Go into EC2 -> Load balancers -> Action -> Delete





Part 1: Configure Keycloak to run in SSL
----------------------------------------
 1. Create a Certificate Authority

 2. Use the Certificate Authority to create a client cert with the CN=smith.john

 3. Use the Certificate Authority to create a server cert with "cn=localhost.localdomain, ou=Components, ou=whatever, c=US"
    NOTE:  Firefox uses subject alternative names.  So make sure you have a subject alternative name with this hostname

    Put the keystore here:   /home/adam/intellijProjects/sf328/sf328-backend/src/main/prod_resources/my_keystore.jks
    Put the truststore here: /home/adam/intellijProjects/sf328/sf328-backend/src/main/prod_resources/my_truststore.jks

    Create the server cert using -dname -dname "cn=localhost.localdomain, ou=Components, ou=whatever, c=US"
    So, the first step in creating the server cert should look something like this:
    unix> export ALIAS=devKeystore
    unix> keytool -genkey -v -alias ${ALIAS}  -dname "cn=localhost.localdomain, ou=Components, ou=whatever, c=US"  -keysize 4096 -keyalg RSA -sigalg SHA256withRSA  -keystore myKeystore.jks -validity 3600

    The name should be a hostname that matches in /etc/hosts or is a real DNS name
    We use localhost.localdomain because it is found in /etc/hosts with the IP of 127.0.0.1


    NOTE:
      A) The keycloak startup script should have --hostname=localhost.localdomain   (so it is listening with this host)
      B) The keycloak's server cert  should have CN=localhost.localdomain
      C) The application.yaml in the spring security should have
             		spring.security.oauth2.client.provider.keycloak.issuer-uri: https://localhost.localdomain:8444/realms/MyRealm
             		spring.security.oauth2.resourceserver.jwt.issuer-uri: https://localhost.localdomain:8444/realms/MyRealm




 4. Enable SSL in keycloak

    a. Create a unix script that will startup keycloak with SSL
       unix> cd ~/Downloads/keycloak-21.0.1/
       unix> vi start.kc.ssl.sh


####################################################################################################################
# Filename:   start.kc.ssl.sh
#
# Purpose:
#     Run keycloak in SSL mode
#
# ASSUMPTIONS:
#   1) You ran bin/kc.sh build  (first)
#   2) You have a Java 11 JDK
#
# NOTES:
#   --https-client-auth=<none|request|required>       "request" means keycloak will also accept requests without a cert but validates cert if it exists
#   --hostname=localhost.localdomain                  tells it to listen on the hostname called localhost.localdomain
####################################################################################################################
export JAVA_HOME=/usr/java/jdk-11.0.12
export PATH=${JAVA_HOME}/bin:$PATH
bin/kc.sh start --http-enabled=false --https-port=8444 --https-key-store-file=/home/adam/intellijProjects/sf328/sf328-backend/src/main/prod_resources/my_keystore.jks --https-key-store-type=JKS --https-key-store-password=changeit --https-trust-store-file=/home/adam/intellijProjects/sf328/sf328-backend/src/main/prod_resources/my_truststore.jks --https-trust-store-type=JKS  --https-trust-store-password=changeit --https-client-auth=request  --log-level=INFO --hostname-strict-https=false --hostname-strict=false --hostname=localhost.localdomain


    b. Make the script executable
       unix> chmod u+x start.kc.ssl.sh


    c. Rebuild keycloak config
       unix> cd ~/Downloads/keycloak-21.0.1/
       unix> bin/kc.sh build   # To rebuild the configuration


 5. Startup Keycloak in SSL
    unix> cd ~/Downloads/keycloak-21.0.1/
    unix> ./start.kc.ssl.sh


 6. Verify that you can connect to keycloak at https://localhost.localdomain:8444/



Part 3: Configure Web App to use oauth2 for authentication
-----------------------------------------------------------
 1. Add these maven dependencies to your backend/pom.xml

    <dependency>
      <!-- Sprint Boot / Use OAuth2/OpenID Connect client as my authentication client -->
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-oauth2-client</artifactId>
    </dependency>

    <dependency>
      <!-- Spring Boot / Tell Spring Security to use the keycloak server for identity control -->
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
    </dependency>



 2. Add this profile to your application.yaml

		---
		#################################################################################################
		#            L O C A L      O A U T H 2        P R O F I L E
		# Prod Profile
		#  1) use the local database
		#################################################################################################
		spring.profiles: local_oauth2

		# So, we're running in HTTPS mode but using a hard-coded principal for security
		use.hardcoded.authenticated.principal: false


		##########################################################
		# Keycloak Settings for Spring Security
		##########################################################
		spring.security.oauth2.client.registration.keycloak.client-id: sf328-webapp
		spring.security.oauth2.client.registration.keycloak.client-secret: EZNI1jBMiWikhmYuIF2aIL0ULfkgzZHA
		spring.security.oauth2.client.registration.keycloak.authorization-grant-type: authorization_code
		spring.security.oauth2.client.registration.keycloak.scope: openid,email,profile

		spring.security.oauth2.client.provider.keycloak.issuer-uri: https://localhost.localdomain:8444/realms/MyRealm
		spring.security.oauth2.client.provider.keycloak.user-name-attribute: preferred_username

		spring.security.oauth2.resourceserver.jwt.issuer-uri: https://localhost.localdomain:8444/realms/MyRealm




		##########################################################
		# SSL Settings
		##########################################################
		server:
		  port: 8443
		  ssl:
			key-store: sf328-backend/src/main/prod_resources/my_keystore.jks
			key-store-password: changeit
			key-store-type: JKS
			client-auth: need
			trust-store: sf328-backend/src/main/prod_resources/my_truststore.jks
			trust-store-password: changeit
			trust-store-type: JKS
			enabled: true


		# Secure the cookies
		server.servlet.session.cookie.secure: true
		server.servlet.session.cookie.http-only: true



		##########################################################
		# Database Settings
		##########################################################
		app.datasource:
		  driver-class-name: org.postgresql.Driver
		  url: jdbc:postgresql://localhost:5432/sf328_db
		  username: sf328_user
		  password: secret
		  schema: sf328_db
		  maxPoolSize: 15
		  connectionTimeout: 60000
		  database-name: sf328_db


		###########################################################
		## ElasticSearch Settings
		###########################################################
		es:
		  url: http://localhost:9201
		  ssl_enabled: false




		##########################################################
		# File System Settings
		##########################################################
		root.dir:        ${java.io.tmpdir}             # Root directory to hold all DAS files
		sf328.root.dir:  ${root.dir}/sf328             # Root directory to hold all sf328 files
		das.user.dir:    ${root.dir}/das/users         # Root directory to hold all DAS user files




		##########################################################
		# SF328 Lifespan Settings
		##########################################################
		sf328.out.of.date.after.days:     365    # Number of days after an SF328 has been submitted before it's considered obsolete



 3. Create this class:  MyUserInfo   (holds additional information stored in the session)

		 package com.lessons.security;

		 import org.apache.commons.lang3.StringUtils;
		 import org.springframework.security.core.GrantedAuthority;
		 import java.io.Serializable;
		 import java.util.Collection;
		 import java.util.List;


		 public class MyUserInfo implements Serializable {

			 private String usernameUID;                           // The part of the Cn=.... that holds this user's client name (from PKI client cert)
			 private String usernameDN;                            // The entire DN string    (from the PKI client cert)
			 private List<GrantedAuthority> grantedAuthorities;    // List of roles for this user (found in the database)
			 private Integer id;                                   // Holds the user's ID in the database
			 private boolean userAcknowledgedMessage = false;
			 private boolean isLocked;
			 private boolean rolesAreConflicting = false;
			 private String rolesAreConflictingMessage;


			 public String getUsername() {
				 return this.usernameUID;
			 }


			 /**
			  * @return an array of GrantedAuthority objects for this user
			  */
			 public Collection<? extends GrantedAuthority> getAuthorities() {
				 // Must implement this method in order to implement the UserDetails interface
				 return this.grantedAuthorities;
			 }


			 public boolean getIsLockedOut() {
				 return this.isLocked;
			 }


			 public List<GrantedAuthority> getGrantedAuthorities() {
				 return grantedAuthorities;
			 }



			 public Integer getId() {
				 return id;
			 }

			 public String toString() {
				 return ("Roles=" + StringUtils.join(this.grantedAuthorities, ",") +
						 " UID=" + this.usernameUID +
						 " DN=" + this.usernameDN);
			 }

			 public MyUserInfo withId(Integer id) {
				 this.id = id;
				 return this;
			 }

			 public MyUserInfo withUsernameUID(String usernameUID) {
				 this.usernameUID = usernameUID;
				 return this;
			 }

			 public MyUserInfo withUsernameDn(String usernameDN) {
				 this.usernameDN = usernameDN;
				 return this;
			 }

			 public MyUserInfo withGrantedAuthorities(List<GrantedAuthority> grantedAuthorities) {
				 this.grantedAuthorities = grantedAuthorities;
				 return this;
			 }


			 public MyUserInfo withIsLocked(boolean aIsLocked) {
				 this.isLocked = aIsLocked;
				 return this;
			 }

			 public MyUserInfo withRolesAreConflicting(boolean aRolesAreConflicting) {
				 this.rolesAreConflicting = aRolesAreConflicting;
				 return this;
			 }

			 public MyUserInfo withRolesAreConflictingMessage(String aRolesAreConflictingMessage) {
				 this.rolesAreConflictingMessage = aRolesAreConflictingMessage;
				 return this;
			 }

			 public boolean getUserAcknowledgedMessage() {
				 return userAcknowledgedMessage;
			 }

			 public void setUserAcknowledgedMessage() {
				 this.userAcknowledgedMessage = true;
			 }

			 public boolean isRolesAreConflicting() {
				 return rolesAreConflicting;
			 }

			 public String getRolesAreConflictingMessage() {
				 return rolesAreConflictingMessage;
			 }

		 }



 4. Create this clsas:  MyDefaultOidcUser         (Replaces the DefaultOidcUser class)

		 package com.lessons.security;

		 import org.springframework.security.core.GrantedAuthority;
		 import org.springframework.security.oauth2.core.oidc.OidcIdToken;
		 import org.springframework.security.oauth2.core.oidc.OidcUserInfo;
		 import org.springframework.security.oauth2.core.oidc.user.DefaultOidcUser;

		 import java.util.Collection;

		 public class MyDefaultOidcUser extends DefaultOidcUser {

			 private MyUserInfo myUserInfo;

			 public MyDefaultOidcUser(Collection<? extends GrantedAuthority> authorities, OidcIdToken idToken) {
				 super(authorities, idToken);
			 }

			 public MyDefaultOidcUser(Collection<? extends GrantedAuthority> authorities, OidcIdToken idToken, String nameAttributeKey) {
				 super(authorities, idToken, nameAttributeKey);
			 }

			 public MyDefaultOidcUser(Collection<? extends GrantedAuthority> authorities, OidcIdToken idToken, OidcUserInfo userInfo) {
				 super(authorities, idToken, userInfo);
			 }

			 public MyDefaultOidcUser(Collection<? extends GrantedAuthority> authorities, OidcIdToken idToken, OidcUserInfo userInfo, String nameAttributeKey) {
				 super(authorities, idToken, userInfo, nameAttributeKey);
			 }

			 public MyDefaultOidcUser(MyUserInfo aUserInfo, Collection<? extends GrantedAuthority> authorities, OidcIdToken idToken, OidcUserInfo userInfo) {
				 super(authorities, idToken, userInfo);
				 this.myUserInfo = aUserInfo;
			 }


			 public MyUserInfo getMyUserInfo() {
				 return this.myUserInfo;
			 }
		 }





 5. Create this class:  AuthenticationService (that loads data into the principal)

		package com.lessons.services;

		import com.lessons.models.ConflictingRolesDTO;
		import com.lessons.models.InitialUserInfoDTO;
		import com.lessons.security.MyDefaultOidcUser;
		import com.lessons.security.MyUserInfo;
		import org.slf4j.Logger;
		import org.slf4j.LoggerFactory;
		import org.springframework.jdbc.core.JdbcTemplate;
		import org.springframework.security.core.Authentication;
		import org.springframework.security.core.GrantedAuthority;
		import org.springframework.security.core.authority.SimpleGrantedAuthority;
		import org.springframework.security.oauth2.core.oidc.user.OidcUser;
		import org.springframework.stereotype.Service;

		import javax.annotation.Resource;
		import javax.servlet.ServletException;
		import javax.servlet.http.HttpServletRequest;
		import javax.servlet.http.HttpServletResponse;
		import javax.sql.DataSource;
		import java.io.IOException;
		import java.util.ArrayList;
		import java.util.List;
		import java.util.Map;
		import java.util.regex.Matcher;
		import java.util.regex.Pattern;

		@Service
		public class AuthenticationService {
			private static final Logger logger = LoggerFactory.getLogger(AuthenticationService.class);

			@Resource
			private DataSource dataSource;

			@Resource
			private UserService userService;


			private static final Pattern patExtractCN = Pattern.compile("cn=(.*?)(?:,|/|\\z)", Pattern.CASE_INSENSITIVE);



			/**
			 * @param aRequest
			 * @param aResponse
			 * @param aAuthentication
			 * @throws Exception
			 */
			public void onAuthenticationSuccessForOauth2(HttpServletRequest aRequest,
														 HttpServletResponse aResponse,
														 Authentication aAuthentication) throws IOException, ServletException {
				logger.debug("onAuthenticationSuccessForOauth2() started");

				MyDefaultOidcUser myDefaultOidcUser = (MyDefaultOidcUser) aAuthentication.getPrincipal();

				// TODO: Mark this user as authenticated


				logger.debug("onAuthenticationSuccessForOauth2() finished");
			}



			public MyUserInfo generateUserInfoUsingOauth2Roles(OidcUser aOidcUser) {
				String userUID = aOidcUser.getName();

				List<GrantedAuthority> oauth2RolesGranted = new ArrayList<>();

				// Get the roles from keycloak and put them into the object called oauth2RolesGranted
				Map<String, Object> realmAccessMap = (Map<String, Object>) aOidcUser.getAttributes().get("realm_access");
				if ((realmAccessMap != null) && (realmAccessMap.size() == 1)) {
					List<String> roleNames = (List<String>) realmAccessMap.get("roles");

					if (roleNames != null) {
						for (String roleName: roleNames) {
							GrantedAuthority grantedAuthority = new SimpleGrantedAuthority("ROLE_" + roleName);
							oauth2RolesGranted.add(grantedAuthority);
						}
					}

				}

				// Get the list of the Citadel Roles from the db
				List<String> allCitadelRolesInDatabase = getListOfCitadelRolesFromDatabase();

				ConflictingRolesDTO conflictingRolesDTO = new ConflictingRolesDTO(oauth2RolesGranted, allCitadelRolesInDatabase);


				// Get the user's userId from the database (or generate one)
				// NOTE:  Use the synchronized version of this method when running in local dev mode
				InitialUserInfoDTO userInfoDTO = userService.getInitialUserInfoOrInsertRecordSynchronized(userUID);

				// The list of allRolesGranted = all citadel roles + all internal roles granted
				List<GrantedAuthority> allRolesGranted = new ArrayList<>(oauth2RolesGranted.size() + userInfoDTO.getInternalRolesGranted().size() );
				allRolesGranted.addAll(oauth2RolesGranted);
				allRolesGranted.addAll( userInfoDTO.getInternalRolesGranted());

				// Create a UserInfo object with information from the database and the keycloak server
				MyUserInfo userInfo = new MyUserInfo()
						.withId( userInfoDTO.getUserId() )
						.withIsLocked( userInfoDTO.getIsLocked() )
						.withUsernameUID( aOidcUser.getName() )
						.withGrantedAuthorities(allRolesGranted)
						.withRolesAreConflicting(conflictingRolesDTO.isRolesAreConflicting())
						.withRolesAreConflictingMessage(conflictingRolesDTO.getRolesAreConflictingMessage());

				return userInfo;
			}




			public MyUserInfo generateUserInfoForDevelopment(Authentication authentication) {

				String userUID = "my_sf328_user2";
				String userDN = "3.2.12.144549.1.9.1=#161760312e646576,CN=my_test_user2,OU=Hosts,O=ZZTop.Org,C=ZZ";

				if ((authentication != null) && (authentication.getPrincipal() != null)) {
					userDN = authentication.getPrincipal().toString();
					userUID = getCnValueFromLongDnString(userDN);
					if (userUID == null) {
						userUID = "my_sf328_user2";
					}
				}

				// Create a list of granted authorities
				// NOTE:  The roles *MUST* start with a ROLE_ prefix for the @PreAuthorize annotations to work correctly
				List<GrantedAuthority> citadelRolesGranted = new ArrayList<>();
				citadelRolesGranted.add(new SimpleGrantedAuthority("ROLE_SF328_USER"));
				citadelRolesGranted.add(new SimpleGrantedAuthority("ROLE_USER_FOUND_IN_VALID_LIST_OF_USERS"));

				// Get the list of the Citadel Roles from the db
				List<String> citadelRoles = getListOfCitadelRolesFromDatabase();

				ConflictingRolesDTO conflictingRolesDTO = new ConflictingRolesDTO(citadelRolesGranted, citadelRoles);


				// Get the user's userId from the database (or generate one)
				// NOTE:  Use the synchronized version of this method when running in local dev mode
				InitialUserInfoDTO userInfoDTO = this.userService.getInitialUserInfoOrInsertRecordSynchronized(userUID);

				// The list of allRolesGranted = all citadel roles + all internal roles granted
				List<GrantedAuthority> allRolesGranted = new ArrayList<>(citadelRolesGranted.size() + userInfoDTO.getInternalRolesGranted().size() );
				allRolesGranted.addAll(citadelRolesGranted);
				allRolesGranted.addAll( userInfoDTO.getInternalRolesGranted());

				// Create a bogus UserInfo object
				// NOTE:  I am hard-coding the user's userid=25
				MyUserInfo userInfo = new MyUserInfo()
						.withId( userInfoDTO.getUserId() )
						.withIsLocked( userInfoDTO.getIsLocked() )
						.withUsernameUID(userUID)
						.withUsernameDn(userDN)
						.withGrantedAuthorities(allRolesGranted)
						.withRolesAreConflicting(conflictingRolesDTO.isRolesAreConflicting())
						.withRolesAreConflictingMessage(conflictingRolesDTO.getRolesAreConflictingMessage());

				if (userInfoDTO.getIsLocked() ) {
					logger.info("{} successfully logged-in.", userUID);
				}


				// When running in local development, disable the acknowledgement popup
				userInfo.setUserAcknowledgedMessage();

				return userInfo;
			}




			public List<String> getListOfCitadelRolesFromDatabase() {
				JdbcTemplate jt = new JdbcTemplate(this.dataSource);

				String sql = "select name from roles where is_citadel_role=true";

				List<String> citadelRolesList = jt.queryForList(sql, String.class);

				return citadelRolesList;
			}



			private static String getCnValueFromLongDnString(String userDN) {
				logger.debug("getCnValueFromLongDnString()  userDN={}", userDN);
				String cnValue = null;
				// Use the regular expression pattern to getByUserId the value part of "CN=value"
				Matcher matcher = patExtractCN.matcher(userDN);
				if (matcher.find()) {
					cnValue = matcher.group(1);
				}

				logger.debug("getCnValueFromLongDnString() returns -->{}<--", cnValue);
				return cnValue;
			}


		}





 6. Create this class:  OAuth2LoginSuccessHandler

		package com.lessons.security;

		import com.lessons.services.AuthenticationService;
		import org.slf4j.Logger;
		import org.slf4j.LoggerFactory;
		import org.springframework.security.core.Authentication;
		import org.springframework.security.web.authentication.SavedRequestAwareAuthenticationSuccessHandler;
		import org.springframework.stereotype.Component;

		import javax.annotation.Resource;
		import javax.servlet.ServletException;
		import javax.servlet.http.HttpServletRequest;
		import javax.servlet.http.HttpServletResponse;
		import java.io.IOException;

		/*
		 * Create a success handler class that extends SavedRequestAwareAuthenticationSuccessHandler
		 * -- This ensures that upon successful authentication, the user is taken to the user's ORIGINAL url
		 */
		@Component
		public class OAuth2LoginSuccessHandler extends SavedRequestAwareAuthenticationSuccessHandler {
			private static final Logger logger = LoggerFactory.getLogger(OAuth2LoginSuccessHandler.class);

			@Resource
			private AuthenticationService authenticationService;

			@Override
			public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response,
												Authentication authentication) throws IOException, ServletException {

				logger.debug("onAuthenticationSuccess() started");

				// The user successfully authenticated against the OAUTH2 Server

				// Create the UserInfo object and set it as the principal
				//   1) Replace the OAuth2 Principal object with our own UserInfo object
				//   2) Update the database to indicate that the user successfully logged-in
			   this.authenticationService.onAuthenticationSuccessForOauth2(request, response, authentication);


			   // Proceed to the user's original URL
			   super.onAuthenticationSuccess(request, response, authentication);
			}


		}



 7. Update your SpringSecurityConfig with this:

		package com.lessons.security;

		import com.lessons.services.AuthenticationService;
		import org.springframework.beans.factory.annotation.Value;
		import org.springframework.boot.web.servlet.FilterRegistrationBean;
		import org.springframework.context.annotation.Bean;
		import org.springframework.context.annotation.Configuration;
		import org.springframework.core.Ordered;
		import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;
		import org.springframework.security.config.annotation.web.builders.HttpSecurity;
		import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
		import org.springframework.security.config.http.SessionCreationPolicy;
		import org.springframework.security.oauth2.client.oidc.userinfo.OidcUserRequest;
		import org.springframework.security.oauth2.client.oidc.userinfo.OidcUserService;
		import org.springframework.security.oauth2.client.userinfo.OAuth2UserService;
		import org.springframework.security.oauth2.core.oidc.user.OidcUser;
		import org.springframework.security.web.SecurityFilterChain;
		import org.springframework.web.filter.ForwardedHeaderFilter;

		import javax.annotation.Resource;
		import javax.servlet.DispatcherType;


		@Configuration
		@EnableWebSecurity
		@EnableGlobalMethodSecurity(prePostEnabled = true)         // Needed for @PreAuthorize to work
		public class SpringSecurityConfig  {

			@Resource
			private MyRequestHeaderAuthFilter requestHeaderAuthFilter;

			@Resource
			private OAuth2LoginSuccessHandler oAuth2LoginSuccessHandler;

			@Resource
			private AuthenticationService authenticationService;

			@Value("${server.ssl.enabled}")
			private boolean sslEnabled;




			private OAuth2UserService<OidcUserRequest, OidcUser> oidcUserService() {
				final OidcUserService delegate = new OidcUserService();

				return (OidcUserRequest aOidcUserRequest) -> {
					// Get the OidcUser object (that holds information from Keycloak)
					OidcUser oidcUser = delegate.loadUser(aOidcUserRequest);

					// Get the MyUserInfo object (that holds additional info from our database)
					MyUserInfo myUserInfo = this.authenticationService.generateUserInfoUsingOauth2Roles(oidcUser);

					// Create a new Principal object that holds MyUserInfo *AND* the original token information from keycloak
					MyDefaultOidcUser myDefaultOidcUser = new MyDefaultOidcUser(myUserInfo, myUserInfo.getGrantedAuthorities(), oidcUser.getIdToken(), oidcUser.getUserInfo());
					return myDefaultOidcUser;
				};
			}



			@Bean
			public SecurityFilterChain securityFilterChain(HttpSecurity aHttpSecurity) throws Exception {

				if (sslEnabled) {

					// Running in production mode using OAuth2 authentication
					aHttpSecurity.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.ALWAYS)
							.and()
								.authorizeRequests()
									.antMatchers("/assets/**",  "**.js", "**.css",  "/error").permitAll()
									.antMatchers("/**").access("hasRole('ROLE_SF328_USER')")   // All users must have the grantedAuthority called ROLE_USER_FOUND_IN_VALID_LIST_OF_USERS to view all pages
									.anyRequest()
									.authenticated()
							.and()
								.requiresChannel().anyRequest().requiresSecure()
							.and()
								.oauth2Login()

									/*
									 * Update the Principal object stored in the session
									 * Replace the defaultOidcUser with MyDefaultOidcUser object   (that holds the additional MyUserInfo)
									 */
									.userInfoEndpoint(userInfo -> userInfo
											.oidcUserService(this.oidcUserService()))


									  /*
									   * The oAuth2LoginSuccessHandler success handler class will do 2 things:
									   *   1) Update the database to indicate that the user successfully authenticated
									   *   2) Redirect the user from keycloak to the user's ORIGINAL requested url (because it extends SavedRequestAwareAuthenticationSuccessHandler)
									   */
									.successHandler(this.oAuth2LoginSuccessHandler)

							.and()
								.csrf().disable();


				}

				else {


					// Running in http / local dev mode

					 aHttpSecurity.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.ALWAYS)
							.and()
								.authorizeRequests()     // Filters out any URLs that are ignored.  This should be before any authorization filters
								.antMatchers("/assets/**",  "**.js", "**.css",  "/error").permitAll()
								.antMatchers("/**").access("hasRole('ROLE_SF328_USER')")   // All users must have the grantedAuthority called ROLE_USER_FOUND_IN_VALID_LIST_OF_USERS to view all pages
								.anyRequest()
								.authenticated()
							.and()
								.requiresChannel().antMatchers("/**").requiresInsecure()
							.and()
								.addFilter(requestHeaderAuthFilter)
								.headers().frameOptions().disable()                       // By default X-Frame-Options is set to denied.
							 .and()
								.anonymous().disable()
								.csrf().disable();

				}

				return aHttpSecurity.build();
			}


			@Bean
			public FilterRegistrationBean<ForwardedHeaderFilter> forwardedHeaderFilter() {
			  // ForwardedHeaderFilter handles non-standard headers
			  //   X-Forwarded-Host, X-Forwarded-Port, X-Forwarded-Proto, X-Forwarded-Ssl, and X-Forwarded-Prefix.
			  ForwardedHeaderFilter filter = new ForwardedHeaderFilter();

			  FilterRegistrationBean<ForwardedHeaderFilter> registration = new FilterRegistrationBean<>(filter);
			  registration.setDispatcherTypes(DispatcherType.REQUEST, DispatcherType.ASYNC, DispatcherType.ERROR);
			  registration.setOrder(Ordered.HIGHEST_PRECEDENCE);
			  return registration;
			}
		}




 8. Update your MyRequestHeaderAuthFilter


		package com.lessons.security;

		import org.slf4j.Logger;
		import org.slf4j.LoggerFactory;
		import org.springframework.beans.factory.annotation.Value;
		import org.springframework.security.web.authentication.preauth.RequestHeaderAuthenticationFilter;
		import org.springframework.stereotype.Component;

		import javax.annotation.PostConstruct;
		import javax.annotation.Resource;
		import javax.servlet.http.HttpServletRequest;


		@Component("com.lessons.security.RequestHeaderAuthFilter")
		public class MyRequestHeaderAuthFilter extends RequestHeaderAuthenticationFilter
		{
			private static final Logger logger = LoggerFactory.getLogger(MyRequestHeaderAuthFilter.class);

			@Resource
			private MyAuthenticationManager myAuthenticationManager;

			@Value("${use.hardcoded.authenticated.principal}")
			private boolean useHardcodedAuthenticatedPrincipal;

			@PostConstruct
			public void init() {
				this.setAuthenticationManager(myAuthenticationManager);
			}


			/*
			 * getPreAuthenticatedPrincipal()
			 *
			 * This is called when a request is made, the returned object identifies the
			 * user and will either be {@literal null} or a String.
			 *
			 * This method will throw an exception if
			 * exceptionIfHeaderMissing is set to true (default) and the required header is missing.
			 */
			@Override
			protected Object getPreAuthenticatedPrincipal(HttpServletRequest request)
			{
				logger.debug("getPreAuthenticatedPrincipal() called");

				// Get the principal from the header
				String userDnFromHeader = request.getHeader("SSL_CLIENT_S_DN");
				logger.debug("userDnFromHeader from header -->{}<---", userDnFromHeader);

				if (userDnFromHeader == null) {

					if (useHardcodedAuthenticatedPrincipal) {
						// No header was found, but I am in dev mode or "local prod" mode.  So, set a hard-coded user name
						logger.debug("No header was found, so using hard-coded header 'Bogus_user'");
						userDnFromHeader = "Bogus_user";
					}
				}

				// If this method returns null, then the user will see a 403 Forbidden Message
				logger.debug("getPreAuthenticatedPrincipal() returns -->{}<--", userDnFromHeader);
				return userDnFromHeader;
			}



		}




 9. Startup keycloak with ssl

10. Startup the backend with this profile  -Dspring.profiles.active=local_oauth2

11. Connect to https://localhost.localdomain:8443/sf
    -- You should be prompted for your pki cert
    -- You should be redirected to keycloak at http://localhost.localdomain:8444/
    -- You should be redirected back to https://localhost.localdomain:8443/sf



When deploying on AWS, remember that you need 2 signed server-certs
 1) Server Cert #1 will be used by keycloak
    Create it with subject alternative name = hostname, external IP, and internal IP
    NOTE:  Make sure the hostname is *FIRST* in the subect alternative name

 2) Server Cert #2 will be used by the sprint boot web app
    Create it with subject alternative name = external hostname, external IP
    NOTE:  Make sure the hostname is *FIRST* in the subect alternative name