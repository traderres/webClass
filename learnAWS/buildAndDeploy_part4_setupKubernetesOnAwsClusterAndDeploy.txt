How to Setup Kubernetes on AWS Cluster and Deploy using Keycloak Server for PKI Authentication
----------------------------------------------------------------------------------------------
Goal: Deploy this webapp so anyone can get to it using https://www.traderres.com/app16
        AWS Region:            us-east-1
        AWS EKS Cluster Name:  app16-cluster



Web Browser Order of Operations
-------------------------------
 1. User uses a browser to hit Java Web App
    -- User presents PKI certificate to Java Web App

 2. Spring Security redirects user to the Keycloak server
    -- User presents PKI certificate to keycloak

 3. User is presented a keycloak login page  (or it can be bypassed)
    -- User presses "Submit" button on keycloak login page
    -- User is redirected to the Java Web App with keycloak credentials
       *OR*
    -- If bypass setting is enabled, user goes directly to Java Web App with keycloak credentials

 4. Spring Security detects that authentication is successful
    -- Java code gets the user's roles and any additional info and adds MyUserInfo to the principal object

    NOTE:  Redirecting the user to the keycloak server is the most secure way of implementing security (according to the Keycloak folks)



ASSUMPTIONS:
 A) You can build your spring boot webapp as a container
    See learnKeycloak / howToConfigureKeycloakToUsePkiAuthenticationOnLocalhost.txt
    See learnAWS / buildAndDeploy_part1_setupAwsAccountAndECR.txt
    See learnAWS / buildAndDeploy_part2_buildWebappsAsContainer.txt
 B) You have an AWS account
 C) You have installed the AWS CLI tool
 D) You have a registered domain called "traderres.com" with Route 53
 	-- You have a Hosted zone name called "traderres.com"




General Approach
----------------
 1. Setup AWS Account / Create Users / Grant CLI Access  (so we can push up builds to our AWS ECR Registry)
 2. Setup AWS CNI Policy / so dev.user can make changes to kubernetes
 3. Create the Amazon VPC (created by default for the dev.user)
 4. Create the "bastion host" key-pair and instance
 5. Create the EKS Cluster (as dev.user)
 6. Finish configuring CNI Policy
 7. Create Kubernetes Node Group
 8. Finish configuring the "bastion host"
 9. Update the yum packages of the running instance
10. Initialize AWS-hosted resources (exist outside of the kubernetes cluster)
    NOTE:  postgres and OpenSearch do not run inside kubernetes
    a. Setup 2 RDS / postgres instances (one for the webapp and one for keycloak)
    b. Setup OpenSearch
11. Create a persistent volume and mount to /opt/shared-storage on the keycloak server
12. Create our own certificate authority (for pki client certs)
13. Configure your local kubectl command to talk to our new Kubernetes cluster
14. Get the aws external hostnames for keycloak and the app's loadbalancer
15. Register the domain name that correspond to the external AWS keycloak and external AWS load balancer names
16. Create server certs with Let's Encrypt for the load-balancer (app.traderres.com) and keycloak (keycloak.traderres.com)
17. Install Java 17 JDK on the keycloak server
18. Create & install the keycloak certificates on the running instance
19. Initialize Keycloak as a service on the running instance
20. Configure Keycloak's admin account
21. Configure certificates for the load-balancer (external hostname used to access the webapp)
22. Get the environment values for the kubernetes deployment yaml files
23. Setup PersistentVolumes so you can share certs among the pods
24. Upload the shared certs into the /shared/certs persistent volume
25. Use Kubernetes to deploy the sync service
26. Use Kubernetes to deploy the webapp



Setup local kubectl that is *NOT* part of minikube
---------------------------------------------------
 1. If you have installed mini-kube, then
 	a. remove the existing mini kube setup
       unix> rm -rf ~/.kube-localhost/
       unix> mv ~/.kube ~/.kube-localhost

    b. Comment out this alias
       unix> vi ~/.bashrc
             ##   alias kubectl="minikube kubectl --"


 2. Download & install the latest kubectl
    unix> cd /tmp
    unix> curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
    	  -- This downloads kubectl to your current directory

    unix> sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl

    unix> which kubectl
    /usr/local/bin/kubectl


 3. **IF YOU HAVE ALREADY CREATED YOUR EKS CLUSTER**
    Set my kubectl configuration (so running kubectl connects to the AWS EKS cluster)
    a. Get your current region by going to aws.com, logging-in as the dve.user and looking at the region (next to your name in the upper right corner)

    b. Get your EKS cluster name by going to EKS -> Clusters and look at the name

    c. Setup kubectl to talk to your cluster
       unix> aws eks update-kubeconfig --region us-east-1 --name app-cluster

       You should see this:
        	Added new context arn:aws:eks:us-east-1:524647912468:cluster/app-cluster to /home/adam/.kube/config

    d. Verify that kubectl can talk to your AWS EKS cluster
       unix> kubectl get services
       -- Now, your kubectl is setup to your cluster





Procedure
---------
 1. Setup AWS Account / Create Users / Grant CLI Access  (so we can push up builds to our AWS ECR Registry)
    Goal:  Setup a user that can run the CLI to push-up builds
    a. Go to https://aws.com/

    b. Create the "administrators" group
       1) In AWS, go to Services -> IAM
       2) On the left, click on User groups
       3) Press "Create group"
          User group name:  administrators

       4) In the "Attach permissions policies"
          Add these role:
            AdministratorAccess
       5) Press "Create Group"

    b. Create the dev.user
       1) In AWS, go to Services -> IAM
       2) On the left, click on Users
       3) Press "Add Users"
       4) In "User details"
          User name:  dev.user
          Check "Provide user access to the AWS Management Console"
          Check "I want to create an IAM user"


          Custom password
             custom password:  enter it
             Uncheck "User must create a new password at next sign-in)

          Press "Next"

       5) In "Set permissions"
          Select "Attach policies directly"
          Search for CNI
          Check Off theses roles:  AmazonEKS_CNI_Policy
          Press "Next"

       6) Press "Create user"
          NOTE:  Grab the console sign-in link:   https://524647912468.signin.aws.amazon.com/console

       7) Add this user to the "administrators group"
          Go to IAM -> Users
          Click on the "dev.user" link
          Click on "Groups"
          Press "Add user to groups"
          Check "administrators"
          Press "Add user to group(s)"

       8) Create access keys for the dev.user
          1) Click on "Users"
          2) Click on dev.user
          3) Click on "Security Credentials"
          4) Click on "Create access key"
          5) Select Command Line interface
             Select "I understand the above"
             Press "Next"

          6) Description tag value:  leave it blank
             Press "Create access key"

          7) Download the key by pressing "Download .csv file"
            --> Save dev.user_accessKeys.csv to your ~/Downloads

           -- Now, the user called "dev.user" should have the authority to push up to the AWS ECR Registry


    c. Logout as root user


 2. Setup AWS CNI Policy (as the dev.user)
    a. Login as dev.user
       https://524647912468.signin.aws.amazon.com/console
                    ^
                    |
                This is your 12-digit account id


    b. Create this role: eksClusterRole
       1) Go to AWS IAM page
       2) Click on Roles
       3) Press "Create Role"
       4) In Select trusted entity,
          Trusted entity type:  "AWS service"
          Service:              "EKS"
          Use case:             "EKS - Cluster"
          Press "Next"

       5) In "Add permissions", go with defaults and press "Next"

       6) In Name, review, and create
          Role name:  eksClusterRole
          Press "Create Role"

       7) In Roles, Check on eksClusterRole
          Select "Add permissions" -> "Attach Policies"
          Search for AmazonEKS_CNI_Policy and press Enter
          -- Check AmazonEKS_CNI_Policy
          Press "Add Permission"

       8) Click on the "Trust relationships" tab
          Verify that you see this:
			  {
				  "Version": "2012-10-17",
				  "Statement": [
					  {
						  "Effect": "Allow",
						  "Principal": {
							  "Service": "eks.amazonaws.com"
						  },
						  "Action": "sts:AssumeRole"
					  }
				  ]
			  }

    c. Create this role:  eksNodeRole
       1) Go to AWS IAM page
       2) Click on Roles
       3) Press "Create Role"
       4) In Select trusted entity,
          Trusted entity type:  "AWS service"
          Service:              "EKS"
          Use case:             "EKS - Cluster"
          Press "Next"
       5) In "Add permissions", go with defaults and press "Next"
       6) In Name, review, and create
          Role name:  eksNodeRole
          Press "Create Role"

       7) In Roles, Click on eksNodeRole
       8) Select "Add permissions" -> "Attach Policies"
          Search for AmazonEKS and press Enter
          -- Check AmazonEKS_CNI_Policy
          -- Check AmazonEKSWorkerNodePolicy
          Press "Add Permission"

       9) In the Roles / eksNodeRole, remove the AmazonEKSClusterPolicy
          -- In Permissions policies, check AmazonEKSClusterPolicy
          -- Press "Remove"

      10) In the Roles / eksNodeRole, Add the AmazonEC2ContainerRegistryReadOnly
          In Permissions policies, select "Add permissions" -> "Attach Policies"
          Search for AmazonEC2ContainerRegistryReadOnly
             -- Check AmazonEC2ContainerRegistryReadOnly
          Press "Add permissions"

          At this point eksNodeRole, should have 3 policies:
                AmazonEC2ContainerRegistryReadOnly
           		AmazonEKS_CNI_Policy,
          		AmazonEKSWorkerNodePolicy


     11) Click on "Trust relationships" (all of the worker nodes are running on ec2 hosted servers / this granting rights to the ec2 hosted instsances)
         Press "Edit trust policy"

         Find this line:
           "Service": "eks.amazonaws.com"

         Replace with this line:
           "Service": "ec2.amazonaws.com"

         Press "Update policy"



    d. Create this role:  AmazonEKS_VPC_CNI_Role
       1) Go to AWS IAM page
       2) Click on Roles
       3) Press "Create Role"
       4) In Select trusted entity, choose "AWS service"
          Trusted entity type:  "AWS service"
          Service:              "EKS"
          Use case:             "EKS - Cluster"
          Press "Next"
       5) In "Add permissions", go with defaults and press "Next"
       6) In Name, review, and create
          Role name:  AmazonEKS_VPC_CNI_Role
          Press "Create Role"

       7) In Roles, Click on AmazonEKS_VPC_CNI_Role
       8) Select "Add permissions" -> "Attach Policies"
          Search for AmazonEKS_CNI_Policy and press Enter
          -- Check AmazonEKS_CNI_Policy
          Press "Add Permission"
       9) In Permissions policies, remove AmazonEKSClusterPolicy policy
          -- Check AmazonEKSClusterPolicy and press "Remove"



 3. Create the Amazon VPC (created by default for the dev.user)
     a. Verify that you have a VPC (created for you)
       1) Go to VPCs -> Your VPCs
       2) If you see no VPCs, then create a VPC
          a) Press "Create VPC"

          b) In the "Create VPC" page
             Resources to create:     Select "VPC and more"

             Name tag auto-generate:  project    (so that the vpc is called project-vpc)

             IPv4 CIDR blocK:               Default of 10.0.0.0/16
             Tenancy:                       Default

			 IPv6 CIDR block:               No IPv6 CIDR block

             Number of Availability Zones:  2     # In production, this would probably be 3

             Number of public subnets:      2     # We need 1 public subnet for our bastion host
             Number of private subnets:     2     # We need private subnets for the running kubernetes nodes

             NAT Gateways:                  None
             VPC endpoints:                 None

             Enable DNS Hostnames:          Checked
             Enable DNS resolution:         Checked

             Press "Create VPC"

             NOTE:  This will also create an Internet Gateway and attach to it to this newly-created VPC (wait a minute for it)


       If you do see a default VPC verify then verify this:
          Select your VPC, Press Action -> Edit VPC Settings
          -- Verify that "Enable DNS resolution" is checked
          -- Verify that "Enable DNS hostnames"  is checked
          -- Verify that you have subnets already created for you
          -- Verify that you have an Internet gateway created for you

        NOTE:  Default settings should be fine
        NOTE:  We can change the subnets are this point




 4. Create the "bastion host" key-pair and instance
 	a. Create a keypair:
    	1) Click on EC2 -> Network & Security -> Key Pairs
    	2) Press "Create key pair"
		   Name:   app16-bastion-host-keypair
		   Type:   RSA
		   Format: PEM
		   Press "Create key pair"
				  -- You will be prompted to download the app16-bastion-host-keypair.pem

	b. Create the bastion host
    	1) Go to EC2 -> Press "Launch Instance"

    	2) In the "Launch an instance" page
    		Name:  bastion-host
    		Amazon Machine Image:  Amazon Linux 2023 AMI
    		Architecture:  64-bit (x86)
    		Instance Type: t2.micro

    	3) Key Pair:      app16-bastion-host

		4) Next to "Network Settings" press "Edit"
			VPC:   					project-vpc
			Subnet:  				Choose a public subnet
			Auto-assign public IP:  Enable

			Firewall
				Create a security group
				security group name:  bastion-host-security-group

				Allow SSH traffic from Anywhere

			Configure storage:
				1 x 20 GiB of Gp3 root volume

			Press "Launch instance"


			W A I T     5    M I N     F O R      B A S T I O N     H O S T     T O     I N I T I A L I Z E




	c. Test connectivity to the bastion host
	   1) Go to EC2 -> Instances
       2) Click on the bastion-host -> Connect -> Click "SSH Client"
          -- Copy the example command *OR* get the public hostname/IP

       3) Reduce the privileges on the key-pair file so it is only accessible to me
          unix> chmod go-rwx ~/Downloads/app16-bastion-host-keypair.pem

	   4) Use the bastion host keypair to connect to it
	      unix> ssh -i ~/Downloads/app16-bastion-host-keypair.pem ec2-user@ec2-44-197-169-72.compute-1.amazonaws.com

		  You should see the following:
			SUSE Linux Enterprise Server 15 SP6 x86_64 (64-bit)

			As "root" (sudo or sudo -i) use the:
			  - zypper command for package management
			  - yast command for configuration management

			Management and Config: https://www.suse.com/suse-in-the-cloud-basics
			Documentation: https://www.suse.com/documentation/sles-15/
			Community: https://community.suse.com/

			Have a lot of fun...


	d. Create a security group:  ssh-from-bastion-host-security-group
         1) Get the private IP address of the bastion host
            -- Go to EC2 Instances
            -- Click on bastion-host
            -- NOTE the private IPv4:   10.0.14.50

         2) Go to VPC -> Security groups
         3) Press "Create security group"
			Security group name:    ssh-from-bastion-host-security-group
			Description:            ssh-from-bastion-host-security-group
			VPC:					Project-VPC

			Under "Inbound rules", press "Add rule"
				Type    is SSH
				Source  is Custom    10.0.14.50/32

         4) Press "Create security group"


											b. Click on Network & Security -> Key Pairs
											c. Press "Create key pair"
											   Name:   app16-kubernetes-nodes-keypair
											   Type:   RSA
											   Format: PEM
											   Press "Create key pair"
													  -- You will be prompted to download the app16-kubernetes-nodes-keypair.pem

											d. Add an inbound rule for this node so that you can ssh from anywhere
											   1) Go to EC2
											   2) Click on Network & Security -> Security groups
											   3) Check the default security group
											   4) Press Action -> Edit Inbound Rules
											   5) Press "Add Rule"
												  Type:   SSH
												  Source: Anywhere-IPv4
												  Press "Save rule"

											e. Add another inbound rule for our default security group  (to let all traffic in and out)
											   1) Go to EC2 Dashboard
											   2) Click on Resources -> Security groups
											   3) Check the default security group and press Action -> Edit Inbound Rules
											   4) Press "Add Rule"
													  Type:   All Traffic
													  Source: Anywhere-IPv4
															  0.0.0.0/0
													  Press "Save rule"




 5. Create the EKS Cluster (as dev.user)
    a. Login as the dev.user

    b. Search Services for EKS -> Select Elastic Kubernetes Service  (as dev.user)

    c. Press "Create Cluster" -> "Create"

    d. In "Configure Cluster"
       Configuration Options:  		"Custom configuration"

       EKS Auto Mode:
       		"EKS AUto Mode":     	Uncheck

       Cluster configuration
       		Name:           		app16-cluster
       		Cluster IAM role:   	eksClusterRole

       Kubernetes version:     1.31  (or the latest)

       Press "Next"


    e. In Networking
       VPC:                               Choose default vpc  (project-vpc)
       Subnets:                           auto-selected both subnets for you / Select public and private subnets
       Security groups:                   Choose the default security group
       Choose cluster IP address family:  IPv4
       Cluster endpoint access:           Public and private
       Press "Next"

    f. In Configure observability
       Leave it all off for now
       Press "Next"

    g. In "Select add-ons",
       By default, it select the following:
       	-- CoreDNS
       	-- kube-proxy
       	-- Amazon VPC CNI
       	-- Amazon EKS Pod Identity Agent
       Go with the defaults and press "Next"

    h. In "Configure selected add-ons settings"
       Go with default and press "Next"
       Press "Next"

    i. In "Review and Create"
       Press "Create"

       W A I T    U P    T O    1 0     M I N      (for AWS to create it)

       -- Right now, we have a cluster with no nodes


 6. Finish configuring CNI Policy
    a. Get the OpenID Connect provider URL
       1) Configure your AWS CLI to talk to your new cluster
           unix> aws configure

	       	AWS Access Key ID:     <enter the first entry form the downloaded csv file>
    	   	AWS Secret Access Key: <enter the 2nd entry from the downloaded csv file>
       		Default region name:   us-east-2    (you get this from the AWS console, look next to your name and look at the default region)
       		Default output format  json

       2) Get the cluster info:
          unix> aws eks describe-cluster --name app16-cluster --query "cluster.identity.oidc.issuer" --output text
          https://oidc.eks.us-east-1.amazonaws.com/id/B97A5C56362F17113EA8F423213123DD0331B3A7
                                                                    ^
                                                                    |
                                                               ID FROM DESCRIBE CLUSTER
    b. Grant anyone in our account to EKS/VPC/CNI
       1) Go to IAM -> Roles
       2) Click on AmazonEKS_VPC_CNI_Role
       3) Click on "Trust relationships"
       4) Edit trust policy

          Replace the trust policy with this  (no tabs):
          Replace ID_FROM_DESCRIBE_CLUSTER with the value from the step above -- e.g., B97A5C56362F17113EA8F423213123DD0331B3A7
          REPLACE MY_REGION with us-east-1 (if needed)

{
    "Version": "2012-10-17",
    "Statement": [
    {
        "Effect": "Allow",
        "Principal": {
              "Federated": "arn:aws:iam::524647912468:oidc-provider/oidc.eks.MY_REGION.amazonaws.com/id/ID_FROM_DESCRIBE_CLUSTER"
         },
         "Action": "sts:AssumeRoleWithWebIdentity",
         "Condition": {
         "StringEquals": {
              "oidc.eks.MY_REGION.amazonaws.com/id/ID_FROM_DESCRIBE_CLUSTER:aud": "sts.amazonaws.com",
              "oidc.eks.MY_REGION.amazonaws.com/id/ID_FROM_DESCRIBE_CLUSTER:sub": "system:serviceaccount:kube-system:aws-node"
              }
            }
        }
   ]
}



     	5) Press "Update policy"



NOTE:  If you have multiple clusters, then you would have multiple statements:

{
    "Version": "2012-10-17",
    "Statement": [
    {
        "Effect": "Allow",
        "Principal": {
              "Federated": "arn:aws:iam::524647912468:oidc-provider/oidc.eks.us-east-1.amazonaws.com/id/ID_FROM_DESCRIBE_CLUSTER"
         },
         "Action": "sts:AssumeRoleWithWebIdentity",
         "Condition": {
         "StringEquals": {
              "oidc.eks.us-east-1.amazonaws.com/id/ID_FROM_DESCRIBE_CLUSTER:aud": "sts.amazonaws.com",
              "oidc.eks.us-east-1.amazonaws.com/id/ID_FROM_DESCRIBE_CLUSTER:sub": "system:serviceaccount:kube-system:aws-node"
              }
            }
        },

      {
        "Effect": "Allow",
        "Principal": {
              "Federated": "arn:aws:iam::524647912468:oidc-provider/oidc.eks.us-east-1.amazonaws.com/id/ID_FROM_DESCRIBE_CLUSTER"
         },
         "Action": "sts:AssumeRoleWithWebIdentity",
         "Condition": {
         "StringEquals": {
              "oidc.eks.us-east-1.amazonaws.com/id/ID_FROM_DESCRIBE_CLUSTER:aud": "sts.amazonaws.com",
              "oidc.eks.us-east-1.amazonaws.com/id/ID_FROM_DESCRIBE_CLUSTER:sub": "system:serviceaccount:kube-system:aws-node"
              }
            }
        }


   ]
}



			#       b. Make sure your subnets enable IP/hostname resolution
			#          1) Click on VPC -> Subnets
			#          2) Edit your 1st public subnet -> Action -> Edit Subnet settings
			#             Check "Enable auto-assign public IPv4 address"
			#             Press "Save"
			#
			#          3) Edit your 2nd public subnet -> Action -> Edit Subnet settings
			#             Check "Enable auto-assign public IPv4 address"
			#             Press "Save"
			#
			#          4) Edit your 1st public subnet -> Action -> Edit Subnet settings
			#             Check "Enable auto-assign public IPv4 address"
			#             Press "Save"




    c. Make sure the subnets have the correct TAGS using these rules
       NOTE:  This is needed so that auto-discovery works and the load balancer can get a public IP
       1) Click on VPC -> Subnets
       2) Click on the 1st private subnet
       3) Press on the "Tags" tab
       4) Press "Manage tags"
       5) Press "Add new tag"

		  key:   kubernetes.io/role/internal-elb
		  value: 1;

       Repeat this for all private subnets


       Rules for the tags
       ------------------
       Public Subnets should be resource tagged with:
          kubernetes.io/role/elb   1

       Private Subnets should be tagged with:
          kubernetes.io/role/internal-elb 1

       Public subnets should have:  if they are also used by non-EKS resources
          kubernetes.io/cluster/${your-cluster-name}: shared





 7. Create Kubernetes Node Group  (as dev.user)
	a. Go to AWS.com -> Elastic Kubernetes Services
	b. Click on app16-cluster
	c. Click on "Compute" tab
	d. Press "Add node group"
	e. In "Configure node group"
		   Name:           app16-node-group
		   Node IAM Role:  eksNodeRole
		   Press "Next"

	f. In "Node group compute configuration"
	   AMI Type:       Amazon Linux 2 (AL2_x86_64)
	   Capacity Type:  On-Demand                        (in DOD, we would have reserved instances)
	   Instance types  t2.medium
	   Disk size:      20 GiB

	   In Node group scaling configuration         (at a minimum, you want 2 nodes as one of the nodes is running keycloak)
		 Desired Size:   2 nodes
		 Minimum size:   2 nodes
		 Maximum size:   2 nodes         (so the whole kubernetes env is run on a SINGLE server)

	   In Node group update configuration   (this is the part of the auto-scaling features built into EKS)
	   -- Go with defaults

	   Pres "Next"


	g. In "Specify Networking"
	   1) Select the private subnets **ONLY**
	   2) Select "Configure remote access to nodes"
		  -- In the warning, press "Enable"
		  -- EC2 Key pair:                  Select app16-kubernetes-nodes-keypair
		  -- Allow remote access from:
		  		-- Selected Security groups
		  		-- Select ssh-from-bastion-host-security-group
		  		-- select default vpc security group


	h. In "Review and Create"
	   Press "Create"

		NOTE:  At this point, I'm being charged for the t2.medium nodes   (which costs $2/day)


	i. W A I T      U P    T O       2      M I N       F O R     A W S    (to create the node group)


	j. While waiting, set the name of one of the instances to be keycloak-instance
	   a. Go to the EC2 Dashboard -> instances
	   b. In the name row, press the "Edit" icon and enter keycloak-instance for one of them


	k. Add the default security group to ALL of our running instance
	   a. Go to EC2 -> Instances
	   b. Check the checkbox next to our running instance
	   c. Selection Actions -> Security -> Change security groups
	   d. In "Associated security groups"
		  Search for default
		  Add it to the list
		  NOTE:  Press "Add Security Group"
		  press "Save"

    l. Grant the allow-ssh-from-public-bastion security group to the other kubernetes nodes
         2) Click on the keycloak-instance
         3) Click on Actions -> Security -> Change Security
         4) In the Associated security groups:
         	  -- Search for default
         	  -- Press "Add security group"
         5) Press "Save"




 8. Finish configuring the "bastion host"
	a. Grant the public bastion ssh access to the other kubernetes nodes
	   1) Go to EC2 -> Instances
       2) Click on the bastion-host
       3) Click on Actions -> Security -> Change Security
       4) In the Associated security groups:
       	  -- Search for default
       	  -- Press "Add security group"
       5) Press "Save"

	b. Get the internal IP address of the keycloak-instance
	   1) Go to EC2 -> Instances
       2) Click on the keycloak-instance
          -- Get the private IPv4 of this keycloak instance -- e.g., 10.0.139.167

	c. Get the public IP address of the bastion-host
	   1) Go to EC2 -> Instances
       2) Click on the bastion-host
          -- Get the public IPv4 of this keycloak instance -- e.g., 44.97.169.72

	d. Upload the app16-bastion-host-keypair.pem to the "bastion host"
	   unix> scp -i ~/Downloads/app16-bastion-host-keypair.pem ~/Downloads/app16-bastion-host-keypair.pem   ec2-user@ec2-44-197-169-72.compute-1.amazonaws.com:/tmp

    e. Move the pem file from /tmp to the home directory and reduce privileges on it
	   1) ssh to the bastion host
	      unix> ssh -i ~/Downloads/app16-bastion-host-keypair.pem ec2-user@ec2-44-197-169-72.compute-1.amazonaws.com

       2) On the bastion host run these commands:
          bastion-host> mv /tmp/app16-bastion-host-keypair.pem .
          bastion-host> chmod go-rwx app16-bastion-host-keypair.pem

	f. Attempt to ssh from the "bastion host" to the "keycloak instance"
	   bastion-host> ssh -i app16-bastion-host-keypair.pem 10.0.139.167
	   -- This should work successfully!!




 9. Update the yum packages of the running instance
    a. SSH to the bastion host
       unix> ssh -i ~/Downloads/app16-bastion-host-keypair.pem ec2-user@ec2-44-197-169-72.compute-1.amazonaws.com

    b. From the bastion host, ssh to the keycloak-instance
       bastion-host> ssh -i app16-bastion-host-keypair.pem 10.0.139.167

    c. On the keycloak instance, update the files
       keycloak-instance>  sudo yum update

    d. Install the telnet client (it's handy)
       keycloak-instance-host> sudo yum install telnet

    e. Install the nslookup command
       keycloak-instance-host> sudo yum install bind-utils




10. Initialize AWS-hosted resources (exist outside of the kubernetes cluster)   (as dev.user)
    NOTE:  postgres and OpenSearch do not run inside kubernetes
    a. Create the keycloak database
       1) In AWS, search for RDS / Select RDS   (as dev.user)
       2) Select Databases -> Press "Create database"
       3) In "Create database"
          Database creation method:  Standard create
          Engine type:               PostgreSQL
          Engine version:            PostreSQL 14.7-R1
          Templates:                 Dev/Test
          Availability:              Single DB Instance

          Settings
             DB Instance identifier     keycloak-database          NOTE:  This is not the same as the database name
             Master username:           keycloak_user
             Master password            secret123

          Instance configuration
             DB Instance class:             Burstable / db.t3.micro
             Include previous gen classes:  Unchecked

          Storage
             Storage Type:                General Purpose SSD (gp2)
             Allocated storage:           20 GB
             Enable storage autoscaling:  Unchecked

		  Connectivity:
		     Compute Resource:               Don't Connect to an EC2 computer resource
		     VPC:                            <Choose default option called project-vpc>
		     DB Subnet Group:                <choose default option to create new DB subnet group>
		     Public Access:                  No   (you can only access this database from inside the cluster)
		     Existing VPC Security Groups:   <Select default VPC>
             Additional VPC security group:  Empty

                                             NOTE:  If I want to make the database open to all, set the VPC security group to include "Default"

          Additional Configuration:
             Database Port:                  5432
             Initial database name:          keycloak_db

          Database authentication:           Password authentication

          Monitoring:
            Uncheck "Turn on Performance Insights"
            Uncheck "Enable enhanced monitoring"

          Additional Configuration
            Uncheck "Enable automated backups"
            Check   "Enable encryption"

          Maintenance
            Uncheck "Enable auto minor version upgrade"

          Press "Create database"


    b. Create the app database
       1) In AWS, search for RDS / Select RDS   (as dev.user)
       2) Select Databases -> Press "Create database"
       3) In "Create database"
          Database creation method:  Standard create
          Engine type:               PostgreSQL
          Engine version:            PostreSQL 14.7-R1
          Templates:                 Dev/Test
          Availability:              Single DB Instance

          Settings
             DB Instance identifier     app-database
             Master username:           app_user
             Master password            secret12

          Instance configuration
             DB Instance class:              Burstable / db.t3.micro
             Include previous gen classes:   Unchecked

          Storage
             Storage Type:                   General Purpose SSD (gp2)
             Allocated storage:              20 GB
             Enable storage auto-scaling:    Unchecked

		  Connectivity:
		     Compute resource:               Don't connect to an EC2 compute resource
		     Network type:                   IPv4
		     VPC:                            <Choose default VPC / project-vpc>
		     DB Subnet Group:                <choose default subnet>
		     Public Access:                  No   (you can only access this database from inside the cluster)
		     Existing VPC Security Groups:   <Select default VPC>
             Additional VPC security group:  Empty

          Additional Configuration:
             Database Port:                   5432
             Initial database name:           app_db

          Database authentication:           Password authentication

          Monitoring:
            Uncheck "Turn on Performance Insights"
            Uncheck "Enable enhanced monitoring"

          Additional Configuration
            Uncheck "Enable automated backups"
            Check   "Enable encryption"

          Maintenance
            Uncheck "Enable auto minor version upgrade"

          Press "Create database"



    c. Setup OpenSearch
       1) In AWS -> Amazon OpenSearch Service   (as dev.user)
       2) Press "Create domain"
          In "Create domain"
             Domain Name:               app-opensearch

             Domain creation method:    standard create

             Templates:
                 choose Dev/Test

             Deployment Option(s)
                 choose Domain without standby
                 Availability zones:  1-AZ


             Engine Options
                 Version:            ElasticSearch 7.10

             Data nodes:
                 Instance Type:             t3.small.search
                 Number of nodes:           3

                 Storage Type:              EBS   (Elastic Block Store)
                 EBS Volume Type:           gp3         NOTE:  gp3 is faster than gp2
                 EBS Storage size per node   10

                 Total Provisioned IPOS:        <default of 3000>
                 Total Provisioned Throughput   <default of 125 MiB/s>


             Dedicated master nodeS:
                Enable Dedicated master nodes:       Unchecked


             Custom endpoint:
                Enable automatic software update:    Unchecked

             Network
                Network:                       Check VPC access
                VPC:                           Select default vpc
                Subnets:                       Select public1-us-east-2a   (if you select 1 availability zone, then you can only select 1 subnet)
                Security groups:               Select default

             Fine-grained access Control
                Fine-grained access control:   Checked
                Create master user:            Checked
                   master username:            es_user                # This must match the production application.yaml es.authentication.principal
                   master password:            Secret1@               # This must match the production application.yaml es.authentication.password

             Access Policy:
                Choose                         Do not set domain level access policy

             Press "Create"

             W A I T        U P         T O        1 0     M I N U T E S    (for AWS to create the OpenSearch domain)


           3. Select Action -> Edit Security Configuration
              In "Access Policy"
                 Domain Access policy:    Select "Configure domain level access policy"
                 Change the JSON
                 -- Change the Access policy from "Effect" : "Deny" to "Allow"

              When finished, it looks something like this:

				{
				  "Version": "2012-10-17",
				  "Statement": [
					{
					  "Effect": "Allow",
					  "Principal": {
						"AWS": "*"
					  },
					  "Action": "es:*",
					  "Resource": "arn:aws:es:us-east-2:524647912468:domain/app-opensearch/*"
					}
				  ]
				}



      d. Label instances (if you haven't)
		 1. Click EC2 -> Instances
		 2. Edited one of the instance name and changed it to keycloak
		 3. Edited one of the instance name and changed it to kubernetes-nodes



11. Create a persistent volume and mount to /opt/shared-storage on the keycloak server
    a. Create a 1 GB volume to hold your root CA
       1) Go to EC2 -> Elastic Block Store -> Volumes
       2) Press "Create volume"
       3) In the Create volume page
          Volume Type:  gp2
          Size:         1 GiB
          Avail Zone:   us-east-2a   (MUST be the same avail zone as the keycloak instance)

          Encryption:
              Check     Encrypt this volume
              KMS Key:  (default) aws/ebs

          Press "Create volume"

       4) Edit the name by pressing the "Edit Name" icon
          Set the name to root-ca-volume

           W A I T      F O R     V O L U M E    (to have volume state of Available)


       5) Check root-ca-volume / Press Action -> Attach Volume
          In Attach Volume
             Instance:      keycloak-instance
             Device name:   /dev/sdf
             Press "Attach volume"

    b. Mount the volume on the keycloak instance
       1) ssh to the keycloak instance
          unix>  ssh -i ~/.ssh/app16-kubernetes-nodes-keypair.pem ec2-user@18.216.9.38

          unix> sudo -s

          unix> blkid
          /dev/nvme0n1: PTUUID="a6d61325-cce9-40a3-9641-505d99880dad" PTTYPE="gpt"
          /dev/nvme0n1p1: LABEL="/" UUID="3d8d838a-1b85-4e10-998a-9c75e2db6bb5" TYPE="xfs" PARTLABEL="Linux" PARTUUID="aadbad73-5001-4740-bef3-91fdd10bf481"
          /dev/nvme0n1p128: PARTLABEL="BIOS Boot Partition" PARTUUID="8f239cbd-881f-4180-935b-c2b6d3b900ab"

          unix> lsblk

          NAME          MAJ:MIN RM SIZE RO TYPE MOUNTPOINT
          nvme0n1       259:0    0  20G  0 disk
          ├─nvme0n1p1   259:1    0  20G  0 part /
          └─nvme0n1p128 259:2    0   1M  0 part
          nvme1n1       259:3    0   1G  0 disk                <--- this is our new disk


        3) Format the disk
           unix> mkfs -t xfs /dev/sdf         # format the disk

        4) Get the UUID of the new partition
          unix> blkid
          /dev/nvme0n1p1: LABEL="/" UUID="3d8d838a-1b85-4e10-998a-9c75e2db6bb5" TYPE="xfs" PARTLABEL="Linux" PARTUUID="aadbad73-5001-4740-bef3-91fdd10bf481"
          /dev/nvme0n1: PTUUID="a6d61325-cce9-40a3-9641-505d99880dad" PTTYPE="gpt"
          /dev/nvme0n1p128: PARTLABEL="BIOS Boot Partition" PARTUUID="8f239cbd-881f-4180-935b-c2b6d3b900ab"
          /dev/nvme1n1: UUID="5fcf5339-921c-467c-829c-53e9a480bde7" TYPE="xfs"       <-- this is the new one

        5) Copy the UUID to the clipboard:   5fcf5339-921c-467c-829c-53e9a480bde7

        6) Create the mount point
           unix> mkdir /opt/shared-storage

        7) Add the mount point to the file system tab
           unix> vi /etc/fstab

            It should hold this:
              UUID=3d8d838a-1b85-4e10-998a-9c75e2db6bb5     /                   xfs    defaults,noatime  1   1

            Add a 2nd line with the new UUID
              UUID=3d8d838a-1b85-4e10-998a-9c75e2db6bb5     /                   xfs    defaults,noatime  1   1
              UUID=5fcf5339-921c-467c-829c-53e9a480bde7     /opt/shared-storage xfs    defaults,noatime  1   1

        8) Mount the filesystems
           unix> mount -a

        9) Verify it exists
           unix> df -h  /opt/shared-storage

			Filesystem      Size  Used Avail Use% Mounted on
			/dev/nvme1n1   1014M   40M  975M   4% /opt/shared-storage


12. Create our own certificate authority (for pki client certs)
    NOTE:  Install on the keycloak server to make life easier for you
    NOTE:  Install to the  /opt/shared-storage/root-ca    (so that if the instance is destroyed, then the root CA files are preserved)
    a. Create certificate authority (on the keycloak server)
       learnSSL / howToUseYourCertAuthority_InitialSetup_centos7.txt

    b. Create PKI Client cert #1 with john.smith.12345
       learnSSL / howToUseYourCertAuthority_MakeClientCert_centos7.txt
       NOTE:  Make the Common Name:  JOHN.SMITH.12345

    c. Create PKI client cert #2 with WILL.FRANKLIN.22222
       learnSSL / howToUseYourCertAuthority_MakeClientCert_centos7.txt
       NOTE:  Make the Common Name:  WILL.FRANKLIN.22222


13. Configure your local kubectl command to talk to our new Kubernetes cluster
    NOTE:  Kubernetes is running but there are no pods running at this time
    a. Download the kubectl command
       unix> cd /tmp
       unix> curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-latest.x86_64.rpm
       unix> sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl

       unix> which kubectl
       /usr/local/bin/kubectl

    b. Erase or move the existing .kube
       unix> mv ~/.kube ~/.kube-localhost

    c. Run aws configure to login as the dev.user   (you will need the dev.user_accessKeys.csv)
       unix> aws configure
       AWS Access Key ID [****************GZ7M]:         <enter the key from the dev.user_accessKeys.csv)
       AWS Secret Access Key [****************DeDp]      <enter the key from the dev.user_accessKeys.csv)
       Default region name [us-gov-west-1]:              <enter>
       Default output format [json]:                      <enter>

    d. Setup kubectl to be configured with your AWS cluster
       unix> export AWS_REGION=$(aws ec2 describe-availability-zones --output text --query 'AvailabilityZones[0].[RegionName]')
       unix> export MY_CLUSTER=app16-cluster
       unix> aws eks update-kubeconfig --region $AWS_REGION --name $MY_CLUSTER
       *OR*
       unix> aws eks update-kubeconfig --region us-east-1  --name app16-cluster

       AT THIS POINT, the kubectl command works!!!!!


    e. Verify that you can see the running nodes
       unix> kubectl get nodes

       NAME                                          STATUS   ROLES    AGE     VERSION
       ip-172-31-42-143.us-east-2.compute.internal   Ready    <none>   4h16m   v1.25.6-eks-48e63af

    f. List existing services
       unix> kubectl get services

       NAME         TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE
       kubernetes   ClusterIP   10.100.0.1   <none>        443/TCP   4h37m



14. Get the aws external hostname for keycloak and the app's loadbalancer
    Keycloak will run locally in your running node
    Keycloak's public IP will be the same as the running node's public IP
    a. Get keycloak's external hostname
       1) Go to AWS -> EC2 -> instances
       2) Check the checkbox for the running instance that is the keycloak server
       3) Get the Public IPv4 DNS
          ec2-160-1-14-243.us-gov-west-1.compute.amazonaws.com

    b. For now, the app's real external hostname is not known -- so we hard code it



15. Register the domain "keycloak.traderres.com" to refer to the public hostname of the AWS keycloak instance
    a. Get the public hostname of the keycloak instance
       1) AWS.com -> EC2 -> Instances
       2) Click on the keycloak-instance
       3) Get the public IPv4 DNS -- e.g., ec2-18-216-9-38.us-east-2.compute.amazonaws.com

    b. Use goDaddy to register the above public IPv4 DNS ("ec2-18-216-9-38.us-east-2.compute.amazonaws.com") with a CNAME of keycloak.traderres.com
       1) Login to goDaddy.com
       2) Go to My Account -> My Products
       3) Click on the "Domain" link for traderres.com
       4) Click "View Domain Settings"
          *or
          https://dcc.godaddy.com/control/traderres.com/settings

       5) In the menu select DNS -> Manage Zones
       6) Click on "View traderres.com"
       7) Under DNS Records, press "Add New Record"
          Type:   CNAME
          Name:   keycloak
          Value   ec2-18-216-9-38.us-east-2.compute.amazonaws.com             (this is the public IPv$ DNS of the keycloak instance)
          TTL:    Default

    c. Verify that keycloak.traderres.com is found in a DNS lookup
       unix> nslookup keycloak.traderres.com

       Non-authoritative answer:
       keycloak.traderres.com	canonical name = ec2-160-1-14-243.us-gov-west-1.compute.amazonaws.com.
       Name:	ec2-18-216-9-38.us-east-2.compute.amazonaws.com
       Address: 18.216.9.38


	d. Use godaddy to register the *SAME* name used by keyclock (ec2-160-1-14-243.us-gov-west-1.compute.amazonaws.com) with a CNAME of app.traderres.com
	   NOTE:  THIS IS TEMPORARY -- we will replace it with the real name later on
	          WE ARE DOING THIS JUST TO GET THE APP'S SERVER CERT
		1) Login to godaddy.com
		2) Go to My Account -> My Products
		3) Click on the "Domain" link for traderres.com
		4) Click "View Domain Settings"
		   *or
		   https://dcc.godaddy.com/control/traderres.com/settings

		5) In the menu select DNS -> Manage Zones
		6) Click on "View traderres.com"
		7) Under DNS Records, press "Add New Record"
		   Type:   CNAME
		   Name:   app
		   Value   ec2-18-216-9-38.us-east-2.compute.amazonaws.com              (yes, this is the public IPv$ DNS of the keycloak instance, too -- for now!!)
		   TTL:    Default


    d. Verify that app.traderres.com is found in a DNS lookup
       unix> nslookup app.traderres.com

	   Non-authoritative answer:
	   app.traderres.com	canonical name = ec2-18-216-9-38.us-east-2.compute.amazonaws.com
       Name:	ec2-18-216-9-38.us-east-2.compute.amazonaws.com
       Address: 18.216.9.38



16. Create server certs with Let's Encrypt for the load-balancer (app.traderres.com) and keycloak (keycloak.traderres.com)
 	a. Install certbot
  	   unix> sudo dnf install python3-pip python3-pyOpenSSL
       unix> pip install certbot
       unix> pip install certbot-dns-route53     # if using Amazon Route 53 for hostnames

    b. Verify it it installed
       unix> which certbot
       /usr/local/bin/certbot



 	If using Amazon Route 53, follow these steps:
    ---------------------------------------------
    Grant these roles to the ec-instance that has these files
		route53:ListHostedZones
		route53:GetChange
		route53:ChangeResourceRecordSets

			1) get your hosted zone id
			   a) Go to the Route 53 service
			   b) Look at your hostez one, at the end, you will see the "Hosted zone ID"

			2) Go to Roles -> EC2_OS_RDS_FullAccess role  (that's already being applied to the ec2 nodes)

			3) Select "Add permissions" -> Create inline policy

			4) Select JSON

			5) Replace the json with this:

				{
					"Version": "2012-10-17",
					"Id": "certbot-dns-route53 sample policy",
					"Statement": [
						{
							"Effect": "Allow",
							"Action": [
								"route53:ListHostedZones",
								"route53:GetChange"
							],
							"Resource": [
								"*"
							]
						},
						{
							"Effect" : "Allow",
							"Action" : [
								"route53:ChangeResourceRecordSets"
							],
							"Resource" : [
								"arn:aws:route53:::hostedzone/YOURHOSTEDZONEID"
							]
						}
					]
				}


			   Press "Next"

			6) Policy Name is certbot-dns-route-53-policy

			7) Use certbot to generate & download a valid "Let's Encrypt" server certificate for keycloak.rbr-tech.us  [good for 90 days]
               WARNING: Make sure the CNAME record exists already in Amazon Route 53
	  	  	   unix> sudo certbot certonly --dns-route53 -d keycloak.rbr-tech.us --config-dir /opt/shared-storage/certbot/

					Saving debug log to /var/log/letsencrypt/letsencrypt.log
					Enter email address (used for urgent renewal and security notices)
					 (Enter 'c' to cancel): mgoldman@rbr-tech.com

					- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
					Please read the Terms of Service at
					https://letsencrypt.org/documents/LE-SA-v1.3-September-21-2022.pdf. You must
					agree in order to register with the ACME server. Do you agree?
					- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
					(Y)es/(N)o: Y

					- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
					Would you be willing, once your first certificate is successfully issued, to
					share your email address with the Electronic Frontier Foundation, a founding
					partner of the Let's Encrypt project and the non-profit organization that
					develops Certbot? We'd like to send you email about our work encrypting the web,
					EFF news, campaigns, and ways to support digital freedom.
					- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
					(Y)es/(N)o: N

					Account registered.
					Requesting a certificate for keycloak.rbr-tech.us

					Successfully received certificate.
					Certificate is saved at: /opt/shared-storage/certbot/live/keycloak.rbr-tech.us/fullchain.pem
					Key is saved at:         /opt/shared-storage/certbot/live/keycloak.rbr-tech.us/privkey.pem
					This certificate expires on 2024-03-19.
					These files will be updated when the certificate renews.

					NEXT STEPS:
					- The certificate will need to be renewed before it expires. Certbot can automatically renew the certificate in the background, but you may need to take steps to enable that functionality. See https://certbot.org/renewal-setup for instructions.

					- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
					If you like Certbot, please consider supporting our work by:
					 * Donating to ISRG / Let's Encrypt:   https://letsencrypt.org/donate
					 * Donating to EFF:                    https://eff.org/donate-le
					- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

            8) Use certbot to generate & download a valid "Let's Encrypt" server certificate for app.rbr-tech.us  [good for 90 days]
               WARNING: Make sure the CNAME record exists already in Amazon Route 53
               unix> sudo certbot certonly --dns-route53 -d app.rbr-tech.us --config-dir /opt/shared-storage/certbot/

					Requesting a certificate for app.rbr-tech.us

					Successfully received certificate.
					Certificate is saved at: /opt/shared-storage/certbot/live/app.rbr-tech.us/fullchain.pem
					Key is saved at:         /opt/shared-storage/certbot/live/app.rbr-tech.us/privkey.pem
					This certificate expires on 2024-03-19.
					These files will be updated when the certificate renews.

					NEXT STEPS:
					- The certificate will need to be renewed before it expires. Certbot can automatically renew the certificate in the background, but you may need to take steps to enable that functionality. See https://certbot.org/renewal-setup for instructions.

					- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
					If you like Certbot, please consider supporting our work by:
					 * Donating to ISRG / Let's Encrypt:   https://letsencrypt.org/donate
					 * Donating to EFF:                    https://eff.org/donate-le
					- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -



			9) Verify that your certbot/ directory looks like this:
               unix> find /opt/shared-storage/certbot -type f -print

			   You should have these files in the /opt/shared-storage/certbot/ directory
					/opt/shared-storage/certbot/accounts/acme-v02.api.letsencrypt.org/directory/4dc21346094c35daea7627d65a5b389c/private_key.json
					/opt/shared-storage/certbot/accounts/acme-v02.api.letsencrypt.org/directory/4dc21346094c35daea7627d65a5b389c/meta.json
					/opt/shared-storage/certbot/accounts/acme-v02.api.letsencrypt.org/directory/4dc21346094c35daea7627d65a5b389c/regr.json
					/opt/shared-storage/certbot/renewal/keycloak.rbr-tech.us.conf
					/opt/shared-storage/certbot/renewal/app.rbr-tech.us.conf
					/opt/shared-storage/certbot/archive/keycloak.rbr-tech.us/cert1.pem
					/opt/shared-storage/certbot/archive/keycloak.rbr-tech.us/privkey1.pem
					/opt/shared-storage/certbot/archive/keycloak.rbr-tech.us/chain1.pem
					/opt/shared-storage/certbot/archive/keycloak.rbr-tech.us/fullchain1.pem
					/opt/shared-storage/certbot/archive/app.rbr-tech.us/cert1.pem
					/opt/shared-storage/certbot/archive/app.rbr-tech.us/privkey1.pem
					/opt/shared-storage/certbot/archive/app.rbr-tech.us/chain1.pem
					/opt/shared-storage/certbot/archive/app.rbr-tech.us/fullchain1.pem
					/opt/shared-storage/certbot/live/README
					/opt/shared-storage/certbot/live/keycloak.rbr-tech.us/README
					/opt/shared-storage/certbot/live/app.rbr-tech.us/README




   	If using GoDaddy, follow these steps
    ------------------------------------
    a. Create API keys in godaddy.com
       WARNING:  When creating the API key, this is the ONLY moment you can view the "secret" and the "key"

       1) Go to https://developer.godaddy.com/
       2) Login with your godaddy account
       3) Click on API keys
          *OR*
          https://developer.godaddy.com/keys
       4) Create New API Key
       5) In the popup
          Give it a name
          Select production
          Press "Next"
       6) Copy the "key" and "secret" values
          -- Double click on the key
          -- Right-click on the key    -> Copy  -> Paste into a temporary file

          -- Double click on the secret
          -- Right-click on the secret -> Copy  -> Paste into a temporary file

          NOTE:  You will **NOT** get another change to view the key and secret values -- so get it right now!!


    b. Set the "key" and "secret" values in the authenticate.sh script
       1) SSH to the kubernetes instance that will hold keycloak, certbot, and our root CA
          unix> ssh -i ~/.ssh/app16-kubernetes-nodes-keypair.pem ec2-user@18.218.246.201

       2) Download the authenticate.sh script:
          unix> sudo -s
          unix> mkdir /opt/shared-storage/certbot
          unix> cd    /opt/shared-storage/certbot
          unix> wget https://raw.githubusercontent.com/traderres/webClass/master/learnAWS/authenticate.sh
          unix> chmod ugo+x ./authenticate.sh        # Make sure this script is executable

       2) Modify the authenticate.sh
          unix> vi authenticate.sh

          Change these values
             GODADDY_API_KEY="go-daddy-api-key-is-here"
             GODADDY_API_SECRET="go-daddy-secret-value-is-here"



    c. Use certbot to generate & download a valid "Let's Encrypt" server certificate for keycloak.traderres.com    [good for 90 days]
       NOTE:  this command uses the authenticate.sh script to verify that the dns entry is valid
       unix> certbot certonly --manual --preferred-challenges dns --manual-auth-hook /opt/shared-storage/certbot/authenticate.sh --config-dir /opt/shared-storage/certbot/ -d keycloak.traderres.com

       NOTE:  First time, you will be prompted for your email address
       	    Enter email address (used for urgent renewal and security notices)
			- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			Please read the Terms of Service at
			https://letsencrypt.org/documents/LE-SA-v1.3-September-21-2022.pdf. You must
			agree in order to register with the ACME server. Do you agree?
			- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			(Y)es/(N)o: Y

			- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			Would you be willing, once your first certificate is successfully issued, to
			share your email address with the Electronic Frontier Foundation, a founding
			partner of the Let's Encrypt project and the non-profit organization that
			develops Certbot? We'd like to send you email about our work encrypting the web,
			EFF news, campaigns, and ways to support digital freedom.
			- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
			(Y)es/(N)o: N


       You should see this:
		   Successfully received certificate.
		   Certificate is saved at: /opt/shared-storage/certbot/live/keycloak.traderres.com/fullchain.pem
		   Key is saved at:         /opt/shared-storage/certbot/live/keycloak.traderres.com/privkey.pem
		   This certificate expires on 2023-06-19.
		   These files will be updated when the certificate renews.
		   Certbot has set up a scheduled task to automatically renew this certificate in the background.


    d. Delete the TXT record in goDaddy or wait 600 seconds
       a. Go to https://dcc.godaddy.com/control/portfolio/traderres.com/settings
       b. Click on the DNS tab
       c. Delete the TXT _acme-challenge.app record


    e. Use certbot to generate & download a valid "Let's Encrypt" server certificate for app.traderres.com  [good for 90 days]
       unix> certbot certonly --manual --preferred-challenges dns --manual-auth-hook /opt/shared-storage/certbot/authenticate.sh --config-dir /opt/shared-storage/certbot/ -d app.traderres.com

       You should see this:
			Successfully received certificate.
			Certificate is saved at: /opt/shared-storage/certbot/live/app.traderres.com/fullchain.pem
			Key is saved at:         /opt/shared-storage/certbot/live/app.traderres.com/privkey.pem
			This certificate expires on 2023-06-19.
			These files will be updated when the certificate renews.
			Certbot has set up a scheduled task to automatically renew this certificate in the background.


    f. Delete the TXT record in goDaddy or wait 600 seconds
       a. Go to https://dcc.godaddy.com/control/portfolio/traderres.com/settings
       b. Click on the DNS tab
       c. Delete the TXT _acme-challenge.app record


    g. Verify that your certbot/ directory looks like this:
       unix> find /opt/shared-storage/certbot -type f -print

       You should have these files in the /opt/shared-storage/certbot/ directory
			/opt/shared-storage/certbot/authenticate.sh
			/opt/shared-storage/certbot/accounts/acme-v02.api.letsencrypt.org/directory/4b4f5f634e7e0c48cf7f298860071d98/private_key.json
			/opt/shared-storage/certbot/accounts/acme-v02.api.letsencrypt.org/directory/4b4f5f634e7e0c48cf7f298860071d98/meta.json
			/opt/shared-storage/certbot/accounts/acme-v02.api.letsencrypt.org/directory/4b4f5f634e7e0c48cf7f298860071d98/regr.json
			/opt/shared-storage/certbot/renewal/keycloak.traderres.com.conf
			/opt/shared-storage/certbot/renewal/app.traderres.com.conf
			/opt/shared-storage/certbot/archive/keycloak.traderres.com/cert1.pem
			/opt/shared-storage/certbot/archive/keycloak.traderres.com/privkey1.pem
			/opt/shared-storage/certbot/archive/keycloak.traderres.com/chain1.pem
			/opt/shared-storage/certbot/archive/keycloak.traderres.com/fullchain1.pem
			/opt/shared-storage/certbot/archive/app.traderres.com/cert1.pem
			/opt/shared-storage/certbot/archive/app.traderres.com/privkey1.pem
			/opt/shared-storage/certbot/archive/app.traderres.com/chain1.pem
			/opt/shared-storage/certbot/archive/app.traderres.com/fullchain1.pem
			/opt/shared-storage/certbot/live/README
			/opt/shared-storage/certbot/live/keycloak.traderres.com/README
			/opt/shared-storage/certbot/live/app.traderres.com/README



17. Install Java 17 JDK on the keycloak server  (keycloak needs Java 11 or later and we need the keytool command)
	 a. Download openJDK17 here:
		https://drive.google.com/file/d/1RMfDzutHZwIeUPRLL0SPFcxxO58H8wZr/view?usp=drive_link
		*OR*
		https://access.redhat.com/jbossnetwork/restricted/softwareDetail.html?softwareId=105840&product=core.service.openjdk&version=17.0.9&downloadType=distributions


	 b. Upload java-17-openjdk-17.0.9.0.9-1.portable.jdk.el.x86_64.tar.gz it to the /tmp directory

	 c. Unzip it to the /usr/java
		unix> sudo mkdir /usr/java
		unix> sudo tar -xvzf java-17-openjdk-17.0.9.0.9-1.portable.jdk.el.x86_64.tar.gz -C /usr/java/
		 -- Creates /usr/java/java-17-openjdk-17.0.9.0.9-1.portable.jdk.el.x86_64

	 d. Add it to the .bashrc
		unix> vi ~/.bashrc
			 export JAVA_HOME=/usr/java/java-17-openjdk-17.0.9.0.9-1.portable.jdk.el.x86_64
			 export PATH=${JAVA_HOME}/bin:$PATH


	 e. Add it to the /etc/sudoers  (so that root hsa it)
		unix> sudo vi /etc/sudoers

		Change line 88 so it ends with the java/bin
			 Defaults    secure_path = /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/var/lib/snapd/snap/bin:/usr/java/java-17-openjdk-17.0.9.0.9-1.portable.jdk.el.x86_64/bin



	 f. Verify that java is found for ec2-user
		unix> java -version
		openjdk version "17.0.9" 2023-10-17 LTS
		OpenJDK Runtime Environment (Red_Hat-17.0.9.0.9-1.el7openjdkportable) (build 17.0.9+9-LTS)
		OpenJDK 64-Bit Server VM (Red_Hat-17.0.9.0.9-1.el7openjdkportable) (build 17.0.9+9-LTS, mixed mode, sharing)

		unix> sudo -s
		unix> java -version
		openjdk version "17.0.9" 2023-10-17 LTS
		OpenJDK Runtime Environment (Red_Hat-17.0.9.0.9-1.el7openjdkportable) (build 17.0.9+9-LTS)
		OpenJDK 64-Bit Server VM (Red_Hat-17.0.9.0.9-1.el7openjdkportable) (build 17.0.9+9-LTS, mixed mode, sharing)





18. Create & install the keycloak certificates on the keycloak instance
    NOTE:  Keycloak Server has Java 11 JDK's keytool
           If your development env uses an older Java JDK, then build the cert with the older Java JDK

    We need to install the files to here:
        /opt/keycloak/keycloak.keystore.jks
        /opt/keycloak/keycloak.truststore.jks

        ASSUMPTIONS:
           1) Your root-ca is on the keycloak server in /opt/shared-storage/root-ca

           2) Your certbot is on the keycloak server in /opt/shared-storage/certbot
                 And, so you have server cert files here:
                        /opt/shared-storage/certbot/archive/app.traderres.com/
                        /opt/shared-storage/certbot/archive/keycloak.traderres.com/

                 If you are not running certbot on the keycloak server, then you need to upload files to
                        /opt/shared-storage/certbot/archive on the keycloak server

                        Upload the files from my box to this keycloak server box
                        unix> cd ~/certbot
       					unix> scp  -i ~/.ssh/app16-kubernetes-nodes-keypair.pem  -r /opt/shared-storage/certbot/archive ec2-user@18.218.246.201:/tmp


    a. Create the keycloak keystore (keycloak.keystore.jks)
       1) SSH to the kubernetes instance that will hold keycloak, certbot, and our root CA
          unix> ssh -i ~/.ssh/app16-kubernetes-nodes-keypair.pem ec2-user@18.218.246.201

        2) Examine the 3 files that makeup the full chain / Split the full-chain into 3 files / Find the server cert
           NOTE:  The server cert has this:
                        CN=keycloak.traderres.com

		   unix> sudo -s
           unix> cd /opt/shared-storage/certbot/archive/keycloak.traderres.com
           unix> cat fullchain1.pem | awk 'BEGIN {n=1};  split_after==1{n++;split_after=0} /-----END CERTIFICATE-----/ {split_after=1} {print > "fullchainkc" n ".pem"}'
                 -- Now, you have 3 new files:  fullchainkc1.pem, fullchainkc2.pem, fullchainkc3.pem

		   unix> openssl x509 -in fullchainkc1.pem -noout -text | grep 'keycloak.traderres.com'     # This one holds the server cert if you see CN=keycloak.traderres.com
		   unix> openssl x509 -in fullchainkc2.pem -noout -text | grep 'keycloak.traderres.com'
		   unix> openssl x509 -in fullchainkc3.pem -noout -text | grep 'keycloak.traderres.com'

        3) Generate the server.p12 file from the server cert
           unix> export SERVER_CRT=fullchainkc1.pem    # holds the cert that has CN=keycloak.traderres.com
		   unix> export SERVER_KEY=privkey1.pem
		   unix> export INTERMEDIATE_CA=fullchainkc2.pem
           unix> openssl pkcs12 -export -in $SERVER_CRT -inkey $SERVER_KEY -out server.p12 -name 'my-server-cert' -CAfile $INTERMEDIATE_CA -caname root
                 Enter Export Password: changeit
                 Verify Password:       changeit

        4) Convert the server.p12 into keycloak.keystore.jks
           unix> mkdir -p /opt/keycloak
           unix> rm -f /opt/keycloak/keycloak.keystore.jks
           unix> keytool -importkeystore -deststorepass changeit -destkeypass changeit -destkeystore /opt/keycloak/keycloak.keystore.jks  -srckeystore server.p12 -srcstoretype PKCS12 -srcstorepass changeit -alias 'my-server-cert'

        5) Import the 3 pem files into the keycloak.keystore.jks
           unix> keytool -import -alias "keycloak1"  -keystore /opt/keycloak/keycloak.keystore.jks  -file fullchainkc1.pem    -srcstorepass changeit  -deststorepass changeit    # If it's already imported, then don't bother
           unix> keytool -import -alias "keycloak2"  -keystore /opt/keycloak/keycloak.keystore.jks  -file fullchainkc2.pem    -srcstorepass changeit  -deststorepass changeit
           unix> keytool -import -alias "keycloak3"  -keystore /opt/keycloak/keycloak.keystore.jks  -file fullchainkc3.pem    -srcstorepass changeit  -deststorepass changeit


    d. Generate the keycloak truststore (keycloak.truststore.jks)
       truststore needs to include the godaddy CA used for keycloak.traderres.com and intermediate CA
       truststore needs to include the self-signed CA used for PKI clients   (no intermediate)
       unix> rm -f /opt/keycloak/keycloak.truststore.jks
       unix> cd /opt/shared-storage/certbot/archive/keycloak.traderres.com
       unix> keytool -import -alias "keycloak1"  -keystore /opt/keycloak/keycloak.truststore.jks  -file fullchainkc1.pem  -storepass changeit
       unix> keytool -import -alias "keycloak2"  -keystore /opt/keycloak/keycloak.truststore.jks  -file fullchainkc2.pem -storepass changeit
       unix> keytool -import -alias "keycloak3"  -keystore /opt/keycloak/keycloak.truststore.jks  -file fullchainkc3.pem  -storepass changeit
       unix> keytool -import -alias "our-ca"     -keystore /opt/keycloak/keycloak.truststore.jks  -file /opt/shared-storage/root-ca/public/root.pem  -storepass changeit


	   At this point, we have these 2 files:
	        /opt/keycloak/keycloak.keystore.jks
	        /opt/keycloak/keycloak.truststore.jks

    e. Copy the keycloak keystore & truststore files to /opt/shared-storage
       unix> mkdir -p /opt/shared-storage/keycloak
       unix> cp /opt/keycloak/keycloak.keystore.jks    /opt/shared-storage/keycloak
       unix> cp /opt/keycloak/keycloak.truststore.jks  /opt/shared-storage/keycloak



19. Initialize Keycloak as a service on the running instance
    NOTE:  Keycloak is a container running on the kubernetes instance
    a. SSH to the kubernetes instance that will hold keycloak, certbot, and our root CA
       unix> ssh -i ~/.ssh/app16-kubernetes-nodes-keypair.pem ec2-user@18.218.246.201

    b. Download keycloak 21.0.1 to the /opt/keycloak directory
       unix> sudo -s
       unix> cd /tmp
       unix> wget https://github.com/keycloak/keycloak/releases/download/21.0.1/keycloak-21.0.1.zip

    c. Install keycloak to the /opt/keycloak directory
       unix> mkdir -p /opt/keycloak
	   unix> unzip /tmp/keycloak-21.0.1.zip -d /opt/keycloak
       -- Now, you should have /opt/keycloak/keycloak-21.0.1

       unix> rm /tmp/keycloak-21.0.1.zip

    d. **OPTIONAL** Upload any jar files with custom key cloak themes to /opt/keycloak/keycloak-21.0.1/providers

    e. Build keycloak (as root)
       unix> cd /opt/keycloak/keycloak-21.0.1
       unix> bin/kc.sh build

    f. Create a keycloak user and group
       unix> groupadd keycloak
       unix> useradd keycloak -c "Mr Keycloak" -g "keycloak" -m

    g. Change ownership so that the /opt/keycloak directory is owned by the keycloak user
       unix> chown keycloak:keycloak -R /opt/keycloak

    h. Verify that keycloak runs from the command line
       NOTE:  Assumes that keycloak's default JRE is Java 11
              To find a version of java in your path
              unix> readlink -f `which java`

              If it's not, then adjust the /opt/keycloak/keycloak-21.0.1/bin/kc.sh and add these entries on line 2:
              unix> sudo -s
              unix> su - keycloak
              unix> vi /opt/keycloak/keycloak-21.0.1/bin/kc.sh

                   export JAVA_HOME=/usr/lib/jvm/java-11-openjdk-11.0.18.0.10-1.amzn2.0.1.x86_64       # REPLACE this with your real Java JDK 11 path
                   export PATH=${JAVA_HOME}/bin:$PATH
              unix> exit


       unix> sudo -s
       unix> su - keycloak
       unix> /opt/keycloak/keycloak-21.0.1/bin/kc.sh start --http-enabled=false --https-port=8444 --https-key-store-file=/opt/keycloak/keycloak.keystore.jks --https-key-store-type=JKS --https-key-store-password=changeit --https-trust-store-file=/opt/keycloak/keycloak.truststore.jks --https-trust-store-type=JKS --https-trust-store-password=changeit --https-client-auth=request --log-level=INFO --hostname-strict-https=false --hostname-strict=false --hostname=keycloak.traderres.com

       You should see this logging:
			2023-06-24 17:50:13,620 INFO  [org.keycloak.services] (main) KC-SERVICES0050: Initializing master realm
			2023-06-24 17:50:17,497 INFO  [io.quarkus] (main) Keycloak 21.0.1 on JVM (powered by Quarkus 2.13.7.Final) started in 18.572s. Listening on: https://0.0.0.0:8444
			2023-06-24 17:50:17,497 INFO  [io.quarkus] (main) Profile prod activated.
			2023-06-24 17:50:17,498 INFO  [io.quarkus] (main) Installed features: [agroal, cdi, hibernate-orm, jdbc-h2, jdbc-mariadb, jdbc-mssql, jdbc-mysql, jdbc-oracle, jdbc-postgresql, keycloak, logging-gelf, micrometer, narayana-jta, reactive-routes, resteasy, resteasy-jackson, smallrye-context-propagation, smallrye-health, vertx]


       Press Control-C to kill it




    i. Create a keycloak service
       unix> sudo -s
       unix> vi /etc/systemd/system/keycloak.service

		###################################################################################
		# Filename:  keycloak.service
		#
		# Purpose:
		#   Describe how the keycloak service runs
		#
		# Notes:
		#   If you update this file, then follow these steps:
		#   unix> sudo systemctl daemon-reload
		#   unix> sudo systemctl start keycloak
		#
		#   Look at the log
		#   unix> sudo journalctl -fu keycloak
		###################################################################################
		[Unit]
		Description=Keycloak Application Server
		After=syslog.target network.target
		StartLimitIntervalSec=1d
		StartLimitBurst=3

		[Service]
		Type=simple
		Restart=on-failure
		RestartSec=2s

		# Disable timeout logic and wait until process is stopped
		TimeoutStopSec=0

		# SIGTERM signal is used to stop the Java process
		KillSignal=SIGTERM

		# Send the signal only to the JVM rather than its control group
		KillMode=process
		User=keycloak
		Group=keycloak
		RemainAfterExit=yes
		LimitNOFILE=102642
		ExecStart=/opt/keycloak/keycloak-21.0.1/bin/kc.sh start --http-enabled=false --https-port=8444 --https-key-store-file=/opt/keycloak/keycloak.keystore.jks --https-key-store-type=JKS --https-key-store-password=changeit --https-trust-store-file=/opt/keycloak/keycloak.truststore.jks --https-trust-store-type=JKS --https-trust-store-password=changeit --https-client-auth=request --log-level=INFO --hostname-strict-https=false --hostname-strict=false --hostname=keycloak.traderres.com

		# Database Options
		Environment=KC_DB=postgres
		Environment=KC_DB_URL=jdbc:postgresql://keycloak.csbk2jnrc8ao.us-east-2.rds.amazonaws.com/keycloak_db
		Environment=KC_DB_USERNAME=keycloak_user
		Environment=KC_DB_PASSWORD=secret123

		[Install]
		WantedBy=multi-user.target


     j. Remove the leading spaces & tabs from this service script
        unix> sed -i -e 's/^[ \t]*//g' /etc/systemd/system/keycloak.service


     k. Update Database options in the /etc/systemd/system/keycloak.service to match the keycloak database in AWS
        a. Get the keycloak database hostname
           1) Go into AWS -> RDS -> Databases
           2) Click on the keyclaok-database
           3) In the "Connectivity & security" tab get the endpoint
              -- It should look something like this:  keycloak-database.csbk2jnrc8ao.us-east-2.rds.amazonaws.com

        b. Set the keycloak KC_DB_URL environment value in /etc/systemd/system/keycloak.service
           unix> vi /etc/systemd/system/keycloak.service

			Environment=KC_DB_URL=jdbc:postgresql://KEYCLOAK_DATABASE_PUBLIC_ENDPOINT/keycloak_db

            *OR*

            Environment=KC_DB_URL=jdbc:postgresql://keycloak-database.csbk2jnrc8ao.us-east-2.rds.amazonaws.com/keycloak_db



     l. Reload systemctl daemon
        unix> systemctl daemon-reload

     m. Start the service
        unix> systemctl start keycloak

     n. Look at the service log
        unix> journalctl -fu keycloak

     o. Verify that you can connect to keycloak
        Open a browser
        Connect to https://keycloak.traderres.com:8444/
        -- Provide a pki client cert that you created earlier
        -- The main page should say, "You need local access to create the initial admin user."


20. Configure keycloak's admin account
    a. Setup the admin account
       1) Stop keycloak
          SSH to the kubernetes instance that will hold keycloak, certbot, and our root CA
          unix> ssh -i ~/.ssh/app16-kubernetes-nodes-keypair.pem ec2-user@18.218.246.201
          unix> sudo -s
          unix> systemctl stop keycloak

       2) Set the admin username and password with ENV variables
          unix> vi /etc/systemd/system/keycloak.service

          Add these 2 environment variables

          		Environment=KEYCLOAK_ADMIN=keycloak
          		Environment=KEYCLOAK_ADMIN_PASSWORD=secret12


            When finished, the keycloak.service file should look like this:
			###################################################################################
			# Filename:  keycloak.service
			#
			# Purpose:
			#   Describe how the keycloak service runs
			#
			# Notes:
			#   If you update this file, then follow these steps:
			#   unix> sudo systemctl daemon-reload
			#   unix> sudo systemctl start keycloak
			#
			#   Look at the log
			#   unix> sudo journalctl -fu keycloak
			###################################################################################
			[Unit]
			Description=Keycloak Application Server
			After=syslog.target network.target
			StartLimitIntervalSec=1d
			StartLimitBurst=3

			[Service]
			Type=simple
			Restart=on-failure
			RestartSec=2s

			# Disable timeout logic and wait until process is stopped
			TimeoutStopSec=0

			# SIGTERM signal is used to stop the Java process
			KillSignal=SIGTERM

			# Send the signal only to the JVM rather than its control group
			KillMode=process
			User=keycloak
			Group=keycloak
			RemainAfterExit=yes
			LimitNOFILE=102642
			ExecStart=/opt/keycloak/keycloak-21.0.1/bin/kc.sh start --http-enabled=false --https-port=8444 --https-key-store-file=/opt/keycloak/keycloak.keystore.jks --https-key-store-type=JKS --https-key-store-password=changeit --https-trust-store-file=/opt/keycloak/keycloak.truststore.jks --https-trust-store-type=JKS --https-trust-store-password=changeit --https-client-auth=request --log-level=INFO --hostname-strict-https=false --hostname-strict=false --hostname=keycloak.traderres.com

			# Database Options
			Environment=KC_DB=postgres
			Environment=KC_DB_URL=jdbc:postgresql://keycloak.csbk2jnrc8ao.us-east-2.rds.amazonaws.com/keycloak_db
			Environment=KC_DB_USERNAME=keycloak_user
			Environment=KC_DB_PASSWORD=secret123

			Environment=KEYCLOAK_ADMIN=keycloak
			Environment=KEYCLOAK_ADMIN_PASSWORD=secret12

			[Install]
			WantedBy=multi-user.target



       3) Update the service
          unix> systemctl daemon-reload

       4) Startup the service
          unix> systemctl start keycloak

       5) Look at the keycloak log
          unix> journalctl -fu keycloak

       6) Use a browser to connect to keycloak
          Connect to https://keycloak.traderres.com:8444/
          Press "Admin Console"
          Enter admin username:   keycloak
          Enter admin password:   secret12
          -- Verify that you can get in

       7) **OPTIONAL** Remove the values from the systemd service file:
           			Environment=KEYCLOAK_ADMIN=keycloak
           			Environment=KEYCLOAK_ADMIN_PASSWORD=secret12


    b. Configure the keycloak settings
       1) Connect to https://keycloak.traderres.com:8444/

       2) Select Realms -> Create realm: MyRealm
          Enabled:  On
          Press "Create"

	   3) Create an x509 authentication flow
	   	a. Click on Authentication
		b. Click on browser
		c. Selection Action -> Duplicate
		   Name:  x509 authentication flow
		d. Delete Everything
		e. Press "Add execution"
		   Select Cookie and press "Add"
		   Change Cookie's Requirement to "Alternate"

		f. Press "Add step"
		   1) Press the "next" button a few times until you see x509/Validate Username Form
		   2) Select x509/Validate Username Form
		   3) Change X509/Validate Username From to Alternate
		   4) Press the "Settings" button

		   5) In the X509/Validate Username Form Config

			  Alias:                                        x509 configuration
			  User Identity Source:                         Match SubjectDN using regular expression
			  Regular expression to extract user identity:  cn=(.*?)(?:,|$)
			  User mapping method:                          Username or Email
			  Check certificate validity:                   On
			  Bypass identity confirmation                  Off

              Press "Save"

		   6) In x509 authentication flow, select Action -> Bind flow
			  Choose "Browser flow"
			  Press "Save"




		 4) Create the client: app16-webapp
			a. Click on Clients
			b. Press "Create client"

			General Settings
			  Client type:           OpenID Connect
			  Client ID:             app16-webapp
			  Name:                  app16 web app
			  Always display in UI:  Off
			  Press "Next"
			  Press "Next"
			  Press "Save"

			Access Settings:
			Root URL:              https://app.traderres.com/app16
			Home URL:              https://app.traderres.com/app16

			Capability Config:
			  Client authentication  On
			  Authorization          On
			  Authentication Flow:   Check Standard flow

			Login Settings
			   Login theme:               keycloak
			   Consent required:          Off
			   Display client on screen:  Off

			Press "Save"


		 5) Click on app16-webapp / Credentials Tab
			Client Authenticator:  Client ID and Secret
            -- We will need this secret key in the deployment yaml file

		 6) Click on "Advanced" Tab
			Go to Authentication flow overrides
			Browser Flow:  x509 authentication flow
			Press "Save"


		 7) Create the realm role
		    a. Press Realm roles
		    b. Press "Create role"
			a. Create a role called APP16_SUPERUSER


		 8) Assign that role to your test user
			a. Click on Users
			b. Press "Add User"
			c. Username:       Lastname.first
            d. Press "create"

			d. Click on "role Mappings"
			e. Press Assign Role
			f. Assign the APP16_SUPERUSER role to this user


		 9) Tell keycloak to provide the roles to spring boot
			a. Click on Client Scopes
			b. Select roles
			c. In the settings tab for 'roles'
			   Include in token scope: On
               press "Save"

			d. Click on Client Scopes
			e. Select roles
			f. Select Mappers Tab
			g. Select Realm Roles
			f. In the settings for "Realm Role'
				  Add to ID Token:     On
				  Add to access token: On
				  Add to userinfo:     On




21. Configure certificates for the load-balancer (external hostname used to access the webapp)
    NOTE:  The webapp needs a load-balancer truststore to work correctly
           The webapp needs a special custom.cacerts file (that has the load-balancer chain and self-signed CA)

       ASSUMPTIONS:
           1) Your root-ca is on the keycloak server in /opt/shared-storage/root-ca

           2) Your certbot is on the keycloak server in /opt/shared-storage/certbot
                 And, so you have server cert files here:
                        /opt/shared-storage/certbot/archive/app.traderres.com/
                        /opt/shared-storage/certbot/archivee/keycloak.traderres.com/

                 If you are not running certbot on the keycloak server, then you need to upload files to
                        /opt/shared-storage/certbot/archive on the keycloak server

                        Upload the files from my box to this keycloak server box
                        unix> cd ~/certbot
       					unix> scp  -i ~/.ssh/app16-kubernetes-nodes-keypair.pem  -r /opt/shared-storage/certbot/archive ec2-user@18.218.246.201:/tmp


    a. Generate this file:  webapp.keystore.jks
       NOTE:  This file should should have the server cert for app.traderres.com in it

       1) SSH to the kubernetes instance that will hold keycloak, certbot, and our root CA
          unix> ssh -i ~/.ssh/app16-kubernetes-nodes-keypair.pem ec2-user@18.218.246.201
          unix> sudo -s

       2) Examine the 3 files that makeup the full chain of the fullchain1.pem / Split it up into 3 files / Find the server cert
           unix> cd /opt/shared-storage/certbot/archive/app.traderres.com
           unix> cat fullchain1.pem | awk 'BEGIN {n=1};  split_after==1{n++;split_after=0} /-----END CERTIFICATE-----/ {split_after=1} {print > "fullchain_part" n ".pem"}'
		   -- Now, we have 3 files called called fullchain_part1.pem, fullchain_part2.pem, fullchain_part3.pem

		   unix> openssl x509 -in fullchain_part1.pem -noout -text | grep 'app.traderres.com'        # Holds the server cert
		   unix> openssl x509 -in fullchain_part2.pem -noout -text | grep 'app.traderres.com'
		   unix> openssl x509 -in fullchain_part3.pem -noout -text | grep 'app.traderres.com'

        3) Generate the server.p12 file from the server cert
           unix> export SERVER_CRT=fullchain_part1.pem       # the cert that has CN=app.traderres.com
		   unix> export SERVER_KEY=privkey1.pem
		   unix> export INTERMEDIATE_CA=fullchain_part2.pem
           unix> openssl pkcs12 -export -in $SERVER_CRT -inkey $SERVER_KEY -out server.p12 -name 'my-server-cert' -CAfile $INTERMEDIATE_CA -caname root
           Enter Export Password: changeit
           Verify Password:       changeit

        4) Convert the server.p12 into webapp.keystore.jks
           unix> rm -f webapp.keystore.jks
           unix> keytool -importkeystore -deststorepass changeit -destkeypass changeit -destkeystore webapp.keystore.jks  -srckeystore server.p12 -srcstoretype PKCS12 -srcstorepass changeit -alias 'my-server-cert'




    b. Generate this file:  webapp.truststore.jks
       1) Import each file into the new webapp.truststore.jks file
          unix> cd /opt/shared-storage/certbot/archive/app.traderres.com
          unix> rm -f webapp.truststore.jks
          unix> keytool -import -alias "new-lb1"  -keystore webapp.truststore.jks -file fullchain_part1.pem  -storepass changeit
          unix> keytool -import -alias "new-lb2"  -keystore webapp.truststore.jks -file fullchain_part2.pem  -storepass changeit
          unix> keytool -import -alias "new-lb3"  -keystore webapp.truststore.jks -file fullchain_part3.pem  -storepass changeit

        2) Import the self-signed root CA pem file into webapp.truststore.jks
           unix> keytool -import -alias "our-ca"  -keystore webapp.truststore.jks -file /opt/shared-storage/root-ca/public/root.pem  -storepass changeit


    c. Generate this file:  custom.cacerts
       NOTE:  This is needed so that the spring security oauth2 authenticator can talk to the keycloak server

              If you cannot find the existing cacerts, you can generate a new one using this command:
                  unix> keytool -genkeypair -alias boguscert -storepass changeit -keystore emptyStore.keystore -dname "CN=Developer, OU=Department, O=Company, L=City, ST=State, C=CA" -keyalg RSA
                  unix> keytool -delete -alias boguscert -storepass changeit -keystore emptyStore.keystore
                  unix> mv emptyStore.keystore custom.cacerts
                  unix> chmod ugo+rw custom.cacerts


       1) Get the path of the cacerts file
          unix> find /usr/lib/jvm -iname cacerts -print

       2) Copy that file to custom.cacerts
          unix> sudo -s
          unix> cd /opt/shared-storage/certbot/archive/app.traderres.com
          unix> cp /usr/lib/jvm/java-11-openjdk-11.0.19.0.7-1.amzn2.0.1.x86_64/lib/security/cacerts  custom.cacerts   # Get this path from previous step
          unix> chmod ugo+rw custom.cacerts

       3) Import the certs into custom.cacerts
          unix> keytool -import -alias "new-lb1"  -keystore  custom.cacerts  -file fullchain_part1.pem  -storepass changeit
          unix> keytool -import -alias "new-lb2"  -keystore  custom.cacerts  -file fullchain_part2.pem  -storepass changeit
          unix> keytool -import -alias "new-lb3"  -keystore  custom.cacerts  -file fullchain_part3.pem  -storepass changeit
          unix> keytool -import -alias "our-ca"   -keystore  custom.cacerts  -file /opt/shared-storage/root-ca/public/root.pem   -storepass changeit



22.  Get the environment values for the kubernetes deployment yaml files
     A) Fill-in the POSTGRES_HOSTNAME       with the name from aws.com -> RDA -> Databases -> app-database -> Endpoint & port
     B) Fill-in the ES_URL                  with the name from aws.com -> OpenSearch -> Domains -> app-opensearch -> domain endpoint (VPC)
     D) Fill-in the KEYCLOAK_ISSUER_URI     with https://<PUBLIC_HOSTNAME-OF_KEYCLOAK_SERVER>:8444/realms/MyRealm
     E) Fill-in the KEYCLOAK_CLIENT_SECRET  with the name from keycloak webapp -> MyRealm -> Clients -> app16-webapp -> Credentials tab
     F) Fill-in the KEYCLOAK_CLIENT_ID      with the name of the keycloak client  (it might be app16-webapp or app16-admin-webapp)
        -- Did you create a separate client for the other webapps
        -- Did you build the keycloak JARs and deploy them?

	    env:
		   - name: POSTGRES_HOSTNAME
			 value: "app-database.csbk2jnrc8ao.us-east-2.rds.amazonaws.com"                                         # Get from RDA -> Databases -> app-database -> Endpoint & port
		   - name: POSTGRES_DB_USERNAME
			 value: "app_user"
		   - name: POSTGRES_DB_PASSWORD
			 value: "secret12"
		   - name: POSTGRES_DB_NAME
			 value: "app_db"
		   - name: POSTGRES_SCHEMA_NAME
			 value: "app_db"
		   - name: POSTGRES_POOL_SIZE
		     value: "5"
		   - name: ES_URL
			 value: "https://vpc-app-opensearch-ep5v5i6jlal7ka3qraya46fpsi.us-east-2.es.amazonaws.com:443"               # Get from OpenSearch -> Domains -> app-opensearch -> domain endpoint (VPC)
		   - name: ES_USERNAME
			 value: "es_user"
		   - name: ES_PASSWORD
			 value: "Secret1@"
		   - name: KEYCLOAK_CLIENT_ID
			 value: "app16-webapp"
		   - name: KEYCLOAK_CLIENT_SECRET
			 value: "0kps0Tn29TWhQhoEy7SwhvWEYNfYb7cU"                                                                  # Get this from keycloak -> MyRealm -> Clients -> app16-webapp -> Credentials tab
		   - name: KEYCLOAK_ISSUER_URI
        	 value: https://keycloak.traderres.com:8444/realms/MyRealm"
		   - name: INCOMING_KEYSTORE_FILEPATH
			 value: "/shared/certs/webapp.keystore.jks"
		   - name: INCOMING_KEYSTORE_PASSWORD
			 value: "changeit"
		   - name: INCOMING_TRUSTSTORE_FILEPATH
			 value: "/shared/certs/webapp.truststore.jks"
		   - name: INCOMING_TRUSTSTORE_PASSWORD
			 value: "changeit"
		   - name: JAVA_TOOL_OPTIONS
			 value: -Xms1024m -Xmx1024m -Demail.mode=off -Djavax.net.ssl.trustStore=/shared/certs/custom.cacerts -Djavax.net.ssl.trustStorePassword=changeit



23. Setup PersistentVolumes so you can share certs among the pods
    Goal is to make these files available to all pods:
       /shared/certs/custom.cacerts                           #  Used by spring-boot so it trusts keycloak server's cert
       /shared/certs/app16.webapp.keystore.jks                #  INCOMING_KEYSTORE_FILEPATH
       /shared/certs/app16.webapp.truststore.jks              #  INCOMING_TRUSTSTORE_FILEPATH

    See https://repost.aws/knowledge-center/eks-persistent-storage     # BE WARNED:  This is set for commercial (not aws-gov) and there are typos


   a. Install the eksctl program for linux
      unix> ARCH=amd64         # this is also for x86_64
      unix> PLATFORM=$(uname -s)_$ARCH
      unix> cd /tmp
      unix> curl -sLO "https://github.com/weaveworks/eksctl/releases/latest/download/eksctl_$PLATFORM.tar.gz"
      unix> tar xvf eksctl_Linux_amd64.tar.gz
      unix> sudo mv /tmp/eksctl /usr/local/bin

   b. Verify that it is installed
      unix> eksctl version

      You should see this:
      0.141.0

   c. Grant the CSI Driver Policy to the eksNodeRole in AWS IAM  (so that the nodes have the authority to read/write to the EBS volumes)
      1) Go to IAM -> Roles -> EksNodeRole
      2) Grant this policy: AmazonEBSCSIDriverPolicy
         1) Add permission -> Attach policies
         2) Search for AmazonEBSCSIDriverPolicy
         3) Select AmazonEBSCSIDriverPolicy
         4) Press "Add permissions"

   d. Create an identify provider using the command-line
      NOTE:  You can create this from the AWS console:  See https://docs.aws.amazon.com/eks/latest/userguide/enable-iam-roles-for-service-accounts.html
      unix> eksctl utils associate-iam-oidc-provider --cluster <MY-CLUSTER-NAME> --approve

      You should see the following:
         2023-06-24 15:23:26 [ℹ]  will create IAM Open ID Connect provider for cluster "app16-cluster" in "us-east-2"
         2023-06-24 15:23:26 [✔]  created IAM Open ID Connect provider for cluster "app16-cluster" in "us-east-2"

   e. Verify that you can see your identity provider
      unix> aws iam list-open-id-connect-providers

      You should see something like this:
		{
			"OpenIDConnectProviderList": [
				{
					"Arn": "arn:aws-us-gov:iam::527362555097:oidc-provider/oidc.eks.us-gov-west-1.amazonaws.com/id/DA006D8E0177E850A3A0489D305D960B"
				}
			]
		}

	  NOTE:  If you see multiple OpenIdConnectProviders, then go into AWS.com -> IAM -> Identify Providers -> Delete the old ones


      So, the OID String would be this "oidc.eks.us-gov-west-1.amazonaws.com/id/DA006D8E0177E850A3A0489D305D960B"


   e. Create an IAM trust policy file using the arn and id from above
      unix> vi trust-policy.json

	   {
		 "Version": "2012-10-17",
		 "Statement": [
		   {
			 "Effect": "Allow",
			 "Principal": {
			   "Federated": "<REPLACE WITH ENTIRE Arn STRING>"
			 },
			 "Action": "sts:AssumeRoleWithWebIdentity",
			 "Condition": {
			   "StringEquals": {
				 "<REPLACE WITH OID STRING>:aud": "sts.amazonaws.com",
				 "<REPLACE WITH OID STRING>:sub": "system:serviceaccount:kube-system:ebs-csi-controller-sa"
			   }
			 }
		   }
		 ]
	   }

	   For us, it looks like this:

	   {
		 "Version": "2012-10-17",
		 "Statement": [
		   {
			 "Effect": "Allow",
			 "Principal": {
			   "Federated": "arn:aws-us-gov:iam::527362555097:oidc-provider/oidc.eks.us-gov-west-1.amazonaws.com/id/DA006D8E0177E850A3A0489D305D960B"
			 },
			 "Action": "sts:AssumeRoleWithWebIdentity",
			 "Condition": {
			   "StringEquals": {
				 "oidc.eks.us-gov-west-1.amazonaws.com/id/DA006D8E0177E850A3A0489D305D960B:aud": "sts.amazonaws.com",
				 "oidc.eks.us-gov-west-1.amazonaws.com/id/DA006D8E0177E850A3A0489D305D960B:sub": "system:serviceaccount:kube-system:ebs-csi-controller-sa"
			   }
			 }
		   }
		 ]
	   }


  f. Create the role:  AmazonEKS_EBS_CSI_DriverRole
     unix>  aws iam create-role  --role-name AmazonEKS_EBS_CSI_DriverRole  --assume-role-policy-document file://"trust-policy.json"

  g. Attach this new role to the AmazonEBSCSIDriverPolicy amazon policy
     unix> aws iam attach-role-policy  --policy-arn arn:aws:iam::aws:policy/service-role/AmazonEBSCSIDriverPolicy  --role-name AmazonEKS_EBS_CSI_DriverRole

  h. Deploy the driver (for aws-gov-cloud)
     unix> export AWS_REGISTRY_ID=$(aws ecr describe-registry --query registryId --output text)
     unix> export YOUR_CLUSTER_NAME=app16-cluster

     For Gov-Cloud:
     unix> aws eks create-addon --cluster-name ${YOUR_CLUSTER_NAME} --addon-name aws-ebs-csi-driver  --service-account-role-arn arn:aws-us-gov:iam::${AWS_REGISTRY_ID}:role/AmazonEKS_EBS_CSI_DriverRole
           NOTE:  This command is set for aws-gov-cloud
           *OR*

     For Non-Gov-Cloud:
     unix> aws eks create-addon --cluster-name ${YOUR_CLUSTER_NAME} --addon-name aws-ebs-csi-driver  --service-account-role-arn arn:aws:iam::${AWS_REGISTRY_ID}:role/AmazonEKS_EBS_CSI_DriverRole



  i. Test the Amazon EBS CSI driver:
     unix> git clone https://github.com/kubernetes-sigs/aws-ebs-csi-driver.git
     unix> cd aws-ebs-csi-driver/examples/kubernetes/dynamic-provisioning/
     unix> kubectl apply -f manifests/

		   NOTE:
		      -- This creates a 4 Gi persistent volume claim called ebs-claim

				storageclass.yaml
				-----------------
				apiVersion: storage.k8s.io/v1
                kind: StorageClass
                metadata:
                  name: ebs-sc
                provisioner: ebs.csi.aws.com
                volumeBindingMode: WaitForFirstConsumer


				claim.yaml
				----------
				apiVersion: v1
				kind: PersistentVolumeClaim
				metadata:
				  name: ebs-claim
				spec:
				  accessModes:
					- ReadWriteOnce
				  storageClassName: ebs-sc
				  resources:
					requests:
					  storage: 4Gi


				pod.yaml   (keeps appending every 5 seconds to /data/out.txt)
				--------
				apiVersion: v1
                kind: Pod
                metadata:
                  name: app
                spec:
                  containers:
                  - name: app
                    image: centos
                    command: ["/bin/sh"]
                    args: ["-c", "while true; do echo $(date -u) >> /data/out.txt; sleep 5; done"]
                    volumeMounts:
                    - name: persistent-storage
                      mountPath: /data
                  volumes:
                  - name: persistent-storage
                    persistentVolumeClaim:
                      claimName: ebs-claim





     You should see this:
       persistentvolumeclaim/ebs-claim created
       pod/app created
       storageclass.storage.k8s.io/ebs-sc created


 j. Describe the ebs-sc storage class:
    unix> kubectl describe storageclass ebs-sc

    You should see something like this:
		Name:            ebs-sc
		IsDefaultClass:  No
		Annotations:     kubectl.kubernetes.io/last-applied-configuration={"apiVersion":"storage.k8s.io/v1","kind":"StorageClass","metadata":{"annotations":{},"name":"ebs-sc"},"provisioner":"ebs.csi.aws.com","volumeBindingMode":"WaitForFirstConsumer"}

		Provisioner:           ebs.csi.aws.com
		Parameters:            <none>
		AllowVolumeExpansion:  <unset>
		MountOptions:          <none>
		ReclaimPolicy:         Delete
		VolumeBindingMode:     WaitForFirstConsumer
		Events:                <none>

 l. Watch the pods and wait for app status to be running
    unix> kubectl get pods --watch

	You should see this:
		NAME                               READY   STATUS             RESTARTS         AGE
		app                                1/1     Running            0                84s


 m. View the persistent volume that was created
    unix> kubectl get pv

    You should see this:
		NAME                                       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM               STORAGECLASS   REASON   AGE
		pvc-d960c622-4a01-4a2f-8209-4d6debff2090   4Gi        RWO            Delete           Bound    default/ebs-claim   ebs-sc                  112s


 n. View the detailed information on your persistent volume
    unix> kubectl describe pv pvc-d960c622-4a01-4a2f-8209-4d6debff2090

    You should see this:
		Name:              pvc-d960c622-4a01-4a2f-8209-4d6debff2090
		Labels:            <none>
		Annotations:       pv.kubernetes.io/provisioned-by: ebs.csi.aws.com
						   volume.kubernetes.io/provisioner-deletion-secret-name:
						   volume.kubernetes.io/provisioner-deletion-secret-namespace:
		Finalizers:        [kubernetes.io/pv-protection external-attacher/ebs-csi-aws-com]
		StorageClass:      ebs-sc
		Status:            Bound
		Claim:             default/ebs-claim
		Reclaim Policy:    Delete
		Access Modes:      RWO
		VolumeMode:        Filesystem
		Capacity:          4Gi
		Node Affinity:
		  Required Terms:
			Term 0:        topology.ebs.csi.aws.com/zone in [us-gov-west-1c]
		Message:
		Source:
			Type:              CSI (a Container Storage Interface (CSI) volume source)
			Driver:            ebs.csi.aws.com
			FSType:            ext4
			VolumeHandle:      vol-00c084488e5310556
			ReadOnly:          false
			VolumeAttributes:      storage.kubernetes.io/csiProvisionerIdentity=1684347075383-8081-ebs.csi.aws.com
		Events:                <none>

  o. Verify that the pod is writing data to the volume:
     unix> kubectl exec -it app -- cat /data/out.txt

     You should see the date time repeated
     	Wed May 17 18:37:46 UTC 2023
        Wed May 17 18:37:51 UTC 2023
        Wed May 17 18:37:56 UTC 2023
        Wed May 17 18:38:01 UTC 2023
        Wed May 17 18:38:06 UTC 2023
        Wed May 17 18:38:11 UTC 2023
        Wed May 17 18:38:16 UTC 2023
        Wed May 17 18:38:21 UTC 2023
        Wed May 17 18:38:26 UTC 2023
        Wed May 17 18:38:31 UTC 2023
        Wed May 17 18:38:36 UTC 2023
        Wed May 17 18:38:41 UTC 2023
        Wed May 17 18:38:46 UTC 2023
        Wed May 17 18:38:51 UTC 2023
        Wed May 17 18:38:56 UTC 2023
        Wed May 17 18:39:01 UTC 2023

  p. Stop the pod that is appending
     a. Delete the pod
        unix> kubectl delete pod app

     b. Delete the PersistentVolumeClaim (which deletes the PersistentVolume)
        unix> kubectl delete pvc ebs-claim

     c. Delete the storage class
        unix> kubectl delete sc ebs-sc


  q. Create the **REAL** storage class called "app-sc" for our webapps
     unix> vi app-storage-class.yaml

#############################################################
# app-storage-class.yaml
#
# volumeBindingModes include Immediate and WaitForFirstConsumer
#############################################################
apiVersion: storage.k8s.io/v1
kind: StorageClass
metadata:
  name: app-sc
provisioner: ebs.csi.aws.com
volumeBindingMode: Immediate

   unix> kubectl apply -f app-storage-class.yaml



  r. Create the **REAL** persistent volume claim called "app-pvc-certs" for our webapps to readonly
     unix> vi app-certs-pvc.yaml

#############################################################
#  app-certs-pvc.yaml
#
# Defines the PersistentVolumeClaim for our certs (so the containers can read the certs)
#############################################################
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: app-certs-pvc
spec:
  accessModes:
    - ReadWriteOnce
  storageClassName: app-sc
  resources:
    requests:
      storage: 1Gi


     unix> kubectl apply -f app-certs-pvc.yaml



 s. Add this section to the deployment.yaml   (should already be in the app16-deployment.yaml)

    volumeMounts:
    - name: persistent-storage
      mountPath: /shared/certs
  volumes:
  - name: persistent-storage
    persistentVolumeClaim:
      claimName: app-certs-pvc




23. Upload the shared certs into the /shared/certs persistent volume
    a. Create a temporary pod (called app2) that has this PVC mounted
       unix> vi app2-pod.yaml

################################
# app2-pod.yaml
################################
apiVersion: v1
kind: Pod
metadata:
  name: app2
spec:

  volumes:
  - name: app-certs-pv
    persistentVolumeClaim:
      claimName: app-certs-pvc

  containers:
  - name: app2
    image: centos
    command: ["/bin/sh"]
    args: ["-c", "while true; do echo 'hi'; sleep 5; done"]
    volumeMounts:
    - name: app-certs-pv
      mountPath: /shared/certs






    b. Deploy the pod
       unix> kubectl apply -f app2-pod.yaml

    c. Verify that the pod is up
       unix> kubectl logs -f app2
       hi
       hi
       hi


    d. Use the kubectl cp command to copy the file from your local filesystem to the pod's /shared/certs directory
       1) Move the files to /tmp so we can download them to our local box
          ssh -i ~/.ssh/app16-kubernetes-nodes-keypair.pem ec2-user@52.15.227.18
          unix> sudo -s
          unix> cp /opt/shared-storage/certbot/archive/app.traderres.com/*.jks /tmp
          unix> cp /opt/shared-storage/certbot/archive/app.traderres.com/custom.cacerts /tmp
          unix> chmod ugo+r /tmp/*.jks
          unix> chmod ugo+r /tmp/custom.cacerts

       2) Download the custom.cacerts, webapp.keystore.jks, webapp.truststore.jks from the keycloak/root-ca/certbot instance to your box
          unix> scp -i ~/.ssh/app16-kubernetes-nodes-keypair.pem ec2-user@52.15.227.187:/tmp/*.jks .
          unix> scp -i ~/.ssh/app16-kubernetes-nodes-keypair.pem ec2-user@52.15.227.187:/tmp/custom.cacerts .

       3) Upload the 3 files into the /shared/certs directory
          unix> kubectl cp custom.cacerts         app2:/shared/certs/custom.cacerts
          unix> kubectl cp webapp.keystore.jks    app2:/shared/certs/webapp.keystore.jks
          unix> kubectl cp webapp.truststore.jks  app2:/shared/certs/webapp.truststore.jks

    e. Verify that the files are there
       unix> kubectl exec app2 -it /bin/sh
       container> cd /shared/certs
       container> ls -l

       -- You should see your 3 files

    f. Delete the running pod
       unix> kubectl delete pod app2


25. Use Kubernetes to deploy the sync-service
    a. Delete existing deployment
       unix> kubectl delete deployment app16-sync-service-deployment

    b. Create the deployment script by adding the "env" section with Java settings
       unix> vi app16-sync-service-deployment-v2.3.0.yaml

######################################################################################
# Filename:  app16-sync-service-deployment-v2.3.0.yaml
#
# Purpose:   Tell kubernetes how to deploy the App16 Sync Service
#
# Usage
#  1. Follow the steps to setup AWS credentials (so you can build & deploy)
#     https://github.com/traderres/webClass/blob/master/learnAWS/howToBuildAndPushToAmazonECR.txt
#
#  2. Build and push the containers to the Amazon ECR (image repository)
#     unix> mvn -Djib.to.auth.username=AWS -Djib.to.auth.password=$PASSWORD clean package -Pprod -PbuildImageAndPush
#
#  3. Edit the environment variables in this yaml file to match reality -- e.g., set the POSTGRES_HOSTNAME
#     a. Also edit the image name (in this yaml file) to make sure it matches what was pushed to the Amazon ECR
#
#  4. Tell kubernetes to deploy the sync service
#     unix> kubectl delete deployment app16-sync-service-deployment
#     unix> kubectl apply -f app16-sync-service-deployment-v2.2.3.yaml
#
#  5. Get the name of the running pod  (it changes every time)
#     unix> kubectl get pods
#
#     NAME                                            READY   STATUS         RESTARTS   AGE
#     app16-sync-service-deployment-69c9fd9db6-6wkcf   1/1     Running        0          19s
#
#  6. Look at the pod log to verify that the sync-service is running
#     uniX> kubectl logs -f app16-sync-service-deployment-69c9fd9db6-6wkcf
#
# Notes:
#  A) If you want to erase the database, then add this to JAVA_TOOL_OPTIONS:
#        -Dapp.datasource.flyway-clean-on-startup=TRUE
######################################################################################
apiVersion: apps/v1
kind: Deployment
metadata:
  name: app16-sync-service-deployment

spec:
  selector:
    matchLabels:
      app: app16-sync-service
  replicas: 1
  strategy:
    type:  Recreate
  template:
    metadata:
      name: app16-sync-service
      labels:
         app: app16-sync-service
    spec:

      volumes:
      - name: app-certs-pv
        persistentVolumeClaim:
          claimName: app-certs-pvc

      containers:
      - image: 524647912468.dkr.ecr.us-east-2.amazonaws.com/app16:sync-service-2.3.0-SNAPSHOT
        imagePullPolicy: Always
        volumeMounts:
        - name: app-certs-pv
          mountPath: /shared/certs

        name: app16-sync-service

        env:
           - name: POSTGRES_HOSTNAME
             value: "app-database.csbk2jnrc8ao.us-east-2.rds.amazonaws.com"
           - name: POSTGRES_DB_USERNAME
             value: "app_user"
           - name: POSTGRES_DB_PASSWORD
             value: "secret12"
           - name: POSTGRES_DB_NAME
             value: "app_db"
           - name: POSTGRES_SCHEMA_NAME
             value: "app_db"
           - name: POSTGRES_POOL_SIZE
             value: "2"
           - name: ES_URL
             value: "https://vpc-app-opensearch-ep5v5i6jlal7ka3qraya46fpsi.us-east-2.es.amazonaws.com:443"
           - name: ES_USERNAME
             value: "es_user"
           - name: ES_PASSWORD
             value: "Secret1@"
           - name: INCOMING_KEYSTORE_FILEPATH
             value: "/shared/certs/webapp.keystore.jks"
           - name: INCOMING_KEYSTORE_PASSWORD
             value: "changeit"
           - name: INCOMING_TRUSTSTORE_FILEPATH
             value: "/shared/certs/webapp.truststore.jks"
           - name: INCOMING_TRUSTSTORE_PASSWORD
             value: "changeit"
           - name: JAVA_TOOL_OPTIONS
             value: -Xms1024m -Xmx1024m -Demail.mode=off  -Djavax.net.ssl.trustStore=/shared/certs/custom.cacerts -Djavax.net.ssl.trustStorePassword=changeit



	 c. Verify that there are no special chars in the file by looking for them
		unix> cat -v -e app16-sync-service-deployment-v2.3.0.yaml

     d. Update the image path so that it matches the image name in the Amazon ECR

	 e. We create the deployment
		unix> kubectl apply -f app16-sync-service-deployment-v2.3.0.yaml

	 f. Get a listing of the pods
		unix> kubectl get pods

		NAME                                           READY   STATUS    RESTARTS   AGE
		app16-sync-service-deployment-f4555b587-rclll   1/1     Running   0          2m50s

     g. Look at the log
        unix> kubectl logs -f app16-sync-service-deployment-f4555b587-rclll




26. Use Kubernetes to deploy the webapp

    a. Delete existing deployment
       unix> kubectl delete deployment app16-deployment

    b. Create the deployment script by adding the "env" section with Java settings
       unix> vi app16-deployment-v2.3.0.yaml

#############################################################################
#  app16-deployment-v2.3.0.yaml
#
# Purpose:   Tell kubernetes how to deploy the app16 web app(s)
#
# Usage
#  1. Follow the steps to setup AWS credentials (so you can build & deploy)
#     https://github.com/traderres/webClass/blob/master/learnAWS/howToBuildAndPushToAmazonECR.txt
#
#  2. Build and push the containers to the Amazon ECR (image repository)
#     unix> mvn -Djib.to.auth.username=AWS -Djib.to.auth.password=$PASSWORD clean package -Pprod -PbuildImageAndPush
#
#  3. Edit the environment variables in this yaml file to match reality -- e.g., set the POSTGRES_HOSTNAME
#     a. Also edit the image name (in this yaml file) to make sure it matches what was pushed to the Amazon ECR
#
#  4. Tell kubernetes to deploy the sync service
#     unix> kubectl delete deployment app16-deployment
#     unix> kubectl apply -f app16-deployment-v2.2.3.yaml
#
#  5. Get the name of the running pod  (it changes every time)
#     unix> kubectl get pods
#
#     NAME                                            READY   STATUS         RESTARTS   AGE
#     app16-deployment-69c9fd9db6-6wkcf                1/1     Running        0          19s
#
#  6. Look at the pod log to verify that the app16 webapp is up
#     uniX> kubectl logs -f app16-deployment-69c9fd9db6-6wkcf
#
# Notes:
#  A) The running pods do not have DNS so we need hostAliases to create an entry in /etc/hosts
#     that can resolve the keycloak.traderres.com to 18.216.9.38
#     Use nslookup keycloak.rbr-tech.com to verify the IP
#  B) If you want 5 copies of the webapp, then change replicas to 5 (in this file)
#############################################################################
apiVersion: apps/v1
kind: Deployment
metadata:
  name: app16-deployment
  labels:
    app: app16-deployment

spec:
  selector:
    matchLabels:
      app: app16-deployment
  replicas: 1
  strategy:
    type:  Recreate
  template:
    metadata:
      name: app16-deployment
      labels:
         app: app16-deployment
    spec:
      hostAliases:
      - ip: "18.216.9.38"
        hostnames:
          - "keycloak.traderres.com"

      volumes:
      - name: app-certs-pv
        persistentVolumeClaim:
          claimName: app-certs-pvc

      containers:
      - image: 524647912468.dkr.ecr.us-east-2.amazonaws.com/app16:backend-2.3.0-SNAPSHOT
        imagePullPolicy: Always
        volumeMounts:
        - name: app-certs-pv
          mountPath: /shared/certs

        name: app16-deployment

        ports:
            - containerPort: 80
              name: health-check
            - containerPort: 443
              name: web-app

        env:
           - name: POSTGRES_HOSTNAME
             value: "app-database.csbk2jnrc8ao.us-east-2.rds.amazonaws.com"
           - name: POSTGRES_DB_USERNAME
             value: "app_user"
           - name: POSTGRES_DB_PASSWORD
             value: "secret12"
           - name: POSTGRES_DB_NAME
             value: "app_db"
           - name: POSTGRES_SCHEMA_NAME
             value: "app_db"
           - name: POSTGRES_POOL_SIZE
             value: "5"
           - name: ES_URL
             value: "https://vpc-app-opensearch-ep5v5i6jlal7ka3qraya46fpsi.us-east-2.es.amazonaws.com:443"
           - name: ES_USERNAME
             value: "es_user"
           - name: ES_PASSWORD
             value: "Secret1@"
           - name: KEYCLOAK_CLIENT_ID
             value: "app16-webapp"
           - name: KEYCLOAK_CLIENT_SECRET
             value: "0kps0Tn29TWhQhoEy7SwhvWEYNfYb7cU"
           - name: KEYCLOAK_ISSUER_URI
             value: "https://keycloak.traderres.com:8444/realms/MyRealm"
           - name: INCOMING_KEYSTORE_FILEPATH
             value: "/shared/certs/webapp.keystore.jks"
           - name: INCOMING_KEYSTORE_PASSWORD
             value: "changeit"
           - name: INCOMING_TRUSTSTORE_FILEPATH
             value: "/shared/certs/webapp.truststore.jks"
           - name: INCOMING_TRUSTSTORE_PASSWORD
             value: "changeit"
           - name: JAVA_TOOL_OPTIONS
             value: -Xms1024m -Xmx1024m -Demail.mode=off -Djavax.net.ssl.trustStore=/shared/certs/custom.cacerts -Djavax.net.ssl.trustStorePassword=changeit




	 c. Verify that there are no special chars in the file by looking for them
		unix> cat -v -e app16-deployment-v2.3.0.yaml

     d. Update the image path so that it matches the image name in the Amazon ECR

	 e. We create the deployment
		unix> kubectl apply -f app16-deployment-v2.3.0.yaml

	 f. Get a listing of the pods
		unix> kubectl get pods

		NAME                               READY   STATUS    RESTARTS   AGE
		app16-deployment-c469974cb-tj4kk   1/1     Running   0          10s

    g. Look at the logs
       unix> kubectl logs -f app16-deployment-c469974cb-tj4kk



STOP HERE AND go to part 5 to setup the load balancer
See buildAndDeploy_part5a_exposeWebApps.classicLoadBalancer.txt for setting-up the classic load balancer







Troubleshooting
---------------
 A. Ssh to the running pod
    unix> kubectl get pods

    unix> kubectl exec -it app16-deployment-5c944dc79f-sb8lc /bin/bash
    unix> curl https://keycloak.traderres.com:8444/realms/MyRealm
    -- Verify that you get info cleanly (without error)




How to Shutdown the entire AWS cluster (so you're not being billed for anything)
--------------------------------------------------------------------------------
 1. Go into ECR, and delete the repository images

 2. Delete the node group
    Go into EKS -> Clusters -> app16-cluster -> Compute
    Check app16-node-group -> Delete

 3. Delete the OpenSearch domain
    Go into OpenSearch -> Click on sf328 domain ->

 4. Delete Postgres RDS
    Go into RDS -> Database
    Select the keycloak -> Action -> Delete
    Uncheck "Create final snapshot"
    Delete

    Go into RDS -> Database
    Select the sf328 -> Action -> Delete
    Uncheck "Create final snapshot"
    Delete

 5. Delete the EKS Cluster
    Go into EKS -> Clusters -> app16-cluster -> delete

 6. Delete the EC2 Load balancer
    Go into EC2 -> Load balancers -> Action -> Delete






When deploying on AWS, remember that you need 2 signed server-certs
-------------------------------------------------------------------
 1) Server Cert #1 will be used by keycloak
    Create it with subject alternative name = hostname, external IP, and internal IP
    NOTE:  Make sure the hostname is *FIRST* in the subject alternative name

 2) Server Cert #2 will be used by the spring boot web app
    Create it with subject alternative name = external hostname, external IP
    NOTE:  Make sure the hostname is *FIRST* in the subject alternative name





Remember:  The goal is to have the *SAME* build used in multiple environments
           So, the application.yaml will get its values from env variables or a kubernetes configMap




Sample YAML Files
-----------------

#############################################################################
#  app16-sync-service-deployment-v1.yaml
#
# Purpose:   Tell kubernetes how to deploy the Sync Service
#
# Usage
#  1. Follow the steps to setup AWS credentials (so you can build & deploy)
#     https://github.com/traderres/webClass/blob/master/learnAWS/howToBuildAndPushToAmazonECR.txt
#
#  2. Build and push the containers to the Amazon ECR (image repository)
#     unix> mvn -Djib.to.auth.username=AWS -Djib.to.auth.password=$PASSWORD clean package -Pprod -PbuildImageAndPush
#
#  3. Edit the environment variables in this yaml file to match reality -- e.g., set the POSTGRES_HOSTNAME
#     a. Also edit the image name (in this yaml file) to make sure it matches what was pushed to the Amazon ECR
#
#  4. Tell kubernetes to deploy the sync service
#     unix> kubectl delete deployment app16-sync-service-deployment
#     unix> kubectl apply -f app16-sync-service-deployment-v2.2.3.yaml
#
#  5. Get the name of the running pod  (it changes every time)
#     unix> kubectl get pods
#
#     NAME                                             READY   STATUS         RESTARTS   AGE
#     app16-sync-service-deployment-69c9fd9db6-6wkcf   1/1     Running        0          19s
#
#  6. Look at the pod log to verify that the sync-service is running
#     uniX> kubectl logs -f app16-sync-service-deployment-69c9fd9db6-6wkcf
#
# Notes:
#  A) If you want to erase the database, then add this to JAVA_TOOL_OPTIONS:
#        -Dapp.datasource.flyway-clean-on-startup=TRUE
#############################################################################
apiVersion: apps/v1
kind: Deployment
metadata:
  name: app16-sync-service-deployment

spec:
  selector:
    matchLabels:
      app: app16-sync-service
  replicas: 1
  strategy:
    type:  Recreate
  template:
    metadata:
      name: app16-sync-service
      labels:
         app: app16-sync-service
    spec:

      volumes:
      - name: app-certs-pv
        persistentVolumeClaim:
          claimName: app-certs-pvc

      containers:
      - image: 527362555097.dkr.ecr.us-gov-west-1.amazonaws.com/app16:sync-service-2.2.3-SNAPSHOT
        imagePullPolicy: Always
        volumeMounts:
        - name: app-certs-pv
          mountPath: /shared/certs

        name: app16-sync-service

        env:
           - name: POSTGRES_HOSTNAME
             value: "app16.cgl3wyvjvqtu.us-gov-west-1.rds.amazonaws.com"
           - name: POSTGRES_DB_USERNAME
             value: "app16_user"
           - name: POSTGRES_DB_PASSWORD
             value: "secret12"
           - name: POSTGRES_DB_NAME
             value: "app16_db"
           - name: POSTGRES_SCHEMA_NAME
             value: "app16_db"
           - name: POSTGRES_POOL_SIZE
             value: "50"
           - name: ES_URL
             value: "https://vpc-app16-wxin7j6ech5f4i6bvhptdwldcu.us-gov-west-1.es.amazonaws.com:443"
           - name: ES_USERNAME
             value: "es_user"
           - name: ES_PASSWORD
             value: "Secret1@"
           - name: INCOMING_KEYSTORE_FILEPATH
             value: "/shared/certs/app16.webapp.keystore.jks"
           - name: INCOMING_KEYSTORE_PASSWORD
             value: "changeit"
           - name: INCOMING_TRUSTSTORE_FILEPATH
             value: "/shared/certs/app16.webapp.truststore.jks"
           - name: INCOMING_TRUSTSTORE_PASSWORD
             value: "changeit"
           - name: JAVA_TOOL_OPTIONS
             value: -Xms1024m -Xmx1024m -Demail.mode=off -Djavax.net.ssl.trustStore=/shared/certs/custom.cacerts -Djavax.net.ssl.trustStorePassword=changeit




#############################################################################
#  app16-deployment-v2.2.3.yaml
#
# Purpose:   Tell kubernetes how to deploy the app16 web app(s)
#
# Usage
#  1. Follow the steps to setup AWS credentials (so you can build & deploy)
#     https://github.com/traderres/webClass/blob/master/learnAWS/howToBuildAndPushToAmazonECR.txt
#
#  2. Build and push the containers to the Amazon ECR (image repository)
#     unix> mvn -Djib.to.auth.username=AWS -Djib.to.auth.password=$PASSWORD clean package -Pprod -PbuildImageAndPush
#
#  3. Edit the environment variables in this yaml file to match reality -- e.g., set the POSTGRES_HOSTNAME
#     a. Also edit the image name (in this yaml file) to make sure it matches what was pushed to the Amazon ECR
#
#  4. Tell kubernetes to deploy the sync service
#     unix> kubectl delete deployment app16-deployment
#     unix> kubectl apply -f app16-deployment-v2.2.3.yaml
#
#  5. Get the name of the running pod  (it changes every time)
#     unix> kubectl get pods
#
#     NAME                                            READY   STATUS         RESTARTS   AGE
#     app16-deployment-69c9fd9db6-6wkcf                1/1     Running        0          19s
#
#  6. Look at the pod log to verify that the app16 webapp is up
#     uniX> kubectl logs -f app16-deployment-69c9fd9db6-6wkcf
#
# Notes:
#  A) The running pods do not have DNS so we need hostAliases to create an entry in /etc/hosts
#     that can resolve the keycloak.rbr-tech.com to 160.1.14.243
#     Use nslookup keycloak.rbr-tech.com to verify the IP
#  B) If you want 5 copies of the webapp, then change replicas to 5 (in this file)
#############################################################################
apiVersion: apps/v1
kind: Deployment
metadata:
  name: app16-deployment

spec:
  selector:
    matchLabels:
      app: app16-backend

  replicas: 1
  strategy:
    type:  Recreate
  template:
    metadata:
      name: app16-backend
      labels:
         app: app16-backend

    spec:
      hostAliases:
      - ip: "160.1.14.243"
        hostnames:
          - "keycloak.rbr-tech.com"

      volumes:
      - name: app-certs-pv
        persistentVolumeClaim:
          claimName: app-certs-pvc

      containers:
      - image: 527362555097.dkr.ecr.us-gov-west-1.amazonaws.com/app16:backend-2.2.3-SNAPSHOT
        imagePullPolicy: Always
        volumeMounts:
        - name: app-certs-pv
          mountPath: /shared/certs

        name: app16-backend

        env:
           - name: POSTGRES_HOSTNAME
             value: "app16.cgl3wyvjvqtu.us-gov-west-1.rds.amazonaws.com"
           - name: POSTGRES_DB_USERNAME
             value: "app16_user"
           - name: POSTGRES_DB_PASSWORD
             value: "secret12"
           - name: POSTGRES_DB_NAME
             value: "app16_db"
           - name: POSTGRES_SCHEMA_NAME
             value: "app16_db"
           - name: POSTGRES_POOL_SIZE
             value: "5"
           - name: ES_URL
             value: "https://vpc-app16-wxin7j6ech5f4i6bvhptdwldcu.us-gov-west-1.es.amazonaws.com:443"
           - name: ES_USERNAME
             value: "app16_user"
           - name: ES_PASSWORD
             value: "Secret1@"
           - name: KEYCLOAK_CLIENT_ID
             value: "app16-webapp"
           - name: KEYCLOAK_CLIENT_SECRET
             value: "gyG7oTbHbenKecReYOJIg4F2fTaUtGDp"
           - name: KEYCLOAK_ISSUER_URI
             value: "https://keycloak.rbr-tech.com:8444/realms/MyRealm"
           - name: INCOMING_KEYSTORE_FILEPATH
             value: "/shared/certs/napp16.webapp.keystore.jks"
           - name: INCOMING_KEYSTORE_PASSWORD
             value: "changeit"
           - name: INCOMING_TRUSTSTORE_FILEPATH
             value: "/shared/certs/app16.webapp.truststore.jks"
           - name: INCOMING_TRUSTSTORE_PASSWORD
             value: "changeit"
           - name: JAVA_TOOL_OPTIONS
             value: -Xms1024m -Xmx1024m -Demail.mode=off -Djavax.net.ssl.trustStore=/shared/certs/custom.cacerts -Djavax.net.ssl.trustStorePassword=changeit

