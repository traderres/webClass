How to Modify Maven and Security to build as a Docker Container
---------------------------------------------------------------
Problem:  How to modify the builds and security to build all of the artifacts as a docker container

NOTE:  These changes are applied to angularApp16 lesson9/deploy-to-aws
       See https://github.com/traderres/angularApp16/tree/lesson9/deploy-to-aws



Part 1 / Configure maven so that we can build using buildImage or buildImageAndPush
------------------------------------------------------------------------------------
 1. Edit the parent pom.xml

    a. In the <properties>, add the aws ecr uri

		  <properties>
			<project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>

			<!-- Tell Maven to compile for Java 17 -->
			<maven.compiler.release>17</maven.compiler.release>
			<maven.compiler.verbose>false</maven.compiler.verbose>

			<!-- Specify where the URI for the Amazon Container Registry -->
			<aws.ecr.uri>524647912468.dkr.ecr.us-east-1.amazonaws.com/apps/app16</aws.ecr.uri>

			<!-- Specify the AWS environment name -->
			<aws.env.name>dev</aws.env.name>
		  </properties>


    b. Tell maven which modules to use for the "buildImage" and "buildImageAndPush" profiles
    	<profiles>
			<profile>
			  <!--    B U I L D     I M A G E      P R O F I L E      (for running this app in a container)  -->
			  <id>buildImage</id>

			  <modules>
				<module>common-backend</module>
				<module>backend</module>
				<module>frontend</module>
				<module>sync-service</module>
			  </modules>
			</profile>

			<profile>
			  <!--    B U I L D     I M A G E    A N D    P U S H        P R O F I L E     (for running this app in a container)  -->
			  <id>buildImageAndPush</id>

			  <modules>
				<module>common-backend</module>
				<module>backend</module>
				<module>frontend</module>
				<module>sync-service</module>
			  </modules>
			</profile>
    	</profiles>



 2.  Add the "buildImage" and "buildImageAndPush" profiles to sync-service/pom.xml

	<profiles>

			<!--    B U I L D     I M A G E      P R O F I L E      (for running this app in a container)  -->
			<profile>
			  <id>buildImage</id>

			  <!-- When running this profile, do *NOT* include the src/main/resources/application.yaml in the build -->
			  <build>
				<resources>
				   <resource>
					<filtering>false</filtering>
					<directory>src/main/resources</directory>
					<excludes>
					  <exclude>application.yaml</exclude>
					</excludes>
				  </resource>
				</resources>

				<plugins>
				  <plugin>
					<!-- Use the jib-maven-plugin to build the container and push it up to a registry [without having to install Docker] -->
					<groupId>com.google.cloud.tools</groupId>
					<artifactId>jib-maven-plugin</artifactId>
					<version>3.4.4</version>

					<executions>
					  <execution>
						<phase>package</phase>
						<goals>
						  <!-- Possible goals are build and dockerBuild   -->
						  <!--   The "build"       goal does not require docker / build the image and push it to a repo                 -->
						  <!--   The "dockerBuild" goal requires docker         / build the image and push to the local daemon daemon   -->
						  <goal>dockerBuild</goal>
						</goals>
					  </execution>
					</executions>

					<configuration>
					  <from>
						<!-- This source image runs linux with JDK 17.07 -->
						<image>eclipse-temurin:17.0.7_7-jdk@sha256:9dd6a19e4819b066aa2bd8e54d5988a49cca29736fe5447cb0a57daa975f8935</image>
					  </from>

					  <to>
						<!-- Specify the destination name in the AWS Container Registry -->
						<image>${aws.ecr.uri}:${aws.env.name}-${project.artifactId}-${project.version}</image>
					   </to>


					  <extraDirectories>
						<paths>
						  <path>
							<!-- Copies everything from 'src/main/image_resources' into '/sync-service-/src/main/image_resources' on the container. -->
							<from>src/main/image_resources</from>
							<into>/sync-service/src/main/image_resources</into>
						  </path>
						</paths>
					  </extraDirectories>

					  <container>
						<jvmFlags>
						  <!-- When starting the container, tell Java where to find the application.yaml -->
						  <jvmFlag> -Dspring.config.location=/sync-service/src/main/image_resources/application.yaml</jvmFlag>
						</jvmFlags>
					  </container>

					</configuration>

				  </plugin>
				</plugins>
			  </build>
			</profile>




			<!--    B U I L D     I M A G E    A N D    P U S H        P R O F I L E      (for running this app in a container)  -->
			<profile>
			  <id>buildImageAndPush</id>

			  <!-- When running this profile, do *NOT* include the src/main/resources/application.yaml in the build -->
			  <build>
				<resources>
				  <resource>
					<filtering>false</filtering>
					<directory>src/main/resources</directory>
					<excludes>
					  <exclude>application.yaml</exclude>
					</excludes>
				  </resource>
				</resources>

				<plugins>
				  <plugin>
					<!-- Use the jib-maven-plugin to build the container and push it up to a registry [without having to install Docker] -->
					<groupId>com.google.cloud.tools</groupId>
					<artifactId>jib-maven-plugin</artifactId>
					<version>3.4.4</version>

					<executions>
					  <execution>
						<phase>package</phase>
						<goals>
						  <!-- Possible goals are build and dockerBuild   -->
						  <!--   The "build"       goal does not require docker / build the image and push it to a repo                 -->
						  <!--   The "dockerBuild" goal requires docker         / build the image and push to the local daemon daemon   -->
						  <goal>build</goal>
						</goals>
					  </execution>
					</executions>

					<configuration>
					  <from>
						<!-- Define the source image that will be executed            -->
						<!-- See https://hub.docker.com/_/eclipse-temurin/tags        -->

						<!-- This source image runs linux with JDK 17.07 -->
						<image>eclipse-temurin:17.0.7_7-jdk@sha256:9dd6a19e4819b066aa2bd8e54d5988a49cca29736fe5447cb0a57daa975f8935</image>
					  </from>

					  <to>
						<!-- Specify the destination name in the AWS Container Registry -->
						<image>${aws.ecr.uri}:${aws.env.name}-${project.artifactId}-${project.version}</image>
					  </to>


					  <extraDirectories>
						<paths>
						  <path>
							<!-- Copies everything from 'src/main/image_resources' into '/sync-service-/src/main/image_resources' on the container. -->
							<from>src/main/image_resources</from>
							<into>/sync-service/src/main/image_resources</into>
						  </path>
						</paths>
					  </extraDirectories>

					  <container>
						<jvmFlags>
						  <!-- When starting the container, tell Java where to find the application.yaml -->
						  <jvmFlag> -Dspring.config.location=/sync-service/src/main/image_resources/application.yaml</jvmFlag>
						</jvmFlags>
					  </container>

					</configuration>

				  </plugin>
				</plugins>
			  </build>
			</profile>
		</profiles>


	When finished, the sync-service/pom.xml looks something like this
    -----------------------------------------------------------------
	<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
             xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd">
        <modelVersion>4.0.0</modelVersion>
        <parent>
            <groupId>com.lessons</groupId>
            <artifactId>angularApp16</artifactId>
            <version>1.0-SNAPSHOT</version>
        </parent>

        <artifactId>sync-service</artifactId>
        <name>sync-service</name>
        <packaging>jar</packaging>



        <dependencyManagement>
            <dependencies>

                <dependency>
                    <!-- Tell Spring Boot to use this **OLDER** version of flyway that works with Postgres 9.6 -->
                    <groupId>org.flywaydb</groupId>
                    <artifactId>flyway-core</artifactId>
                    <version>6.5.7</version>
                </dependency>

                <dependency>
                    <!-- Set the Spring Boot Version -->
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-dependencies</artifactId>
                    <version>3.2.0</version>
                    <type>pom</type>
                    <scope>import</scope>
                </dependency>

            </dependencies>
        </dependencyManagement>



        <dependencies>
            <dependency>
                <!-- Spring Boot Console Application -->
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-starter</artifactId>
            </dependency>

            <dependency>
                <!-- Tell Spring Boot to use this **OLDER** version of flyway that works with Postgres 9.6 -->
                <groupId>org.flywaydb</groupId>
                <artifactId>flyway-core</artifactId>
                <version>6.5.7</version>
            </dependency>

            <dependency>
                <!-- Hikari Data Source / JDBC Connection Pool -->
                <groupId>com.zaxxer</groupId>
                <artifactId>HikariCP</artifactId>
                <version>5.0.1</version>
            </dependency>

            <dependency>
                <!-- Database Driver that is used to by Java to talk to the SQL database -->
                <groupId>org.postgresql</groupId>
                <artifactId>postgresql</artifactId>
                <version>42.5.4</version>
            </dependency>

            <dependency>
                <!-- Send logging from Java Common Logging to SLF4J -->
                <groupId>org.slf4j</groupId>
                <artifactId>jcl-over-slf4j</artifactId>
                <version>2.0.5</version>
            </dependency>

            <dependency>
                <!-- SLF4J will use Logback-classic as its logging implementation -->
                <groupId>ch.qos.logback</groupId>
                <artifactId>logback-classic</artifactId>
                <version>1.4.11</version>
            </dependency>

            <dependency>
                <!-- Add the dependency for the SSLContextFactory's use of DatatypeConverter -->
                <!-- This ensures that SSLContextFactory will compile with Java 17           -->
                <groupId>jakarta.xml.bind</groupId>
                <artifactId>jakarta.xml.bind-api</artifactId>
                <version>3.0.0</version>
            </dependency>

            <dependency>
                <!-- StringUtils Dependency -->
                <groupId>org.apache.commons</groupId>
                <artifactId>commons-lang3</artifactId>
                <version>3.14.0</version>
            </dependency>

            <dependency>
                <groupId>org.apache.commons</groupId>
                <artifactId>commons-collections4</artifactId>
                <version>4.4</version>
            </dependency>

            <dependency>
                <groupId>org.springframework</groupId>
                <artifactId>spring-jdbc</artifactId>
                <version>6.1.2</version>
            </dependency>

            <dependency>
                <!-- AsyncHttpClient Client implementation (used to make outgoing REST calls out to ES) -->
                <groupId>com.ning</groupId>
                <artifactId>async-http-client</artifactId>
                <version>1.9.40</version>
            </dependency>

            <dependency>
                <groupId>com.fasterxml.jackson.core</groupId>
                <artifactId>jackson-core</artifactId>
                <version>2.15.3</version>
            </dependency>
            <dependency>
                <groupId>com.fasterxml.jackson.core</groupId>
                <artifactId>jackson-databind</artifactId>
                <version>2.15.3</version>
            </dependency>
            <dependency>
                <groupId>com.fasterxml.jackson.core</groupId>
                <artifactId>jackson-annotations</artifactId>
                <version>2.15.3</version>
            </dependency>

            <dependency>
                <!-- Add the javax.mail email library (so this webapp can send out emails by connecting to an SMTP server) -->
                <groupId>com.sun.mail</groupId>
                <artifactId>javax.mail</artifactId>
                <version>1.6.2</version>
            </dependency>

            <dependency>
                <!-- Add common backend as a dependency -->
                <groupId>${project.groupId}</groupId>
                <artifactId>common-backend</artifactId>
                <version>${project.version}</version>
            </dependency>

            <dependency>
                <!-- Include the db-migrations as a dependency (so we can run flyway:migrate on application startup) -->
                <groupId>${project.groupId}</groupId>
                <artifactId>db-migrations</artifactId>
                <version>${project.version}</version>
            </dependency>

            <dependency>
                <groupId>junit</groupId>
                <artifactId>junit</artifactId>
                <version>3.8.1</version>
                <scope>test</scope>
            </dependency>

            <dependency>
                <groupId>software.amazon.awssdk</groupId>
                <artifactId>s3</artifactId>
                <version>2.24.6</version>
            </dependency>

            <!-- This is required for the AWS SDK to be able to assume the service account permissions of the Kubernetes pod -->
            <dependency>
                <groupId>software.amazon.awssdk</groupId>
                <artifactId>sts</artifactId>
                <version>2.24.6</version>
            </dependency>

        </dependencies>

        <build>

            <plugins>
                <plugin>
                    <!-- This plugin provides the tools needed to repackage the Spring Boot JAR into a runnable JAR
                         Run this command to generate the runnable Spring Boot Jar
                            mvn clean package  *or*
                            mvn clean package spring-boot:repackage
                     -->
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-maven-plugin</artifactId>
                    <version>3.2.0</version>
                    <configuration>
                        <addResources>true</addResources>
                    </configuration>

                    <executions>
                        <execution>
                            <goals>
                                <goal>repackage</goal>
                            </goals>
                            <configuration>
                                <classifier>exec</classifier>
                            </configuration>
                        </execution>
                    </executions>

                </plugin>
                <plugin>
                    <groupId>org.apache.maven.plugins</groupId>
                    <artifactId>maven-compiler-plugin</artifactId>
                    <configuration>
                        <source>17</source>
                        <target>17</target>
                    </configuration>
                </plugin>


                <plugin>
                    <!-- Use the git-commit-id plugin to generate the git.properties file that has info about who compiled the app  -->
                    <!-- See https://github.com/git-commit-id/git-commit-id-maven-plugin                                            -->
                    <groupId>io.github.git-commit-id</groupId>
                    <artifactId>git-commit-id-maven-plugin</artifactId>
                    <version>7.0.0</version>

                    <executions>
                        <execution>
                            <id>get-the-git-infos</id>
                            <goals>
                                <goal>revision</goal>
                            </goals>
                        </execution>
                        <execution>
                            <id>validate-the-git-infos</id>
                            <goals>
                                <goal>validateRevision</goal>
                            </goals>
                        </execution>
                    </executions>

                    <configuration>
                        <verbose>false</verbose>
                        <generateGitPropertiesFile>true</generateGitPropertiesFile>
                    </configuration>
                </plugin>

            </plugins>
        </build>

        <profiles>

            <!--    B U I L D     I M A G E      P R O F I L E      (for running this app in a container)  -->
            <profile>
                <id>buildImage</id>

                <!-- When running this profile, do *NOT* include the src/main/resources/application.yaml in the build -->
                <build>
                    <resources>
                        <resource>
                            <filtering>false</filtering>
                            <directory>src/main/resources</directory>
                            <excludes>
                                <exclude>application.yaml</exclude>
                            </excludes>
                        </resource>
                    </resources>

                    <plugins>
                        <plugin>
                            <!-- Use the jib-maven-plugin to build the container and push it up to a registry [without having to install Docker] -->
                            <groupId>com.google.cloud.tools</groupId>
                            <artifactId>jib-maven-plugin</artifactId>
                            <version>3.4.4</version>

                            <executions>
                                <execution>
                                    <phase>package</phase>
                                    <goals>
                                        <!-- Possible goals are build and dockerBuild   -->
                                        <!--   The "build"       goal does not require docker / build the image and push it to a repo                 -->
                                        <!--   The "dockerBuild" goal requires docker         / build the image and push to the local daemon daemon   -->
                                        <goal>dockerBuild</goal>
                                    </goals>
                                </execution>
                            </executions>

                            <configuration>
                                <from>
                                    <!-- This source image runs linux with JDK 17.07 -->
                                    <image>eclipse-temurin:17.0.7_7-jdk@sha256:9dd6a19e4819b066aa2bd8e54d5988a49cca29736fe5447cb0a57daa975f8935</image>
                                </from>

                                <to>
                                    <!-- Specify the destination name in the AWS Container Registry -->
                                    <image>${aws.ecr.uri}:${aws.env.name}-${project.artifactId}-${project.version}</image>
                                </to>


                                <extraDirectories>
                                    <paths>
                                        <path>
                                            <!-- Copies everything from 'src/main/image_resources' into '/sync-service-/src/main/image_resources' on the container. -->
                                            <from>src/main/image_resources</from>
                                            <into>/sync-service/src/main/image_resources</into>
                                        </path>
                                    </paths>
                                </extraDirectories>

                                <container>
                                    <jvmFlags>
                                        <!-- When starting the container, tell Java where to find the application.yaml -->
                                        <jvmFlag> -Dspring.config.location=/sync-service/src/main/image_resources/application.yaml</jvmFlag>
                                    </jvmFlags>
                                </container>

                            </configuration>

                        </plugin>
                    </plugins>
                </build>
            </profile>


            <!--    B U I L D     I M A G E    A N D    P U S H        P R O F I L E      (for running this app in a container)  -->
            <profile>
                <id>buildImageAndPush</id>

                <!-- When running this profile, do *NOT* include the src/main/resources/application.yaml in the build -->
                <build>
                    <resources>
                        <resource>
                            <filtering>false</filtering>
                            <directory>src/main/resources</directory>
                            <excludes>
                                <exclude>application.yaml</exclude>
                            </excludes>
                        </resource>
                    </resources>

                    <plugins>
                        <plugin>
                            <!-- Use the jib-maven-plugin to build the container and push it up to a registry [without having to install Docker] -->
                            <groupId>com.google.cloud.tools</groupId>
                            <artifactId>jib-maven-plugin</artifactId>
                            <version>3.4.4</version>

                            <executions>
                                <execution>
                                    <phase>package</phase>
                                    <goals>
                                        <!-- Possible goals are build and dockerBuild   -->
                                        <!--   The "build"       goal does not require docker / build the image and push it to a repo                 -->
                                        <!--   The "dockerBuild" goal requires docker         / build the image and push to the local daemon daemon   -->
                                        <goal>build</goal>
                                    </goals>
                                </execution>
                            </executions>

                            <configuration>
                                <from>
                                    <!-- Define the source image that will be executed            -->
                                    <!-- See https://hub.docker.com/_/eclipse-temurin/tags        -->

                                    <!-- This source image runs linux with JDK 17.07 -->
                                    <image>eclipse-temurin:17.0.7_7-jdk@sha256:9dd6a19e4819b066aa2bd8e54d5988a49cca29736fe5447cb0a57daa975f8935</image>
                                </from>

                                <to>
                                    <!-- Specify the destination name in the AWS Container Registry -->
                                    <image>${aws.ecr.uri}:${user.name}-${project.artifactId}-${project.version}</image>
                                </to>


                                <extraDirectories>
                                    <paths>
                                        <path>
                                            <!-- Copies everything from 'src/main/image_resources' into '/sync-service-/src/main/image_resources' on the container. -->
                                            <from>src/main/image_resources</from>
                                            <into>/sync-service/src/main/image_resources</into>
                                        </path>
                                    </paths>
                                </extraDirectories>

                                <container>
                                    <jvmFlags>
                                        <!-- When starting the container, tell Java where to find the application.yaml -->
                                        <jvmFlag> -Dspring.config.location=/sync-service/src/main/image_resources/application.yaml</jvmFlag>
                                    </jvmFlags>
                                </container>

                            </configuration>

                        </plugin>
                    </plugins>
                </build>
            </profile>


            <profile>
                <!-- D E F A U L T       M A V E N      P R O F I L E -->
                <id>defaultProfile</id>
                <activation>
                    <activeByDefault>true</activeByDefault>
                </activation>

                <!-- When running any other build profile, include *ALL* files from the sync/src/main/resources into the JAR file -->
                <build>
                    <resources>
                        <resource>
                            <directory>src/main/resources</directory>
                            <filtering>false</filtering>
                        </resource>
                    </resources>
                </build>
            </profile>

        </profiles>


    </project>




 2.  Add the "buildImage" and "buildImageAndPush" profiles to backend/pom.xml

		<profiles>

			<!--    B U I L D     I M A G E      P R O F I L E      (for running this app in a container)  -->
			<profile>
			  <id>buildImage</id>

			  <!-- When running this profile, do *NOT* include the src/main/resources/application.yaml in the build -->
			  <build>
				<resources>
				  <resource>
					<filtering>false</filtering>
					<directory>src/main/resources</directory>
					<excludes>
					  <exclude>application.yaml</exclude>
					</excludes>
				  </resource>
				</resources>

				<plugins>
				  <plugin>
					<!-- Use the jib-maven-plugin to build the container and push it up to a registry [without having to install Docker] -->
					<groupId>com.google.cloud.tools</groupId>
					<artifactId>jib-maven-plugin</artifactId>
					<version>3.4.4</version>

					<executions>
					  <execution>
						<phase>package</phase>
						<goals>
						  <!-- Possible goals are build and dockerBuild   -->
						  <!--   The "build"       goal does not require docker / build the image and push it to a repo                 -->
						  <!--   The "dockerBuild" goal requires docker         / build the image and push to the local daemon daemon   -->
						  <goal>dockerBuild</goal>
						</goals>
					  </execution>
					</executions>

					<configuration>
					  <from>
						<!-- Define the source image that will be executed            -->
						<!-- See https://hub.docker.com/_/eclipse-temurin/tags        -->

						<!-- This source image runs linux with JDK 17.07 -->
						<image>eclipse-temurin:17.0.7_7-jdk@sha256:9dd6a19e4819b066aa2bd8e54d5988a49cca29736fe5447cb0a57daa975f8935</image>
					  </from>

					  <to>
						<!-- Specify the destination name in the AWS Container Registry -->
						<image>${aws.ecr.uri}:${aws.env.name}-${project.artifactId}-${project.version}</image>
					  </to>


					  <extraDirectories>
						<paths>
						  <path>
							<!-- Copies everything from 'src/main/image_resources' into '/sync-service-/src/main/image_resources' on the container. -->
							<from>src/main/image_resources</from>
							<into>/backend/src/main/image_resources</into>
						  </path>
						</paths>
					  </extraDirectories>

					  <container>
						<jvmFlags>
						  <!-- When starting the container, tell Java where to find the application.yaml -->
						  <jvmFlag> -Dspring.config.location=/backend/src/main/image_resources/application.yaml</jvmFlag>
						</jvmFlags>
					  </container>

					</configuration>

				  </plugin>
				</plugins>
			  </build>
			</profile>




			<!--    B U I L D     I M A G E    A N D     P U S H       P R O F I L E      (for running this app in a container)  -->
			<profile>
			  <id>buildImageAndPush</id>

			  <!-- When running this profile, do *NOT* include the src/main/resources/application.yaml in the build -->
			  <build>
				<resources>
				  <resource>
					<filtering>false</filtering>
					<directory>src/main/resources</directory>
					<excludes>
					  <exclude>application.yaml</exclude>
					</excludes>
				  </resource>
				</resources>

				<plugins>
				  <plugin>
					<!-- Use the jib-maven-plugin to build the container and push it up to a registry [without having to install Docker] -->
					<groupId>com.google.cloud.tools</groupId>
					<artifactId>jib-maven-plugin</artifactId>
					<version>3.4.4</version>

					<executions>
					  <execution>
						<phase>package</phase>
						<goals>
						  <!-- Possible goals are build and dockerBuild   -->
						  <!--   The "build"       goal does not require docker / build the image and push it to a repo                 -->
						  <!--   The "dockerBuild" goal requires docker         / build the image and push to the local daemon daemon   -->
						  <goal>build</goal>
						</goals>
					  </execution>
					</executions>

					<configuration>
					  <from>
						<!-- Define the source image that will be executed            -->
						<!-- See https://hub.docker.com/_/eclipse-temurin/tags        -->

						<!-- This source image runs linux with JDK 17.07 -->
						<image>eclipse-temurin:17.0.7_7-jdk@sha256:9dd6a19e4819b066aa2bd8e54d5988a49cca29736fe5447cb0a57daa975f8935</image>
					  </from>

					  <to>
						<!-- Specify the destination name in the AWS Container Registry -->
						<image>${aws.ecr.uri}:${aws.env.name}-${project.artifactId}-${project.version}</image>
					  </to>


					  <extraDirectories>
						<paths>
						  <path>
							<!-- Copies everything from 'src/main/image_resources' into '/sync-service-/src/main/image_resources' on the container. -->
							<from>src/main/image_resources</from>
							<into>/backend/src/main/image_resources</into>
						  </path>
						</paths>
					  </extraDirectories>

					  <container>
						<jvmFlags>
						  <!-- When starting the container, tell Java where to find the application.yaml -->
						  <jvmFlag> -Dspring.config.location=/backend/src/main/image_resources/application.yaml</jvmFlag>
						</jvmFlags>
					  </container>

					</configuration>

				  </plugin>
				</plugins>
			  </build>
			</profile>

			<profile>
			  <!-- When running any other build profile, include *ALL* files from the backend/src/main/resources into the JAR file -->
			  <id>defaultProfile</id>
			  <activation>
				<activeByDefault>true</activeByDefault>
			  </activation>
			  <build>
				<resources>
				  <resource>
					<directory>src/main/resources</directory>
					<filtering>true</filtering>
				  </resource>
				</resources>
			  </build>
			</profile>
		</profiles>




	When finished, the backend/pom.xml looks something like this
	------------------------------------------------------------
	<?xml version="1.0" encoding="UTF-8"?>
	<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
			 xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
	  <modelVersion>4.0.0</modelVersion>

	  <parent>
		<artifactId>angularApp16</artifactId>
		<groupId>com.lessons</groupId>
		<version>1.0-SNAPSHOT</version>
	  </parent>

	  <artifactId>backend</artifactId>
	  <version>1.0-SNAPSHOT</version>

	  <name>backend</name>
	  <packaging>jar</packaging>



	  <dependencyManagement>
		<dependencies>

		  <dependency>
			<!-- Set the Spring Boot Version -->
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-dependencies</artifactId>
			<version>3.2.0</version>
			<type>pom</type>
			<scope>import</scope>
		  </dependency>

		</dependencies>
	  </dependencyManagement>




	  <dependencies>

		<dependency>
		  <!-- Include the front-end as a dependency so the front-end is compiled *BEFORE* the backend is compiled -->
		  <groupId>${project.groupId}</groupId>
		  <artifactId>frontend</artifactId>
		  <version>${project.version}</version>
		</dependency>

		<dependency>
		  <!-- Spring Boot Web -->
		  <groupId>org.springframework.boot</groupId>
		  <artifactId>spring-boot-starter-web</artifactId>

		  <exclusions>
			<exclusion>
			  <!-- Remove Tomcat from Spring Boot -->
			  <groupId>org.springframework.boot</groupId>
			  <artifactId>spring-boot-starter-tomcat</artifactId>
			</exclusion>

			<exclusion>
			  <!-- Remove logging from spring as we will use logback -->
			  <groupId>org.springframework.boot</groupId>
			  <artifactId>spring-boot-starter-logging</artifactId>
			</exclusion>
		  </exclusions>
		</dependency>

		<dependency>
		  <!-- Add Dependency for the Undertow App Server -->
		  <groupId>org.springframework.boot</groupId>
		  <artifactId>spring-boot-starter-undertow</artifactId>

		  <exclusions>
			<exclusion>
			  <!-- Remove logging from undertow as we will use logback -->
			  <groupId>org.springframework.boot</groupId>
			  <artifactId>spring-boot-starter-logging</artifactId>
			</exclusion>
		  </exclusions>
		</dependency>

		<dependency>
		  <!-- Hikari Data Source / JDBC Connection Pool -->
		  <groupId>com.zaxxer</groupId>
		  <artifactId>HikariCP</artifactId>
		  <version>5.0.1</version>
		</dependency>

		<dependency>
		  <!-- Database Driver that is used to by Java to talk to the SQL database -->
		  <groupId>org.postgresql</groupId>
		  <artifactId>postgresql</artifactId>
		  <version>42.5.4</version>
		</dependency>

		<dependency>
		  <!-- Send logging from Java Common Logging to SLF4J -->
		  <groupId>org.slf4j</groupId>
		  <artifactId>jcl-over-slf4j</artifactId>
		  <version>2.0.5</version>
		</dependency>

		<dependency>
		  <!-- SLF4J will use Logback-classic as its logging implementation -->
		  <groupId>ch.qos.logback</groupId>
		  <artifactId>logback-classic</artifactId>
		  <version>1.4.11</version>
		</dependency>

		<dependency>
		  <!-- Add the dependency for the SSLContextFactory's use of DatatypeConverter -->
		  <!-- This ensures that SSLContextFactory will compile with Java 17           -->
		  <groupId>jakarta.xml.bind</groupId>
		  <artifactId>jakarta.xml.bind-api</artifactId>
		  <version>3.0.0</version>
		</dependency>

		<dependency>
		  <!-- StringUtils Dependency -->
		  <groupId>org.apache.commons</groupId>
		  <artifactId>commons-lang3</artifactId>
		  <version>3.14.0</version>
		</dependency>

		<dependency>
		  <!-- Apache POI dependency (used to generate xlsx files) -->
		  <groupId>org.apache.poi</groupId>
		  <artifactId>poi-ooxml</artifactId>
		  <version>4.1.2</version>
		  <scope>test</scope>
		</dependency>

		<dependency>
		  <groupId>org.springframework</groupId>
		  <artifactId>spring-jdbc</artifactId>
		  <version>6.1.2</version>
		</dependency>

		<dependency>
		  <groupId>org.springframework</groupId>
		  <artifactId>spring-web</artifactId>
		  <version>6.1.2</version>
		</dependency>

		<dependency>
		  <groupId>org.springframework.security</groupId>
		  <artifactId>spring-security-web</artifactId>
		  <version>6.1.2</version>
		</dependency>

		<dependency>
		  <groupId>org.springframework.security</groupId>
		  <artifactId>spring-security-config</artifactId>
		  <version>6.1.2</version>
		</dependency>

		<dependency>
		  <groupId>commons-io</groupId>
		  <artifactId>commons-io</artifactId>
		  <version>2.11.0</version>
		</dependency>

		<dependency>
		  <groupId>com.fasterxml.jackson.core</groupId>
		  <artifactId>jackson-core</artifactId>
		  <version>2.15.3</version>
		</dependency>
		<dependency>
		  <groupId>com.fasterxml.jackson.core</groupId>
		  <artifactId>jackson-databind</artifactId>
		  <version>2.15.3</version>
		</dependency>
		<dependency>
		  <groupId>com.fasterxml.jackson.core</groupId>
		  <artifactId>jackson-annotations</artifactId>
		  <version>2.15.3</version>
		</dependency>

		<dependency>
		  <!-- Sprint Boot / Keycloak Integration / Add the OAuth2/OpenID client to talk to Keycloak and authenticate users -->
		  <groupId>org.springframework.boot</groupId>
		  <artifactId>spring-boot-starter-oauth2-client</artifactId>
		</dependency>

		<dependency>
		  <groupId>org.apache.commons</groupId>
		  <artifactId>commons-collections4</artifactId>
		  <version>4.4</version>
		</dependency>

		<dependency>
		  <!-- AsyncHttpClient Client implementation (used to make outgoing REST calls out to ES) -->
		  <groupId>com.ning</groupId>
		  <artifactId>async-http-client</artifactId>
		  <version>1.9.40</version>
		</dependency>

		<dependency>
		  <!-- Add common backend as a dependency -->
		  <groupId>${project.groupId}</groupId>
		  <artifactId>common-backend</artifactId>
		  <version>${project.version}</version>
		</dependency>

		<dependency>
		  <!-- Add wrapper to invoke virus-scanning with clamAV -->
		  <groupId>com.eurodyn.qlack.util</groupId>
		  <artifactId>qlack-util-clam-av</artifactId>
		  <version>3.5.3</version>

		  <exclusions>
			<!-- The qlack-util-clam-av dependency comes with lots of stuff we do not need -->
			<exclusion>
			  <groupId>org.springframework.boot</groupId>
			  <artifactId>spring-boot-configuration-processor</artifactId>
			</exclusion>

			<exclusion>
			  <groupId>org.springframework.boot</groupId>
			  <artifactId>spring-boot-starter</artifactId>
			</exclusion>

			<exclusion>
			  <groupId>org.springframework.boot</groupId>
			  <artifactId>spring-boot-starter-data-jpa</artifactId>
			</exclusion>

			<exclusion>
			  <groupId>org.hibernate</groupId>
			  <artifactId>hibernate-core</artifactId>
			</exclusion>

			<exclusion>
			  <groupId>org.jboss.logging</groupId>
			  <artifactId>jboss-logging</artifactId>
			</exclusion>

			<exclusion>
			  <groupId>com.zaxxer</groupId>
			  <artifactId>HikariCP</artifactId>
			</exclusion>

			<exclusion>
			  <groupId>org.springframework</groupId>
			  <artifactId>spring-jdbc</artifactId>
			</exclusion>

			<exclusion>
			  <groupId>org.springframework</groupId>
			  <artifactId>spring-aop</artifactId>
			</exclusion>

			<exclusion>
			  <groupId>commons-codec</groupId>
			  <artifactId>commons-codec</artifactId>
			</exclusion>

			<exclusion>
			  <groupId>com.querydsl</groupId>
			  <artifactId>querydsl-core</artifactId>
			</exclusion>

		  </exclusions>
		</dependency>

		<dependency>
		  <!-- Send logging from Java Util Logging to SLF4J -->
		  <groupId>org.slf4j</groupId>
		  <artifactId>jul-to-slf4j</artifactId>
		  <version>1.7.30</version>
		</dependency>

		<dependency>
		  <groupId>junit</groupId>
		  <artifactId>junit</artifactId>
		  <version>4.13.2</version>
		  <scope>test</scope>
		</dependency>

	  </dependencies>

	  <build>

		<plugins>
		  <plugin>
			<!-- This plugin provides the tools needed to repackage the Spring Boot JAR into a runnable JAR
				 Run this command to generate the runnable Spring Boot Jar
					mvn clean package  *or*
					mvn clean package spring-boot:repackage
			 -->
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-maven-plugin</artifactId>
			<version>3.2.0</version>
			<configuration>
			  <addResources>true</addResources>
			</configuration>

			<executions>
			  <execution>
				<goals>
				  <goal>repackage</goal>
				</goals>
				<configuration>
				  <classifier>exec</classifier>
				</configuration>
			  </execution>
			</executions>

		  </plugin>
		  <plugin>
			<groupId>org.apache.maven.plugins</groupId>
			<artifactId>maven-compiler-plugin</artifactId>
			<configuration>
			  <source>17</source>
			  <target>17</target>
			</configuration>
		  </plugin>


		  <plugin>
			<!-- Use the git-commit-id plugin to generate the git.properties file that has info about who compiled the app  -->
			<!-- See https://github.com/git-commit-id/git-commit-id-maven-plugin                                            -->
			<groupId>io.github.git-commit-id</groupId>
			<artifactId>git-commit-id-maven-plugin</artifactId>
			<version>7.0.0</version>

			<executions>
			  <execution>
				<id>get-the-git-infos</id>
				<goals>
				  <goal>revision</goal>
				</goals>
			  </execution>
			  <execution>
				<id>validate-the-git-infos</id>
				<goals>
				  <goal>validateRevision</goal>
				</goals>
			  </execution>
			</executions>

			<configuration>
			  <verbose>false</verbose>
			  <generateGitPropertiesFile>true</generateGitPropertiesFile>
			</configuration>
		  </plugin>

		</plugins>
	  </build>


	  <profiles>


		<!--    B U I L D     I M A G E      P R O F I L E      (for running this app in a container)  -->
		<profile>
		  <id>buildImage</id>

		  <!-- When running this profile, do *NOT* include the src/main/resources/application.yaml in the build -->
		  <build>
			<resources>
			  <resource>
				<filtering>false</filtering>
				<directory>src/main/resources</directory>
				<excludes>
				  <exclude>application.yaml</exclude>
				</excludes>
			  </resource>
			</resources>

			<plugins>
			  <plugin>
				<!-- Use the jib-maven-plugin to build the container and push it up to a registry [without having to install Docker] -->
				<groupId>com.google.cloud.tools</groupId>
				<artifactId>jib-maven-plugin</artifactId>
				<version>3.4.4</version>

				<executions>
				  <execution>
					<phase>package</phase>
					<goals>
					  <!-- Possible goals are build and dockerBuild   -->
					  <!--   The "build"       goal does not require docker / build the image and push it to a repo                 -->
					  <!--   The "dockerBuild" goal requires docker         / build the image and push to the local daemon daemon   -->
					  <goal>dockerBuild</goal>
					</goals>
				  </execution>
				</executions>

				<configuration>
				  <from>
					<!-- Define the source image that will be executed            -->
					<!-- See https://hub.docker.com/_/eclipse-temurin/tags        -->

					<!-- This source image runs linux with JDK 17.07 -->
					<image>eclipse-temurin:17.0.7_7-jdk@sha256:9dd6a19e4819b066aa2bd8e54d5988a49cca29736fe5447cb0a57daa975f8935</image>
				  </from>

				  <to>
					<!-- Specify the destination name in the AWS Container Registry -->
					<image>${aws.ecr.uri}:${aws.env.name}-${project.artifactId}-${project.version}</image>
				  </to>


				  <extraDirectories>
					<paths>
					  <path>
						<!-- Copies everything from 'src/main/image_resources' into '/sync-service-/src/main/image_resources' on the container. -->
						<from>src/main/image_resources</from>
						<into>/backend/src/main/image_resources</into>
					  </path>
					</paths>
				  </extraDirectories>

				  <container>
					<jvmFlags>
					  <!-- When starting the container, tell Java where to find the application.yaml -->
					  <jvmFlag> -Dspring.config.location=/backend/src/main/image_resources/application.yaml</jvmFlag>
					</jvmFlags>
				  </container>

				</configuration>

			  </plugin>
			</plugins>
		  </build>
		</profile>




		<!--    B U I L D     I M A G E    A N D     P U S H       P R O F I L E      (for running this app in a container)  -->
		<profile>
		  <id>buildImageAndPush</id>

		  <!-- When running this profile, do *NOT* include the src/main/resources/application.yaml in the build -->
		  <build>
			<resources>
			  <resource>
				<filtering>false</filtering>
				<directory>src/main/resources</directory>
				<excludes>
				  <exclude>application.yaml</exclude>
				</excludes>
			  </resource>
			</resources>

			<plugins>
			  <plugin>
				<!-- Use the jib-maven-plugin to build the container and push it up to a registry [without having to install Docker] -->
				<groupId>com.google.cloud.tools</groupId>
				<artifactId>jib-maven-plugin</artifactId>
				<version>3.4.4</version>

				<executions>
				  <execution>
					<phase>package</phase>
					<goals>
					  <!-- Possible goals are build and dockerBuild   -->
					  <!--   The "build"       goal does not require docker / build the image and push it to a repo                 -->
					  <!--   The "dockerBuild" goal requires docker         / build the image and push to the local daemon daemon   -->
					  <goal>build</goal>
					</goals>
				  </execution>
				</executions>

				<configuration>
				  <from>
					<!-- Define the source image that will be executed            -->
					<!-- See https://hub.docker.com/_/eclipse-temurin/tags        -->

					<!-- This source image runs linux with JDK 17.07 -->
					<image>eclipse-temurin:17.0.7_7-jdk@sha256:9dd6a19e4819b066aa2bd8e54d5988a49cca29736fe5447cb0a57daa975f8935</image>
				  </from>

				  <to>
					<!-- Specify the destination name in the AWS Container Registry -->
					<image>${aws.ecr.uri}:${aws.env.name}-${project.artifactId}-${project.version}</image>
				  </to>


				  <extraDirectories>
					<paths>
					  <path>
						<!-- Copies everything from 'src/main/image_resources' into '/sync-service-/src/main/image_resources' on the container. -->
						<from>src/main/image_resources</from>
						<into>/backend/src/main/image_resources</into>
					  </path>
					</paths>
				  </extraDirectories>

				  <container>
					<jvmFlags>
					  <!-- When starting the container, tell Java where to find the application.yaml -->
					  <jvmFlag> -Dspring.config.location=/backend/src/main/image_resources/application.yaml</jvmFlag>
					</jvmFlags>
				  </container>

				</configuration>

			  </plugin>
			</plugins>
		  </build>
		</profile>



		<profile>
		  <!-- When running any other build profile, include *ALL* files from the backend/src/main/resources into the JAR file -->
		  <id>defaultProfile</id>
		  <activation>
			<activeByDefault>true</activeByDefault>
		  </activation>
		  <build>
			<resources>
			  <resource>
				<directory>src/main/resources</directory>
				<filtering>true</filtering>
			  </resource>
			</resources>
		  </build>
		</profile>

	  </profiles>

	</project>



 3. Add these directories:
          backend/src/main/image_resources/
          sync-service/src/main/image_resources/



 4. Create this file:  sync-service/src/main/image_resources/application.yaml
    a. Copy the sync-service/src/main/resources/application.yaml  to  sync-service/src/main/image_resources/application.yaml
    b. Edit sync-service/src/main/image_resources/application.yaml
       Replace credentials with environment variables

		###############################################################################
		# application.yaml   (used when running in a container)
		###############################################################################

		# Set the Active profile to be dev
		spring.profiles.active: prod

		# Tell spring not to run flyway on start-up
		spring.flyway.enabled: false



		##########################################################
		# Run Settings
		#########################################################
		# If true,  then this runs as a service  (so it refreshes on startup and every night)
		# If false, then this runs once and then stops
		run.service_mode: false

		# If true, then a sync process will be performed on startup
		run.sync_on_startup: true



		##########################################################
		# Database Settings
		##########################################################
		app.datasource:
			driver-class-name: org.postgresql.Driver
			url: jdbc:postgresql://${POSTGRES_HOSTNAME}/${POSTGRES_DB_NAME}
			username: ${POSTGRES_DB_USERNAME}
			password: ${POSTGRES_DB_PASSWORD}
			schema: ${POSTGRES_SCHEMA_NAME}
			maxPoolSize: ${POSTGRES_POOL_SIZE:20}
			database-name: ${POSTGRES_DB_NAME}
			flyway-migrate-on-startup: true



		###########################################################
		# ElasticSearch Settings
		##########################################################
		es:
			url: ${ES_URL}
			ssl_enabled: true
			key-store: ${INCOMING_KEYSTORE_FILEPATH}
			key-store-password:  ${INCOMING_KEYSTORE_PASSWORD}
			key-store-type: JKS
			trust-store:  ${INCOMING_TRUSTSTORE_FILEPATH}
			trust-store-password: ${INCOMING_TRUSTSTORE_PASSWORD}
			trust-store-type: JKS
			authentication.principal: ${ES_USERNAME}
			authentication.password:  ${ES_PASSWORD}



		##############################################################################
		# Email Settings
		#
		# If email.mode==off,  then the emails are not sent out but are logged
		# If email.mode==demo, then the emails are sent only to the email.demo.recipient_email
		# If email.mode==prod, then the emails are sent out to the assigned userid
		#
		# NOTE:  The EmailService will extract the hostname from the email.smtp.host.url
		##############################################################################
		email.mode:      'off'                           # possible modes are off, demo, and prod


		##########################################################
		# Document Settings
		##########################################################
		s3.enabled: false



 5. Create this file:  backend/src/main/image_resources/application.yaml
    NOTE:  Don't forget to change the server.servlet.context-path to be something real like /app16
    NOTE:  Update this to use SSL and Keycloak sections
    a. Copy the backend/src/main/resources/application.yaml  to  backend/src/main/image_resources/application.yaml
    b. Edit backend/src/main/image_resources/application.yaml
       Replace credentials with environment variables

		###############################################################################
		# application.yaml   (used when running in a container)
		###############################################################################
		name: app16
		server.servlet.context-path: /app16
		server.port: 8080



		# Disable cors check because we are running in local dev mode
		# NOTE:  order is important.  Make sure disable.cors comes *AFTER* you set the profile
		disable.cors: true


		# Show Exception info to local developers
		exception_handler.return_dev_info: false


		##########################################################
		# Database Settings
		##########################################################
		app.datasource:
		  driver-class-name: org.postgresql.Driver
		  url: jdbc:postgresql://${POSTGRES_HOSTNAME}/${POSTGRES_DB_NAME}
		  username: ${POSTGRES_DB_USERNAME}
		  password: ${POSTGRES_DB_PASSWORD}
		  schema: ${POSTGRES_SCHEMA_NAME}
		  maxPoolSize: ${POSTGRES_POOL_SIZE:20}
		  database-name: ${POSTGRES_DB_NAME}
		  flyway-migrate-on-startup: true


		###########################################################
		# ElasticSearch Settings
		##########################################################
		es:
		  url: ${ES_URL}
		  ssl_enabled: true
		  key-store: ${INCOMING_KEYSTORE_FILEPATH}
		  key-store-password:  ${INCOMING_KEYSTORE_PASSWORD}
		  key-store-type: JKS
		  trust-store:  ${INCOMING_TRUSTSTORE_FILEPATH}
		  trust-store-password: ${INCOMING_TRUSTSTORE_PASSWORD}
		  trust-store-type: JKS
		  authentication.principal: ${ES_USERNAME}
		  authentication.password:  ${ES_PASSWORD}


		##########################################################
		# Security & SSL Settings
		#
		# Set the security mode to "keycloak" so it authenticates against keycloak
		##########################################################
		security.mode: keycloak    # Possible values are localdev, citadel, and keycloak / set to keycloak to use keycloak authentication

		server:
			ssl:
			  key-store: ${INCOMING_KEYSTORE_FILEPATH}
			  key-store-password: ${INCOMING_KEYSTORE_PASSWORD}
			  key-store-type: JKS
			  client-auth: need
			  trust-store: ${INCOMING_TRUSTSTORE_FILEPATH}
			  trust-store-password: ${INCOMING_TRUSTSTORE_PASSWORD}
			  trust-store-type: JKS
			  enabled: true

		# Secure the cookies
		server.servlet.session.cookie.secure: true
		server.servlet.session.cookie.http-only: true

		server.use-forward-headers: true


		##############################################################################
		# Keycloak Settings for Spring Security
		#
		# The realm url is probably something like https://keycloak.rbr-tech.com:8444/realms/MyRealm
		##############################################################################
		spring.security.oauth2.client.registration.keycloak.client-id: ${KEYCLOAK_CLIENT_ID}
		spring.security.oauth2.client.registration.keycloak.client-secret: ${KEYCLOAK_CLIENT_SECRET}
		spring.security.oauth2.client.registration.keycloak.authorization-grant-type: authorization_code
		spring.security.oauth2.client.registration.keycloak.scope: openid,email,profile
		spring.security.oauth2.client.provider.keycloak.issuer-uri: ${KEYCLOAK_ISSUER_URI}
		spring.security.oauth2.client.provider.keycloak.user-name-attribute: preferred_username


		##########################################################
		# File Upload Settings
		##########################################################
		spring.servlet.multipart.enabled: true

		# Set the maximum file upload size for one file    (-1 is unlimited)
		spring.servlet.multipart.max-file-size: 300MB

		# Set the maximum request size
		# If a user uploads 5 files of 1 MB, then the entire request size is 5 MB   (-1 is unlimited)
		spring.servlet.multipart.max-request-size: 400MB


		##########################################################
		# Document Settings
		##########################################################
		root.dir: /data
		uploads.dir: ${root.dir}/uploads
		s3.enabled: false


		##########################################################
		# Virus Scanning Settings
		##########################################################
		virus-scanning.enabled: false
		qlack.util.clamav.host: localhost
		qlack.util.clamav.port: 3310
		qlack.util.clamav.socket.timeout: 100000




 6. Add the Spring Boot Oauth2 client to the backend/pom.xml    (so the webapp can talk to keycloak via Oauth2/OpenID

		<dependency>
		  <!-- Sprint Boot / Keycloak Integration / Add the OAuth2/OpenID client to talk to Keycloak and authenticate users -->
		  <groupId>org.springframework.boot</groupId>
		  <artifactId>spring-boot-starter-oauth2-client</artifactId>
		</dependency>



 7. Verify that the <to><image> has the correct private repo
    a. Edit the backend/pom.xml and sync-service.pom.xml

    b. Make sure the private-repo has the correct url

		  <to>
			<!-- Specify the destination name in the AWS Container Registry -->
			<image>${aws.ecr.uri}:${aws.env.name}-${project.artifactId}-${project.version}</image>
		  </to>


 8. Build and push the containers to a container repo


		Build & Push Approach 1 / Use -PbuildImageAndPush and provide username/password on the command-line
        ---------------------------------------------------------------------------------------------------
		a. Configure AWS credentials
		   unix> aws configure

		   AWS Access Key ID:
		   AWS Secret Access Key:
		   Default region name:
		   Default output format:


		b. Get the password and store it in a variable
           unix> export AWS_REGION=$(aws ec2 describe-availability-zones --output text --query 'AvailabilityZones[0].[RegionName]')
           unix> export PASSWORD=`aws ecr get-login-password --region $AWS_REGION`

        c. Build and push (using the password)
           WARNING:  You must pass-in the BOTH username *AND* password on the command-line for this to work
                     If you pass-in ONLY the password on the command-line, the jib maven plugin does not pass-in the info correctly
            unix> mvn  -Djib.to.auth.username=AWS -Djib.to.auth.password=$PASSWORD clean package -Pprod -PbuildImageAndPush




		Build & Push Approach 2 / Use -PbuildImageAndPush and use the "docker login" command to set credentials to push to AWS ECR
        --------------------------------------------------------------------------------------------------------------------------
		a. On Rocky Linux 9, install docker
           unix> sudo dnf config-manager --add-repo https://download.docker.com/linux/rhel/docker-ce.repo
           unix> sudo dnf install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin


		b. Configure AWS credentials
		   unix> aws configure

           AWS Access Key ID:
           AWS Secret Access Key:
           Default region name:
           Default output format:


		c. Get the command to login to your AWS to push up
		   1) Login to AWS as dev.user
		   2) Go to Services -> ECR
		   3) Click on Private Repositories
		   4) Check your private repository -- e.g., apps/app16
		   5) Press "View push commands"
           6) Copy the command to retrieve an authentication token
           7) Run that command
              unix> aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin 524647912468.dkr.ecr.us-east-1.amazonaws.com

			  WARNING! Your password will be stored unencrypted in /home/adam/.docker/config.json.
			  Configure a credential helper to remove this warning. See
			  https://docs.docker.com/engine/reference/commandline/login/#credential-stores

			  Login Succeeded


		d. Build and push to your AWS ECR repository
		   unix> cd ~/intellijProjects/angularApp16
		   unix> mvn clean package -Pprod -PbuildImageAndPush


		e. Go to your AWS -> ECR -> Private Repositories -> apps/app16
		   -- Verify that you see these containers:
		   			dev-backend-1.0-SNAPSHOT
		   			dev-sync-service-1.0-SNAPSHOT




		Build & Push Approach 3 / Use -PbuildImageAndPush and provide username/password on the command-line
        ---------------------------------------------------------------------------------------------------
		unix> export USERNAME=traderres
		unix> export PASSWORD='secret'
		unix> mvn clean package -Pprod -PbuildImageAndPush -Djib.to.auth.username=$USERNAME -Djib.to.auth.password=$PASSWORD



		Build & Push Approach 4 / Use -PbuildImageAndPush and use the "docker login" command to set credentials
        -------------------------------------------------------------------------------------------------------
		a. Login to docker
		   unix> docker login
		   username: traderres
		   password

		b. Build and push to your docker repo
		   unix> mvn clean package -Pprod -PbuildImageAndPush



		Build & Push Approach 5 / Use -PbuildImage to build it to your local docker daemon and push it up manually
        ----------------------------------------------------------------------------------------------------------
		a. Login to docker  (to set your docker credentials and allow you to push the tags to your private repo)
		   unix> docker login

		b. Build the image and store it in your local docker daemon
		   unix> mvn clean package -Pprod -PbuildImage

		c. Push each image up to the repo
		   unix> docker push traderres/my-private-repo:sync-service-2.2.2-SNAPSHOT
		   unix> docker push traderres/my-private-repo:backend-2.2.2-SNAPSHOT


 9. Verify that the files were uploaded to your docker repo
    a. Go to https://hub.docker.com
    b. Enter your docker username/password
    c. Go to your private repo -> tags
    d. Verify that it builds the image and pushes it to your repo:


