How to Configure Keycloak to run in SSL and Configure Spring Boot to use it
---------------------------------------------------------------------------
Problem:  I want to update my spring boot webapp to use keycloak for security
Solution: Install keycloak, configure keycloak, configure spring boot t use keycloak openid for security



Procedure
---------
 1. Create a Certificate Authority
    Import the public root.pem into your browser (as a trusted authority)

 2. Use the Certificate Authority to create a client cert with the CN=smith.john
    Import the client cert into your browser

 3. Use the Certificate Authority to create a server cert with "cn=localhost.localdomain, ou=Components, ou=whatever, c=US"
    NOTE:  Firefox uses subject alternative names.  So make sure you have a subject alternative name with this hostname

    Put the keystore here:   /home/adam/intellijProjects/sf328/sf328-backend/src/main/prod_resources/webapp.keystore.jks
    Put the truststore here: /home/adam/intellijProjects/sf328/sf328-backend/src/main/prod_resources/webapp.truststore.jks

    Create the server cert using -dname -dname "cn=localhost.localdomain, ou=Components, ou=whatever, c=US"
    So, the first step in creating the server cert should look something like this:
    unix> export ALIAS=devKeystore
    unix> keytool -genkey -v -alias ${ALIAS}  -dname "cn=localhost.localdomain, ou=Components, ou=whatever, c=US"  -keysize 4096 -keyalg RSA -sigalg SHA256withRSA  -keystore myKeystore.jks -validity 3600

    The name should be a hostname that matches in /etc/hosts or is a real DNS name
    We use localhost.localdomain because it is found in /etc/hosts with the IP of 127.0.0.1


    NOTE:
      A) The keycloak startup script should have --hostname=localhost.localdomain   (so it is listening with this host)
      B) The keycloak's server cert  should have CN=localhost.localdomain *AND*
      C) The application.yaml in the spring security should have
             		spring.security.oauth2.client.provider.keycloak.issuer-uri: https://localhost.localdomain:8444/realms/MyRealm
             		spring.security.oauth2.resourceserver.jwt.issuer-uri: https://localhost.localdomain:8444/realms/MyRealm




 4. Enable SSL in keycloak
    NOTE:  To run locally, we are using the *SAME* keystore and truststore for the webapp and keycloak
           To run on AWS,  we would have    *DIFFERENT* keystores for the webapp and keycloak

    a. Create a unix script that will startup keycloak with SSL
       unix> cd ~/Downloads/keycloak-21.0.1/
       unix> vi start.kc.ssl.sh


####################################################################################################################
# Filename:   start.kc.ssl.sh
#
# Purpose:
#     Run keycloak in SSL mode
#
# ASSUMPTIONS:
#   1) You ran bin/kc.sh build  (first)
#   2) You have a Java 11 JDK
#
# NOTES:
#   --https-client-auth=<none|request|required>       "request" means keycloak will also accept requests without a cert but validates cert if it exists
#   --hostname=localhost.localdomain                  tells it to listen on the hostname called localhost.localdomain
####################################################################################################################
export JAVA_HOME=/usr/java/jdk-11.0.12
export PATH=${JAVA_HOME}/bin:$PATH
export KEYCLOAK_ADMIN=admin
export KEYCLOAK_ADMIN_PASSWORD=secret
bin/kc.sh start --http-enabled=false --https-port=8444 --https-key-store-file=/home/adam/intellijProjects/sf328/sf328-backend/src/main/prod_resources/webapp.keystore.jks --https-key-store-type=JKS --https-key-store-password=changeit --https-trust-store-file=/home/adam/intellijProjects/sf328/sf328-backend/src/main/prod_resources/webapp.truststore.jks --https-trust-store-type=JKS  --https-trust-store-password=changeit --https-client-auth=request  --log-level=INFO --hostname-strict-https=false --hostname-strict=false --hostname=localhost.localdomain


    b. Make the script executable
       unix> chmod u+x start.kc.ssl.sh


    c. Rebuild keycloak config
       unix> cd ~/Downloads/keycloak-21.0.1/
       unix> bin/kc.sh build   # To rebuild the configuration


 5. Startup Keycloak in SSL
    unix> cd ~/Downloads/keycloak-21.0.1/
    unix> ./start.kc.ssl.sh

 6. Import the root.pem (public cert of your self-signed CA into your browser)

 7. Verify that you can connect to keycloak
    a. Connect to https://localhost.localdomain:8444/
    b. Press "Administration Console"
    c. Enter the Keycloak admin credentials
       username=admin
       password=secret



Part 2: Configure Keycloak's realm and client
---------------------------------------------
 1. Select Realms -> Create new realm: MyRealm


 2. Create an x509 authentication flow
    a. Click on Authentication
    b. Click on browser
    c. Selection Action -> Duplicate
       Name:  x509 authentication flow
    d. Delete Everything
    e. Add Cookie   with Requirement=Alternative

    f. Press "Add step"
       1) Press the "next" button a few times until you see x509/Validate Username Form
       2) Select x509/Validate Username Form
       3) Change X509/Validate Username From to Alternate
       4) Press the "Settings" button

       5) In the X509/Validate Username Form Config

          Alias:                                        x509 configuration
          User Identity Source:                         Match SubjectDN using regular expression
          Regular expression to extract user identity:  cn=(.*?)(?:,|$)
          User mapping method:                          Username or Email
          Check certificate validity:                   On
          Bypass identity confirmation                  On

       6) In x509 authentication flow, select Action -> Bind flow
          Choose "Browser flow"
          Press "Save"




 3. Create the client: sf328-webapp
    a. Click on Clients
    b. Press "Create client"

    General Settings
      Client type:           OpenID Connect
      Client ID:             sf328-webapp
      Name:                  SF328 Submissions
      Always display in UI:  Off
      Press "Next"
      Press "Next"
      Press "Save"

    Access Settings:
    Root URL:              https://localhost.localdomain:8443/sf
    Home URL:              https://localhost.localdomain:8443/sf

    Capability Config:
      Client authentication  On
      Authorization          On
      Authentication Flow:   Check Standard flow

    Login Settings
       Login theme:               keycloak
       Consent required:          Off
       Display client on screen:  Off

    Press "Save"


 4. Click on SF328-webapp / Credentials Tab
    Client Authenticator:  Client ID and Secret


 5. Click on "Advanced"
    Go to Authentication flow overrides
    Browser Flow:  x509 authentication flow
    Press "Save"


 6. Create the realm role
    a. Create a role called SF328_USER


 7. Assign that role to your test user
    a. Click on Users
    b. Press "Add User"
    c. Username:       Lastname.first

    d. Click on "role Mappings"
    e. Press Assign Role
    f. Assign the SF328_USER role to this user


 8. Tell keycloak to provide the roles to spring boot
    a. Click on Client Scopes
    b. Select roles
    c. In the settings for 'roles'
       Include in token scope: On

    d. Click on Client Scopes
    e. Select roles
    f. Select Mappers
    g. Select Realm Roles
    f. In the settings for "Realm Role'
          Add to ID Token:     On
          Add to access token: On
          Add to userinfo:     On





Part 3: Configure Web App to use oauth2 for authentication
-----------------------------------------------------------
 1. Add these maven dependencies to your backend/pom.xml

    <dependency>
      <!-- Sprint Boot / Use OAuth2/OpenID Connect client as my authentication client -->
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-oauth2-client</artifactId>
    </dependency>

    <dependency>
      <!-- Spring Boot / Tell Spring Security to use the keycloak server for identity control -->
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
    </dependency>

	<dependency>
	    <!-- You might need to explicitly set this dependency                          -->
	    <!-- If you get a JWSVerificationKeySelector java.lang.NoSuchMethodError, then -->
	    <!--   1) Find the version of nimbus-jose-jwt that is being used by the spring-boot-starter-oauth2-client and spring-boot-starter-oauth2-resource-server -->
	    <!--   2) It is likely that there is a mis-match                               -->
	    <!--   3) And, explicitly set it to the later version.                         -->
	    <!--      For Spring Boot 2.7.1, I explicitly set it to 9.22                   -->
		<groupId>com.nimbusds</groupId>
		<artifactId>nimbus-jose-jwt</artifactId>
		<version>9.22</version>
	</dependency>



 2. Add this profile to your application.yaml

		---
		#################################################################################################
		#            L O C A L      O A U T H 2        P R O F I L E
		# Prod Profile
		#  1) use the local database
		#################################################################################################
		spring.profiles: local_oauth2

		# So, we're running in HTTPS mode but using a hard-coded principal for security
		use.hardcoded.authenticated.principal: false


		##########################################################
		# Keycloak Settings for Spring Security
		##########################################################
		spring.security.oauth2.client.registration.keycloak.client-id: sf328-webapp
		spring.security.oauth2.client.registration.keycloak.client-secret: EZNI1jBMiWikhmYuIF2aIL0ULfkgzZHA
		spring.security.oauth2.client.registration.keycloak.authorization-grant-type: authorization_code
		spring.security.oauth2.client.registration.keycloak.scope: openid,email,profile

		spring.security.oauth2.client.provider.keycloak.issuer-uri: https://localhost.localdomain:8444/realms/MyRealm
		spring.security.oauth2.client.provider.keycloak.user-name-attribute: preferred_username

		spring.security.oauth2.resourceserver.jwt.issuer-uri: https://localhost.localdomain:8444/realms/MyRealm




		##########################################################
		# SSL Settings
		##########################################################
		server:
		  port: 8443
		  ssl:
			key-store: sf328-backend/src/main/prod_resources/webapp.keystore.jks
			key-store-password: changeit
			key-store-type: JKS
			client-auth: need
			trust-store: sf328-backend/src/main/prod_resources/webapp.truststore.jks
			trust-store-password: changeit
			trust-store-type: JKS
			enabled: true


		# Secure the cookies
		server.servlet.session.cookie.secure: true
		server.servlet.session.cookie.http-only: true



		##########################################################
		# Database Settings
		##########################################################
		app.datasource:
		  driver-class-name: org.postgresql.Driver
		  url: jdbc:postgresql://localhost:5432/sf328_db
		  username: sf328_user
		  password: secret
		  schema: sf328_db
		  maxPoolSize: 15
		  connectionTimeout: 60000
		  database-name: sf328_db


		###########################################################
		## ElasticSearch Settings
		###########################################################
		es:
		  url: http://localhost:9201
		  ssl_enabled: false




		##########################################################
		# File System Settings
		##########################################################
		root.dir:        ${java.io.tmpdir}             # Root directory to hold all DAS files
		sf328.root.dir:  ${root.dir}/sf328             # Root directory to hold all sf328 files
		das.user.dir:    ${root.dir}/das/users         # Root directory to hold all DAS user files




		##########################################################
		# SF328 Lifespan Settings
		##########################################################
		sf328.out.of.date.after.days:     365    # Number of days after an SF328 has been submitted before it's considered obsolete



 3. Create this class:  MyUserInfo   (holds additional information stored in the session)

		 package com.lessons.security;

		 import org.apache.commons.lang3.StringUtils;
		 import org.springframework.security.core.GrantedAuthority;
		 import java.io.Serializable;
		 import java.util.Collection;
		 import java.util.List;


		 public class MyUserInfo implements Serializable {

			 private String usernameUID;                           // The part of the Cn=.... that holds this user's client name (from PKI client cert)
			 private String usernameDN;                            // The entire DN string    (from the PKI client cert)
			 private List<GrantedAuthority> grantedAuthorities;    // List of roles for this user (found in the database)
			 private Integer id;                                   // Holds the user's ID in the database
			 private boolean userAcknowledgedMessage = false;
			 private boolean isLocked;
			 private boolean rolesAreConflicting = false;
			 private String rolesAreConflictingMessage;


			 public String getUsername() {
				 return this.usernameUID;
			 }


			 /**
			  * @return an array of GrantedAuthority objects for this user
			  */
			 public Collection<? extends GrantedAuthority> getAuthorities() {
				 // Must implement this method in order to implement the UserDetails interface
				 return this.grantedAuthorities;
			 }


			 public boolean getIsLockedOut() {
				 return this.isLocked;
			 }


			 public List<GrantedAuthority> getGrantedAuthorities() {
				 return grantedAuthorities;
			 }



			 public Integer getId() {
				 return id;
			 }

			 public String toString() {
				 return ("Roles=" + StringUtils.join(this.grantedAuthorities, ",") +
						 " UID=" + this.usernameUID +
						 " DN=" + this.usernameDN);
			 }

			 public MyUserInfo withId(Integer id) {
				 this.id = id;
				 return this;
			 }

			 public MyUserInfo withUsernameUID(String usernameUID) {
				 this.usernameUID = usernameUID;
				 return this;
			 }

			 public MyUserInfo withUsernameDn(String usernameDN) {
				 this.usernameDN = usernameDN;
				 return this;
			 }

			 public MyUserInfo withGrantedAuthorities(List<GrantedAuthority> grantedAuthorities) {
				 this.grantedAuthorities = grantedAuthorities;
				 return this;
			 }


			 public MyUserInfo withIsLocked(boolean aIsLocked) {
				 this.isLocked = aIsLocked;
				 return this;
			 }

			 public MyUserInfo withRolesAreConflicting(boolean aRolesAreConflicting) {
				 this.rolesAreConflicting = aRolesAreConflicting;
				 return this;
			 }

			 public MyUserInfo withRolesAreConflictingMessage(String aRolesAreConflictingMessage) {
				 this.rolesAreConflictingMessage = aRolesAreConflictingMessage;
				 return this;
			 }

			 public boolean getUserAcknowledgedMessage() {
				 return userAcknowledgedMessage;
			 }

			 public void setUserAcknowledgedMessage() {
				 this.userAcknowledgedMessage = true;
			 }

			 public boolean isRolesAreConflicting() {
				 return rolesAreConflicting;
			 }

			 public String getRolesAreConflictingMessage() {
				 return rolesAreConflictingMessage;
			 }

		 }



 4. Create this class:  MyDefaultOidcUser         (Replaces the DefaultOidcUser class)

		 package com.lessons.security;

		 import org.springframework.security.core.GrantedAuthority;
		 import org.springframework.security.oauth2.core.oidc.OidcIdToken;
		 import org.springframework.security.oauth2.core.oidc.OidcUserInfo;
		 import org.springframework.security.oauth2.core.oidc.user.DefaultOidcUser;

		 import java.util.Collection;

		 public class MyDefaultOidcUser extends DefaultOidcUser {

			 private MyUserInfo myUserInfo;

			 public MyDefaultOidcUser(Collection<? extends GrantedAuthority> authorities, OidcIdToken idToken) {
				 super(authorities, idToken);
			 }

			 public MyDefaultOidcUser(Collection<? extends GrantedAuthority> authorities, OidcIdToken idToken, String nameAttributeKey) {
				 super(authorities, idToken, nameAttributeKey);
			 }

			 public MyDefaultOidcUser(Collection<? extends GrantedAuthority> authorities, OidcIdToken idToken, OidcUserInfo userInfo) {
				 super(authorities, idToken, userInfo);
			 }

			 public MyDefaultOidcUser(Collection<? extends GrantedAuthority> authorities, OidcIdToken idToken, OidcUserInfo userInfo, String nameAttributeKey) {
				 super(authorities, idToken, userInfo, nameAttributeKey);
			 }

			 public MyDefaultOidcUser(MyUserInfo aUserInfo, Collection<? extends GrantedAuthority> authorities, OidcIdToken idToken, OidcUserInfo userInfo) {
				 super(authorities, idToken, userInfo);
				 this.myUserInfo = aUserInfo;
			 }


			 public MyUserInfo getMyUserInfo() {
				 return this.myUserInfo;
			 }
		 }





 5. Create this class:  AuthenticationService (that loads data into the principal)

		package com.lessons.services;

		import com.lessons.models.ConflictingRolesDTO;
		import com.lessons.models.InitialUserInfoDTO;
		import com.lessons.security.MyDefaultOidcUser;
		import com.lessons.security.MyUserInfo;
		import org.slf4j.Logger;
		import org.slf4j.LoggerFactory;
		import org.springframework.jdbc.core.JdbcTemplate;
		import org.springframework.security.core.Authentication;
		import org.springframework.security.core.GrantedAuthority;
		import org.springframework.security.core.authority.SimpleGrantedAuthority;
		import org.springframework.security.oauth2.core.oidc.user.OidcUser;
		import org.springframework.stereotype.Service;

		import javax.annotation.Resource;
		import javax.servlet.ServletException;
		import javax.servlet.http.HttpServletRequest;
		import javax.servlet.http.HttpServletResponse;
		import javax.sql.DataSource;
		import java.io.IOException;
		import java.util.ArrayList;
		import java.util.List;
		import java.util.Map;
		import java.util.regex.Matcher;
		import java.util.regex.Pattern;

		@Service
		public class AuthenticationService {
			private static final Logger logger = LoggerFactory.getLogger(AuthenticationService.class);

			@Resource
			private DataSource dataSource;

			@Resource
			private UserService userService;


			private static final Pattern patExtractCN = Pattern.compile("cn=(.*?)(?:,|/|\\z)", Pattern.CASE_INSENSITIVE);



			/**
			 * @param aRequest
			 * @param aResponse
			 * @param aAuthentication
			 * @throws Exception
			 */
			public void onAuthenticationSuccessForOauth2(HttpServletRequest aRequest,
														 HttpServletResponse aResponse,
														 Authentication aAuthentication) throws IOException, ServletException {
				logger.debug("onAuthenticationSuccessForOauth2() started");

				MyDefaultOidcUser myDefaultOidcUser = (MyDefaultOidcUser) aAuthentication.getPrincipal();

				// TODO: Mark this user as authenticated


				logger.debug("onAuthenticationSuccessForOauth2() finished");
			}



			public MyUserInfo generateUserInfoUsingOauth2Roles(OidcUser aOidcUser) {
				String userUID = aOidcUser.getName();

				List<GrantedAuthority> oauth2RolesGranted = new ArrayList<>();

				// Get the roles from keycloak and put them into the object called oauth2RolesGranted
				Map<String, Object> realmAccessMap = (Map<String, Object>) aOidcUser.getAttributes().get("realm_access");
				if ((realmAccessMap != null) && (realmAccessMap.size() == 1)) {
					List<String> roleNames = (List<String>) realmAccessMap.get("roles");

					if (roleNames != null) {
						for (String roleName: roleNames) {
							GrantedAuthority grantedAuthority = new SimpleGrantedAuthority("ROLE_" + roleName);
							oauth2RolesGranted.add(grantedAuthority);
						}
					}

				}

				// Get the list of the Citadel Roles from the db
				List<String> allCitadelRolesInDatabase = getListOfCitadelRolesFromDatabase();

				ConflictingRolesDTO conflictingRolesDTO = new ConflictingRolesDTO(oauth2RolesGranted, allCitadelRolesInDatabase);


				// Get the user's userId from the database (or generate one)
				InitialUserInfoDTO userInfoDTO = userService.getInitialUserInfoOrInsertRecord(userUID);

				// The list of allRolesGranted = all citadel roles + all internal roles granted
				List<GrantedAuthority> allRolesGranted = new ArrayList<>(oauth2RolesGranted.size() + userInfoDTO.getInternalRolesGranted().size() );
				allRolesGranted.addAll(oauth2RolesGranted);
				allRolesGranted.addAll( userInfoDTO.getInternalRolesGranted());

				// Create a UserInfo object with information from the database and the keycloak server
				MyUserInfo userInfo = new MyUserInfo()
						.withId( userInfoDTO.getUserId() )
						.withIsLocked( userInfoDTO.getIsLocked() )
						.withUsernameUID( aOidcUser.getName() )
						.withGrantedAuthorities(allRolesGranted)
						.withRolesAreConflicting(conflictingRolesDTO.isRolesAreConflicting())
						.withRolesAreConflictingMessage(conflictingRolesDTO.getRolesAreConflictingMessage());

				return userInfo;
			}




			public MyUserInfo generateUserInfoForDevelopment(Authentication authentication) {

				String userUID = "my_sf328_user2";
				String userDN = "3.2.12.144549.1.9.1=#161760312e646576,CN=my_test_user2,OU=Hosts,O=ZZTop.Org,C=ZZ";

				if ((authentication != null) && (authentication.getPrincipal() != null)) {
					userDN = authentication.getPrincipal().toString();
					userUID = getCnValueFromLongDnString(userDN);
					if (userUID == null) {
						userUID = "my_sf328_user2";
					}
				}

				// Create a list of granted authorities
				// NOTE:  The roles *MUST* start with a ROLE_ prefix for the @PreAuthorize annotations to work correctly
				List<GrantedAuthority> citadelRolesGranted = new ArrayList<>();
				citadelRolesGranted.add(new SimpleGrantedAuthority("ROLE_SF328_USER"));
				citadelRolesGranted.add(new SimpleGrantedAuthority("ROLE_USER_FOUND_IN_VALID_LIST_OF_USERS"));

				// Get the list of the Citadel Roles from the db
				List<String> citadelRoles = getListOfCitadelRolesFromDatabase();

				ConflictingRolesDTO conflictingRolesDTO = new ConflictingRolesDTO(citadelRolesGranted, citadelRoles);


				// Get the user's userId from the database (or generate one)
				// NOTE:  Use the synchronized version of this method when running in local dev mode
				InitialUserInfoDTO userInfoDTO = this.userService.getInitialUserInfoOrInsertRecordSynchronized(userUID);

				// The list of allRolesGranted = all citadel roles + all internal roles granted
				List<GrantedAuthority> allRolesGranted = new ArrayList<>(citadelRolesGranted.size() + userInfoDTO.getInternalRolesGranted().size() );
				allRolesGranted.addAll(citadelRolesGranted);
				allRolesGranted.addAll( userInfoDTO.getInternalRolesGranted());

				// Create a bogus UserInfo object
				// NOTE:  I am hard-coding the user's userid=25
				MyUserInfo userInfo = new MyUserInfo()
						.withId( userInfoDTO.getUserId() )
						.withIsLocked( userInfoDTO.getIsLocked() )
						.withUsernameUID(userUID)
						.withUsernameDn(userDN)
						.withGrantedAuthorities(allRolesGranted)
						.withRolesAreConflicting(conflictingRolesDTO.isRolesAreConflicting())
						.withRolesAreConflictingMessage(conflictingRolesDTO.getRolesAreConflictingMessage());

				if (userInfoDTO.getIsLocked() ) {
					logger.info("{} successfully logged-in.", userUID);
				}


				// When running in local development, disable the acknowledgement popup
				userInfo.setUserAcknowledgedMessage();

				return userInfo;
			}




			public List<String> getListOfCitadelRolesFromDatabase() {
				JdbcTemplate jt = new JdbcTemplate(this.dataSource);

				String sql = "select name from roles where is_citadel_role=true";

				List<String> citadelRolesList = jt.queryForList(sql, String.class);

				return citadelRolesList;
			}



			private static String getCnValueFromLongDnString(String userDN) {
				logger.debug("getCnValueFromLongDnString()  userDN={}", userDN);
				String cnValue = null;
				// Use the regular expression pattern to getByUserId the value part of "CN=value"
				Matcher matcher = patExtractCN.matcher(userDN);
				if (matcher.find()) {
					cnValue = matcher.group(1);
				}

				logger.debug("getCnValueFromLongDnString() returns -->{}<--", cnValue);
				return cnValue;
			}


		}





 6. Create this class:  OAuth2LoginSuccessHandler

		package com.lessons.security;

		import com.lessons.services.AuthenticationService;
		import org.slf4j.Logger;
		import org.slf4j.LoggerFactory;
		import org.springframework.security.core.Authentication;
		import org.springframework.security.web.authentication.SavedRequestAwareAuthenticationSuccessHandler;
		import org.springframework.stereotype.Component;

		import javax.annotation.Resource;
		import javax.servlet.ServletException;
		import javax.servlet.http.HttpServletRequest;
		import javax.servlet.http.HttpServletResponse;
		import java.io.IOException;

		/*
		 * Create a success handler class that extends SavedRequestAwareAuthenticationSuccessHandler
		 * -- This ensures that upon successful authentication, the user is taken to the user's ORIGINAL url
		 */
		@Component
		public class OAuth2LoginSuccessHandler extends SavedRequestAwareAuthenticationSuccessHandler {
			private static final Logger logger = LoggerFactory.getLogger(OAuth2LoginSuccessHandler.class);

			@Resource
			private AuthenticationService authenticationService;

			@Override
			public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response,
												Authentication authentication) throws IOException, ServletException {

				logger.debug("onAuthenticationSuccess() started");

				// The user successfully authenticated against the OAUTH2 Server

				// Create the UserInfo object and set it as the principal
				//   1) Replace the OAuth2 Principal object with our own UserInfo object
				//   2) Update the database to indicate that the user successfully logged-in
			   this.authenticationService.onAuthenticationSuccessForOauth2(request, response, authentication);


			   // Proceed to the user's original URL
			   super.onAuthenticationSuccess(request, response, authentication);
			}


		}



 7. Update your SpringSecurityConfig with this:

		package com.lessons.security;

		import com.lessons.services.AuthenticationService;
		import org.springframework.beans.factory.annotation.Value;
		import org.springframework.boot.web.servlet.FilterRegistrationBean;
		import org.springframework.context.annotation.Bean;
		import org.springframework.context.annotation.Configuration;
		import org.springframework.core.Ordered;
		import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;
		import org.springframework.security.config.annotation.web.builders.HttpSecurity;
		import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
		import org.springframework.security.config.http.SessionCreationPolicy;
		import org.springframework.security.oauth2.client.oidc.userinfo.OidcUserRequest;
		import org.springframework.security.oauth2.client.oidc.userinfo.OidcUserService;
		import org.springframework.security.oauth2.client.userinfo.OAuth2UserService;
		import org.springframework.security.oauth2.core.oidc.user.OidcUser;
		import org.springframework.security.web.SecurityFilterChain;
		import org.springframework.web.filter.ForwardedHeaderFilter;

		import javax.annotation.Resource;
		import javax.servlet.DispatcherType;


		@Configuration
		@EnableWebSecurity
		@EnableGlobalMethodSecurity(prePostEnabled = true)         // Needed for @PreAuthorize to work
		public class SpringSecurityConfig  {

			@Resource
			private MyRequestHeaderAuthFilter requestHeaderAuthFilter;

			@Resource
			private OAuth2LoginSuccessHandler oAuth2LoginSuccessHandler;

			@Resource
			private AuthenticationService authenticationService;

			@Value("${server.ssl.enabled}")
			private boolean sslEnabled;




			private OAuth2UserService<OidcUserRequest, OidcUser> oidcUserService() {
				final OidcUserService delegate = new OidcUserService();

				return (OidcUserRequest aOidcUserRequest) -> {
					// Get the OidcUser object (that holds information from Keycloak)
					OidcUser oidcUser = delegate.loadUser(aOidcUserRequest);

					// Get the MyUserInfo object (that holds additional info from our database)
					MyUserInfo myUserInfo = this.authenticationService.generateUserInfoUsingOauth2Roles(oidcUser);

					// Create a new Principal object that holds MyUserInfo *AND* the original token information from keycloak
					MyDefaultOidcUser myDefaultOidcUser = new MyDefaultOidcUser(myUserInfo, myUserInfo.getGrantedAuthorities(), oidcUser.getIdToken(), oidcUser.getUserInfo());
					return myDefaultOidcUser;
				};
			}



			@Bean
			public SecurityFilterChain securityFilterChain(HttpSecurity aHttpSecurity) throws Exception {

				if (sslEnabled) {

					// Running in production mode using OAuth2 authentication
					aHttpSecurity.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.ALWAYS)
							.and()
								.authorizeRequests()
									.antMatchers("/assets/**",  "**.js", "**.css",  "/error").permitAll()
									.anyRequest()
									.authenticated()
							.and()
								.requiresChannel().anyRequest().requiresSecure()
							.and()
								.oauth2Login()

									/*
									 * Update the Principal object stored in the session
									 * Replace the defaultOidcUser with MyDefaultOidcUser object   (that holds the additional MyUserInfo)
									 */
									.userInfoEndpoint(userInfo -> userInfo
											.oidcUserService(this.oidcUserService()))


									  /*
									   * The oAuth2LoginSuccessHandler success handler class will do 2 things:
									   *   1) Update the database to indicate that the user successfully authenticated
									   *   2) Redirect the user from keycloak to the user's ORIGINAL requested url (because it extends SavedRequestAwareAuthenticationSuccessHandler)
									   */
									.successHandler(this.oAuth2LoginSuccessHandler)

							.and()
								.csrf().disable();


				}

				else {


					// Running in http / local dev mode

					 aHttpSecurity.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.ALWAYS)
							.and()
								.authorizeRequests()     // Filters out any URLs that are ignored.  This should be before any authorization filters
								.antMatchers("/assets/**",  "**.js", "**.css",  "/error").permitAll()
								.anyRequest()
								.authenticated()
							.and()
								.requiresChannel().antMatchers("/**").requiresInsecure()
							.and()
								.addFilter(requestHeaderAuthFilter)
								.headers().frameOptions().disable()                       // By default X-Frame-Options is set to denied.
							 .and()
								.anonymous().disable()
								.csrf().disable();

				}

				return aHttpSecurity.build();
			}


			@Bean
			public FilterRegistrationBean<ForwardedHeaderFilter> forwardedHeaderFilter() {
			  // ForwardedHeaderFilter handles non-standard headers
			  //   X-Forwarded-Host, X-Forwarded-Port, X-Forwarded-Proto, X-Forwarded-Ssl, and X-Forwarded-Prefix.
			  ForwardedHeaderFilter filter = new ForwardedHeaderFilter();

			  FilterRegistrationBean<ForwardedHeaderFilter> registration = new FilterRegistrationBean<>(filter);
			  registration.setDispatcherTypes(DispatcherType.REQUEST, DispatcherType.ASYNC, DispatcherType.ERROR);
			  registration.setOrder(Ordered.HIGHEST_PRECEDENCE);
			  return registration;
			}
		}




 8. Update your MyRequestHeaderAuthFilter


		package com.lessons.security;

		import org.slf4j.Logger;
		import org.slf4j.LoggerFactory;
		import org.springframework.beans.factory.annotation.Value;
		import org.springframework.security.web.authentication.preauth.RequestHeaderAuthenticationFilter;
		import org.springframework.stereotype.Component;

		import javax.annotation.PostConstruct;
		import javax.annotation.Resource;
		import javax.servlet.http.HttpServletRequest;


		@Component
		public class MyRequestHeaderAuthFilter extends RequestHeaderAuthenticationFilter
		{
			private static final Logger logger = LoggerFactory.getLogger(MyRequestHeaderAuthFilter.class);

			@Resource
			private MyAuthenticationManager myAuthenticationManager;

			@Value("${use.hardcoded.authenticated.principal}")
			private boolean useHardcodedAuthenticatedPrincipal;

			@PostConstruct
			public void init() {
				this.setAuthenticationManager(myAuthenticationManager);
			}


			/*
			 * getPreAuthenticatedPrincipal()
			 *
			 * This is called when a request is made, the returned object identifies the
			 * user and will either be {@literal null} or a String.
			 *
			 * This method will throw an exception if
			 * exceptionIfHeaderMissing is set to true (default) and the required header is missing.
			 */
			@Override
			protected Object getPreAuthenticatedPrincipal(HttpServletRequest request)
			{
				logger.debug("getPreAuthenticatedPrincipal() called");

				// Get the principal from the header
				String userDnFromHeader = request.getHeader("SSL_CLIENT_S_DN");
				logger.debug("userDnFromHeader from header -->{}<---", userDnFromHeader);

				if (userDnFromHeader == null) {

					if (useHardcodedAuthenticatedPrincipal) {
						// No header was found, but I am in dev mode or "local prod" mode.  So, set a hard-coded user name
						logger.debug("No header was found, so using hard-coded header 'Bogus_user'");
						userDnFromHeader = "Bogus_user";
					}
				}

				// If this method returns null, then the user will see a 403 Forbidden Message
				logger.debug("getPreAuthenticatedPrincipal() returns -->{}<--", userDnFromHeader);
				return userDnFromHeader;
			}



		}


 9. Update MyAuthenticationManager  (so it creates a fake user when running locally)

		 package com.lessons.security;

		 import com.lessons.services.AuthenticationService;
		 import org.slf4j.Logger;
		 import org.slf4j.LoggerFactory;
		 import org.springframework.security.authentication.AuthenticationManager;
		 import org.springframework.security.core.Authentication;
		 import org.springframework.security.core.AuthenticationException;
		 import org.springframework.security.core.context.SecurityContextHolder;
		 import org.springframework.security.oauth2.core.oidc.OidcIdToken;
		 import org.springframework.security.oauth2.core.oidc.OidcUserInfo;
		 import org.springframework.security.web.authentication.preauth.PreAuthenticatedAuthenticationToken;
		 import org.springframework.stereotype.Component;

		 import javax.annotation.Resource;
		 import java.time.Instant;
		 import java.time.temporal.ChronoUnit;
		 import java.util.HashMap;
		 import java.util.Map;

		 @Component
		 public class MyAuthenticationManager implements AuthenticationManager {
			 private static final Logger logger = LoggerFactory.getLogger(MyAuthenticationManager.class);

			 @Resource
			 private AuthenticationService authenticationService;


			 @Override
			 public Authentication authenticate(Authentication authentication) throws AuthenticationException {
				 logger.debug("authenticate() started.   authentication={}", authentication);

				 if (SecurityContextHolder.getContext().getAuthentication() != null) {
					 // Users is already authenticated, so do nothing
					 return  SecurityContextHolder.getContext().getAuthentication();
				 }

				 // Load the fake data
				 MyUserInfo userInfo = this.authenticationService.generateUserInfoForDevelopment(authentication);

				 String tokenValue = "eyJhbGciOiJSUzI1NiIsInR5cCIgOiAiSldUIiwia2lkIiA6ICI2UEtSMURxUk9IS29lZ0s5ODJSWEhFRmlUVjZRcmc1emdXNUxPQVZCTkV3In0.eyJleHAiOjE2Nzg4Mjg0NTMsImlhdCI6MTY3ODgyODE1MywiYXV0aF90aW1lIjoxNjc4ODI4MTUzLCJqdGkiOiI0ZWNkMWM3Yi1jMzU4LTQ4MDktOGI5OS01MzAzZDNhMGYxNjciLCJpc3MiOiJodHRwczovL2xvY2FsaG9zdC5sb2NhbGRvbWFpbjo4NDQ0L3JlYWxtcy9NeVJlYWxtIiwiYXVkIjoic2YzMjgtd2ViYXBwIiwic3ViIjoiMDZkNGY2NTYtZTI3OC00Y2VkLWI4ODctYTRkY2IxZjdiZDdmIiwidHlwIjoiSUQiLCJhenAiOiJzZjMyOC13ZWJhcHAiLCJub25jZSI6Ii00cUk3WUk4ampTaXhobkFQaFR2VXhQY1pMVkg5d0pYa0FBMm9yd3B2RnciLCJzZXNzaW9uX3N0YXRlIjoiYjg5MDczNmItZDkzMy00NGRlLWI2NjktNTIzNjQ3YWI3NDczIiwiYXRfaGFzaCI6InhCZ1Ftd0FMeGFqTEtIaTVxQ1RrMmciLCJhY3IiOiIxIiwic2lkIjoiYjg5MDczNmItZDkzMy00NGRlLWI2NjktNTIzNjQ3YWI3NDczIiwicmVzb3VyY2VfYWNjZXNzIjp7ImFjY291bnQiOnsicm9sZXMiOlsibWFuYWdlLWFjY291bnQiLCJtYW5hZ2UtYWNjb3VudC1saW5rcyIsInZpZXctcHJvZmlsZSJdfX0sImVtYWlsX3ZlcmlmaWVkIjpmYWxzZSwicmVhbG1fYWNjZXNzIjp7InJvbGVzIjpbImRlZmF1bHQtcm9sZXMtbXlyZWFsbSIsIm9mZmxpbmVfYWNjZXNzIiwidW1hX2F1dGhvcml6YXRpb24iLCJTRjMyOF9VU0VSIl19LCJuYW1lIjoiQWRhbSBSZXNuaWNrIiwicHJlZmVycmVkX3VzZXJuYW1lIjoicmVzbmljay5hZGFtIiwiZ2l2ZW5fbmFtZSI6IkFkYW0iLCJmYW1pbHlfbmFtZSI6IlJlc25pY2sifQ.Qsbo5hFtjbiexBgGpohno-nRi-0z4g-jBKtlYv_2My_nITfQeezKhiO-GnhgR5jbLXKf2y2v5-cHAZcPyX8lCUepU68B77m9M23PRnT7os-dW0HTpFqbTIJwaOAljOW7LMMJbuUi6TpRVltMWZyP8DfeMJTtRB97Auf6bPNREAMUSSBZqw-7T30hQih7S_ZJN6BohdiPxbJ5BGidthoUOO_l8pfoGTGn66gARiGIBZpHjHP5d92WvARJKif1g5LXXkpd0I-SkCIGvBU3LS_EKpNVzTadTWwhhPPht_13Z73LtmI1Clm4FO_vSqbYeqY6PwCHTE6zf201tpzaagY0pQ";
				 Map<String, Object> claimsMap = new HashMap<>();
				 claimsMap.put("email_verified", false);
				 claimsMap.put("sub", "06d4f656-e278-4ced-b887-a4dcb1f7bd7f");
				 OidcIdToken oidcIdToken = new OidcIdToken(tokenValue, Instant.now(), Instant.now().plus(30, ChronoUnit.MINUTES), claimsMap);

				 // Create a fake keycloak UserInfo map
				 OidcUserInfo oidcUserInfo = new OidcUserInfo(claimsMap);

				 // Create a fake principal object
				 MyDefaultOidcUser myDefaultOidcUser = new MyDefaultOidcUser(userInfo, userInfo.getAuthorities(), oidcIdToken, oidcUserInfo);

				 // Return an AuthenticationToken object
				 PreAuthenticatedAuthenticationToken preApproved = new PreAuthenticatedAuthenticationToken(myDefaultOidcUser, null, userInfo.getAuthorities());
				 preApproved.setAuthenticated(true);
				 return preApproved;
			 }



		 }


10. Update the webapp to use MyUserInfo (instead of UserInfo)
    a. Copy properties from the old UserInfo to MyUserInfo

    b. Update the UserService.getUserInfo() to return a MyUserInfo object

			/**
			 * @return the MyUserInfo object from Spring-Security
			 */
			public MyUserInfo getUserInfo() {
				// Get the UserInfo object from Spring Security
				SecurityContext securityContext = SecurityContextHolder.getContext();
				if (securityContext == null) {
					throw new RuntimeException("Error in getMyUserInfo():  SecurityContext is null.  This should never happen.");
				}

				Authentication auth = securityContext.getAuthentication();
				if (auth == null) {
					throw new RuntimeException("Error in getMyUserInfo():  Authentication is null.  This should never happen.");
				}

		        // Get the MyDefaultOidcUser from the Principal
				MyDefaultOidcUser myDefaultOidcUser = (MyDefaultOidcUser) auth.getPrincipal();
				if (myDefaultOidcUser == null) {
					throw new RuntimeException("Error in getMyUserInfo():  MyDefaultOidcUser is null.  This should never happen.");
				}

		        // Get MyUserInfo from the MyDefaultOidcUser object
				MyUserInfo myUserInfo = myDefaultOidcUser.getMyUserInfo();
				if (myUserInfo == null) {
					throw new RuntimeException("Error in getMyUserInfo():  MyUserInfo is null.  This should never happen.");
				}

				return myUserInfo;
			}


    c. Make sure the old MyAuthenticationManager code that creates the UserInfo object is added to the AuthenticaitonService methods

    d. Rename UserService.getUserInfo() to UserService.getMyUserInfo()

    e. Everywhere UserService.getMyUserInfo() is called, change the UserInfo object to MyUserInfo

    f. Erase the original UserInfo object



11. Startup keycloak with ssl  (if it's not already running)
    So, it's listening on https://localhost.localdomain:8444/


12. Startup the backend with this profile  -Dspring.profiles.active=local_oauth2
    a. You may have to update your application.yaml with missing properties

    b. If you get the sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target
       Then, you can update your java cacerts to trust https://localhost.localdomain:8444/

		 1) Get the server certificate used by keycloak
			unix> openssl s_client -connect localhost.localdomain:8444


		 2) Create this file:  /tmp/keycloak.cer

		    Copy and save the certificate to here:
				-----BEGIN CERTIFICATE----- and
				-----END CERTIFICATE-----
			into a new file called /tmp/keycloak.cer


			So, the /tmp/keycloak.cer should look something like this:

			-----BEGIN CERTIFICATE-----
			UzEYMBYGA1UEChMPVS5TLiBHb3Zlcm5tZW50MQwwCgYDVQQLEwNEb0QxDDAKBgNV
			BAsTA1BLSTEVMBMGA1UEAxMMRE9EIFNXIENBLTYwMB4XDTIxMTEyOTEzMjkwNFoX
			DTIyMTIzMTEzMjkwNFoweTELMAkGA1UEBhMCVVMxGDAWBgNVBAoTD1UuUy4gR292
			ZXJubWVudDEMMAoGA1UECxMDRG9EMQwwCgYDVQQLEwNQS0kxDDAKBgNVBAsTA0RP
			RDEmMCQGA1UEAxMddGVzc2VyYWN0LXRlc3QuY2xvdWQuZGNzYS5taWwwggEiMA0G
			CSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCozqDWEwwzYGZ42S5XpW/L4dWmUPBH
			qOFdzvdOmdea6Ue94Lc5b2L3+rxGKyoIA29PIKfcz6IjcWC9ztNan1nS0nD4Mlm6
			3J3wHoGJFV803P7dBwN8eF/QtwMRFosb1Ba2aY/xQhqtdeUd4++A5dueycpHTGt9
			WxJgkeu+O1+xFjzTAZMZ996qm/ep3ddHyC9DQ2l0qTLXjlA+ik4W73naI5fdFCfq
			wQAUJzBKe5FOeHf0iP7ZbJOerb329SHwGntY6lE6OUWRX+WdntRPfUgwy8OYXjSm
			YS5taWwvY3JsL0RPRFNXQ0FfNjBfU1NMLmNybDAoBgNVHREEITAfgh10ZXNzZXJh
			Y3QtdGVzdC5jbG91ZC5kY3NhLm1pbDAWBgNVHSAEDzANMAsGCWCGSAFlAgELJDAd
			BgNVHSUEFjAUBggrBgEFBQcDAQYIKwYBBQUHAwIwHQYDVR0OBBYEFDOJk590j1uS
			lpwyT5PhN0k+t+hRMA0GCSqGSIb3DQEBCwUAA4IBAQBqKGHMo23gYjyuH4cUiu/9
			xyFeoZR7GoR+C6fl95XzJ85BUrSfW4T7v/NscuE0qS2V1wGV6bweRfiwfwnjMyip
			oP2z+jhbdx5bdB+xr5ishVKTJocH9ceI+t46Fdwp2E5+FKv7znek97rrtZHzB9l6
			6Vqm/eGxvqhaKB16IPcs3oYYfLNHk9Oogiy5muI/KuQN8ZOWZ+AuxozR1XLDgoRd
			ASDQCV+dkNRrRA2yYQw2d91cwL+5h9T+x/wLCIbj9vZMTaZcR1KFqFbuuVQftGLz
			-----END CERTIFICATE-----

		 3) Get the real path of where java is running from
			unix> readlink -f `which java`
			/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.352.b08-2.el7_9.x86_64/jre/bin/java

			Set JAVA_HOME should be the directory that holds the jre directory
			unix> export JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.352.b08-2.el7_9.x86_64


		 4) Verify that you have the path of the cacerts file
			unix> ls $JAVA_HOME/jre/lib/security/cacerts

			You should see this:
			   /usr/lib/jvm/java-1.8.0-openjdk-1.8.0.352.b08-2.el7_9.x86_64/jre/lib/security/cacerts


		 5) Update the cacerts file so it will trust the server cert
			unix> sudo keytool -import -alias "keycloak-localhost" -keystore "$JAVA_HOME/jre/lib/security/cacerts" -file /tmp/keycloak.cer
			password> changeit
			Trust this certificate: yes

			You should see this message:
			   Certificate was added to keystore




13. Connect to https://localhost.localdomain:8443/sf
    -- You should be prompted for your pki cert
    -- You should be redirected to keycloak at https://localhost.localdomain:8444/
    -- You should be redirected to webapp   at https://localhost.localdomain:8443/sf


14. Create 2 profiles:  "buildImage" and "buildImageWithoutDocker"
    a. Edit backend/pom.xml

    b. Add the "buildImage" maven profile:

        <profile>
            <!--    B U I L D    I M A G E       P R O F I L E    -->
            <id>buildImage</id>

            <build>
              <plugins>
                <plugin>
                  <groupId>com.google.cloud.tools</groupId>
                  <artifactId>jib-maven-plugin</artifactId>
                  <version>3.3.1</version>
                  <configuration>
                    <from>
                      <!-- The source image runs linux with JDK 1.8-362 -->
                      <image>eclipse-temurin:8u362-b09-jdk@sha256:3b83f3fc0d016d7536dfd5e8a98ece451061b7dbb6d5db3ddea2db30b6153b28</image>
                    </from>

                    <to>
                      <image>traderres/my-public-repo:${project.artifactId}-${project.version}</image>
                    </to>
                  </configuration>

                  <executions>
                    <execution>
                      <phase>package</phase>
                      <goals>
                        <!-- The "dockerBuild" goal requires docker to be installed -->
                        <goal>dockerBuild</goal>
                      </goals>
                    </execution>
                  </executions>

                </plugin>
              </plugins>
            </build>
          </profile>



          <profile>
             <!--    B U I L D      I M A G E      W I T H O U T    D O C K E R     P R O F I L E    -->
            <id>buildImageWithoutDocker</id>

            <build>
              <plugins>
                <plugin>
                  <groupId>com.google.cloud.tools</groupId>
                  <artifactId>jib-maven-plugin</artifactId>
                  <version>3.3.1</version>
                  <configuration>
                    <from>
                      <!-- The source image runs linux with JDK 1.8-362 -->
                      <image>eclipse-temurin:8u362-b09-jdk@sha256:3b83f3fc0d016d7536dfd5e8a98ece451061b7dbb6d5db3ddea2db30b6153b28</image>
                    </from>

                    <to>
                      <image>traderres/my-public-repo:${project.artifactId}-${project.version}</image>
                    </to>
                  </configuration>

                  <executions>
                    <execution>
                      <phase>package</phase>
                      <goals>
                        <!-- The "build" goal does not require docker to be installed -->
                        <goal>build</goal>
                      </goals>
                    </execution>
                  </executions>

                </plugin>
              </plugins>
            </build>
          </profile>


15. Build the image (without pushing it)
 	unix> mvn clean package -Pprod -PbuildImage

16. Build the image and push to the repo
    unix> cd ~/intellijProjects/app
    unix> export USERNAME=traderres      # This is the username for the  <to><image>...</image></to repository
	unix> export PASSWORD=secret         # This is the password for the <to><image>...</image></to> repository
	unix> mvn clean package -Pprod -PbuildImageWithoutDocker  -Djib.to.auth.username=$USERNAME -Djib.to.auth.password=$PASSWORD

    See learnDocker / howToBuildAndPushSpringBootImagesUsingJibMavenPlugin.txt for more approaches


When deploying on AWS, remember that you need 2 signed server-certs
 1) Server Cert #1 will be used by keycloak
    Create it with subject alternative name = hostname, external IP, and internal IP
    NOTE:  Make sure the hostname is *FIRST* in the subject alternative name

 2) Server Cert #2 will be used by the sprint boot web app
    Create it with subject alternative name = external hostname, external IP
    NOTE:  Make sure the hostname is *FIRST* in the subject alternative name